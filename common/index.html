
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
        <link rel="canonical" href="https://npucino.github.io/sandpyper/common/">
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.1.2, mkdocs-material-7.2.3">
    
    
      
        <title>common module - Sandpyper</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.f7f47774.min.css">
      
        
        <link rel="stylesheet" href="../assets/stylesheets/palette.3f5d1f46.min.css">
        
      
    
    
    
      
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CRoboto+Mono&display=fallback">
        <style>:root{--md-text-font-family:"Roboto";--md-code-font-family:"Roboto Mono"}</style>
      
    
    
    
      <link rel="stylesheet" href="../assets/_mkdocstrings.css">
    
    
      


    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="preference" data-md-color-primary="" data-md-color-accent="">
  
    
    <script>function __prefix(e){return new URL("..",location).pathname+"."+e}function __get(e,t=localStorage){return JSON.parse(t.getItem(__prefix(e)))}</script>
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#sandpyper.common" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Sandpyper" class="md-header__button md-logo" aria-label="Sandpyper" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Sandpyper
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              common module
            
          </span>
        </div>
      </div>
    </div>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
      </label>
      
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" aria-label="Clear" tabindex="-1">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        
<a href="https://github.com//npucino//sandpyper/" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
      </div>
    
  </nav>
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Sandpyper" class="md-nav__button md-logo" aria-label="Sandpyper" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    Sandpyper
  </label>
  
    <div class="md-nav__source">
      
<a href="https://github.com//npucino//sandpyper/" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        Home
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../installation/" class="md-nav__link">
        Installation
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../usage/" class="md-nav__link">
        Usage
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../contributing/" class="md-nav__link">
        Contributing
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../faq/" class="md-nav__link">
        FAQ
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="https://github.com//npucino//sandpyper//issues" class="md-nav__link">
        Report Issues
      </a>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_7" data-md-state="indeterminate" type="checkbox" id="__nav_7" checked>
      
      <label class="md-nav__link" for="__nav_7">
        Methods
        <span class="md-nav__icon md-icon"></span>
      </label>
      <nav class="md-nav" aria-label="Methods" data-md-level="1">
        <label class="md-nav__title" for="__nav_7">
          <span class="md-nav__icon md-icon"></span>
          Methods
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
  
  
  
    <li class="md-nav__item">
      <a href="../Introduction/" class="md-nav__link">
        Introduction
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../extraction%20and%20lod/" class="md-nav__link">
        Elevation analysis
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../ML%20and%20SA/" class="md-nav__link">
        Data cleaning
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../hotspot_methods/" class="md-nav__link">
        Hotspot analysis
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../bcds_method/" class="md-nav__link">
        BCDs
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../volumetrics_method/" class="md-nav__link">
        Volumetrics
      </a>
    </li>
  

          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
    
  
  
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_8" type="checkbox" id="__nav_8" checked>
      
      <label class="md-nav__link" for="__nav_8">
        API Reference
        <span class="md-nav__icon md-icon"></span>
      </label>
      <nav class="md-nav" aria-label="API Reference" data-md-level="1">
        <label class="md-nav__title" for="__nav_8">
          <span class="md-nav__icon md-icon"></span>
          API Reference
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
  
  
  
    <li class="md-nav__item">
      <a href="../sandpyper/" class="md-nav__link">
        sandpyper module
      </a>
    </li>
  

          
            
  
  
    
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" data-md-toggle="toc" type="checkbox" id="__toc">
      
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          common module
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        common module
      </a>
      
        
<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common" class="md-nav__link">
    sandpyper.common
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.add_grid_loc_coords" class="md-nav__link">
    add_grid_loc_coords()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.arr2geotiff" class="md-nav__link">
    arr2geotiff()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.check_overlaps_poly_label" class="md-nav__link">
    check_overlaps_poly_label()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.check_overlay" class="md-nav__link">
    check_overlay()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.compute_multitemporal" class="md-nav__link">
    compute_multitemporal()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.consecutive_ids" class="md-nav__link">
    consecutive_ids()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.coords_to_points" class="md-nav__link">
    coords_to_points()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.corr_baseline_distance" class="md-nav__link">
    corr_baseline_distance()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.correct_multi_detections" class="md-nav__link">
    correct_multi_detections()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.create_id" class="md-nav__link">
    create_id()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.create_spatial_id" class="md-nav__link">
    create_spatial_id()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.create_transects" class="md-nav__link">
    create_transects()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.cross_ref" class="md-nav__link">
    cross_ref()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.dissolve_shores" class="md-nav__link">
    dissolve_shores()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.error_from_gt" class="md-nav__link">
    error_from_gt()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.extract_from_folder" class="md-nav__link">
    extract_from_folder()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.extract_loc_date" class="md-nav__link">
    extract_loc_date()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.filepath_raster_type" class="md-nav__link">
    filepath_raster_type()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.fill_gaps" class="md-nav__link">
    fill_gaps()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.filter_filename_list" class="md-nav__link">
    filter_filename_list()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.find_date_string" class="md-nav__link">
    find_date_string()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.get_beachface_length" class="md-nav__link">
    get_beachface_length()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.get_coastal_Markov" class="md-nav__link">
    get_coastal_Markov()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.get_dn" class="md-nav__link">
    get_dn()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.get_elevation" class="md-nav__link">
    get_elevation()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.get_m3_m_location" class="md-nav__link">
    get_m3_m_location()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.get_opt_k" class="md-nav__link">
    get_opt_k()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.get_profile_dn" class="md-nav__link">
    get_profile_dn()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.get_profiles" class="md-nav__link">
    get_profiles()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.get_rbcd_transect" class="md-nav__link">
    get_rbcd_transect()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.get_sil_location" class="md-nav__link">
    get_sil_location()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.get_state_vol_table" class="md-nav__link">
    get_state_vol_table()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.get_terrain_info" class="md-nav__link">
    get_terrain_info()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.get_transects_vol_table" class="md-nav__link">
    get_transects_vol_table()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.getAngle" class="md-nav__link">
    getAngle()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.getCrs_from_raster_path" class="md-nav__link">
    getCrs_from_raster_path()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.getCrs_from_transect" class="md-nav__link">
    getCrs_from_transect()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.getDate" class="md-nav__link">
    getDate()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.getListOfDate" class="md-nav__link">
    getListOfDate()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.getListOfFiles" class="md-nav__link">
    getListOfFiles()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.getLoc" class="md-nav__link">
    getLoc()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.getPoint1" class="md-nav__link">
    getPoint1()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.grid_from_pts" class="md-nav__link">
    grid_from_pts()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.grid_from_shore" class="md-nav__link">
    grid_from_shore()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.images_to_dirs" class="md-nav__link">
    images_to_dirs()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.interpol_integrate" class="md-nav__link">
    interpol_integrate()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.kmeans_sa" class="md-nav__link">
    kmeans_sa()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.LISA_site_level" class="md-nav__link">
    LISA_site_level()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.plot_alongshore_change" class="md-nav__link">
    plot_alongshore_change()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.plot_sensitivity_rbcds_transects" class="md-nav__link">
    plot_sensitivity_rbcds_transects()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.plot_single_loc" class="md-nav__link">
    plot_single_loc()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.prep_heatmap" class="md-nav__link">
    prep_heatmap()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.round_special" class="md-nav__link">
    round_special()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.s2_to_rgb" class="md-nav__link">
    s2_to_rgb()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.sensitivity_tr_rbcd" class="md-nav__link">
    sensitivity_tr_rbcd()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.shoreline_from_prediction" class="md-nav__link">
    shoreline_from_prediction()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.split_transects" class="md-nav__link">
    split_transects()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.test_format" class="md-nav__link">
    test_format()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.tidal_correction" class="md-nav__link">
    tidal_correction()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.tiles_from_grid" class="md-nav__link">
    tiles_from_grid()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.toes_candidates" class="md-nav__link">
    toes_candidates()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.toes_from_slopes" class="md-nav__link">
    toes_from_slopes()
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_9" data-md-state="indeterminate" type="checkbox" id="__nav_9" checked>
      
      <label class="md-nav__link" for="__nav_9">
        Notebooks
        <span class="md-nav__icon md-icon"></span>
      </label>
      <nav class="md-nav" aria-label="Notebooks" data-md-level="1">
        <label class="md-nav__title" for="__nav_9">
          <span class="md-nav__icon md-icon"></span>
          Notebooks
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
  
  
  
    <li class="md-nav__item">
      <a href="../notebooks/1%20-%20Introduction%20and%20data%20preparation/" class="md-nav__link">
        Introduction and data preparation
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../notebooks/2%20-%20Profiles%20extraction%2C%20unsupervised%20sand%20labelling%20and%20cleaning/" class="md-nav__link">
        Profile extraction, LoD and data cleaning
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../notebooks/3%20-%20Profile%20dynamics/" class="md-nav__link">
        Multiscale sediment dynamics
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../notebooks/Space%20analysis%20-%20teaser/" class="md-nav__link">
        Space analysis   teaser
      </a>
    </li>
  

          
        </ul>
      </nav>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common" class="md-nav__link">
    sandpyper.common
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.add_grid_loc_coords" class="md-nav__link">
    add_grid_loc_coords()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.arr2geotiff" class="md-nav__link">
    arr2geotiff()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.check_overlaps_poly_label" class="md-nav__link">
    check_overlaps_poly_label()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.check_overlay" class="md-nav__link">
    check_overlay()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.compute_multitemporal" class="md-nav__link">
    compute_multitemporal()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.consecutive_ids" class="md-nav__link">
    consecutive_ids()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.coords_to_points" class="md-nav__link">
    coords_to_points()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.corr_baseline_distance" class="md-nav__link">
    corr_baseline_distance()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.correct_multi_detections" class="md-nav__link">
    correct_multi_detections()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.create_id" class="md-nav__link">
    create_id()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.create_spatial_id" class="md-nav__link">
    create_spatial_id()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.create_transects" class="md-nav__link">
    create_transects()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.cross_ref" class="md-nav__link">
    cross_ref()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.dissolve_shores" class="md-nav__link">
    dissolve_shores()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.error_from_gt" class="md-nav__link">
    error_from_gt()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.extract_from_folder" class="md-nav__link">
    extract_from_folder()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.extract_loc_date" class="md-nav__link">
    extract_loc_date()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.filepath_raster_type" class="md-nav__link">
    filepath_raster_type()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.fill_gaps" class="md-nav__link">
    fill_gaps()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.filter_filename_list" class="md-nav__link">
    filter_filename_list()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.find_date_string" class="md-nav__link">
    find_date_string()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.get_beachface_length" class="md-nav__link">
    get_beachface_length()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.get_coastal_Markov" class="md-nav__link">
    get_coastal_Markov()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.get_dn" class="md-nav__link">
    get_dn()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.get_elevation" class="md-nav__link">
    get_elevation()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.get_m3_m_location" class="md-nav__link">
    get_m3_m_location()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.get_opt_k" class="md-nav__link">
    get_opt_k()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.get_profile_dn" class="md-nav__link">
    get_profile_dn()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.get_profiles" class="md-nav__link">
    get_profiles()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.get_rbcd_transect" class="md-nav__link">
    get_rbcd_transect()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.get_sil_location" class="md-nav__link">
    get_sil_location()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.get_state_vol_table" class="md-nav__link">
    get_state_vol_table()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.get_terrain_info" class="md-nav__link">
    get_terrain_info()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.get_transects_vol_table" class="md-nav__link">
    get_transects_vol_table()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.getAngle" class="md-nav__link">
    getAngle()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.getCrs_from_raster_path" class="md-nav__link">
    getCrs_from_raster_path()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.getCrs_from_transect" class="md-nav__link">
    getCrs_from_transect()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.getDate" class="md-nav__link">
    getDate()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.getListOfDate" class="md-nav__link">
    getListOfDate()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.getListOfFiles" class="md-nav__link">
    getListOfFiles()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.getLoc" class="md-nav__link">
    getLoc()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.getPoint1" class="md-nav__link">
    getPoint1()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.grid_from_pts" class="md-nav__link">
    grid_from_pts()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.grid_from_shore" class="md-nav__link">
    grid_from_shore()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.images_to_dirs" class="md-nav__link">
    images_to_dirs()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.interpol_integrate" class="md-nav__link">
    interpol_integrate()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.kmeans_sa" class="md-nav__link">
    kmeans_sa()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.LISA_site_level" class="md-nav__link">
    LISA_site_level()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.plot_alongshore_change" class="md-nav__link">
    plot_alongshore_change()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.plot_sensitivity_rbcds_transects" class="md-nav__link">
    plot_sensitivity_rbcds_transects()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.plot_single_loc" class="md-nav__link">
    plot_single_loc()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.prep_heatmap" class="md-nav__link">
    prep_heatmap()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.round_special" class="md-nav__link">
    round_special()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.s2_to_rgb" class="md-nav__link">
    s2_to_rgb()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.sensitivity_tr_rbcd" class="md-nav__link">
    sensitivity_tr_rbcd()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.shoreline_from_prediction" class="md-nav__link">
    shoreline_from_prediction()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.split_transects" class="md-nav__link">
    split_transects()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.test_format" class="md-nav__link">
    test_format()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.tidal_correction" class="md-nav__link">
    tidal_correction()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.tiles_from_grid" class="md-nav__link">
    tiles_from_grid()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.toes_candidates" class="md-nav__link">
    toes_candidates()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sandpyper.common.toes_from_slopes" class="md-nav__link">
    toes_from_slopes()
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content" data-md-component="content">
            <article class="md-content__inner md-typeset">
              



                
                  <a href="https://github.com/npucino/sandpyper/edit/master/docs/common.md" title="Edit this page" class="md-content__button md-icon">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20.71 7.04c.39-.39.39-1.04 0-1.41l-2.34-2.34c-.37-.39-1.02-.39-1.41 0l-1.84 1.83 3.75 3.75M3 17.25V21h3.75L17.81 9.93l-3.75-3.75L3 17.25z"/></svg>
                  </a>
                
                
                  <h1>common module</h1>
                
                <div class="doc doc-object doc-module">

<a id="sandpyper.common"></a>
    <div class="doc doc-contents first">

      <p>This module contains some common functions for both ProfileSet and ProfileDynamics classes and the upcoming Space module.</p>



  <div class="doc doc-children">








  <div class="doc doc-object doc-function">



<h2 class="doc doc-heading" id="sandpyper.common.add_grid_loc_coords">
<code class="highlight language-python"><span class="n">add_grid_loc_coords</span><span class="p">(</span><span class="n">grid_gdf</span><span class="p">,</span> <span class="n">location</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>


<a class="headerlink" href="#sandpyper.common.add_grid_loc_coords" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Add coordinate fields of the corners of each grid tiles.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>grid_gdf</code></td>
        <td><code>gpd.GeoDataFrame</code></td>
        <td><p>The geodataframe storing the grid, returned by the grid_from_pts function.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>location</code></td>
        <td><code>str</code></td>
        <td><p>The location code associated with the grid. Defaults to None.</p></td>
        <td><code>None</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>grid_gdf (gpd.GeoDataFrame)</code></td>
      <td><p>The original grid, with UpperLeft X and Y (ulx,uly), UpperRight X and Y (urx,ury), LowerLeft X and Y (llx,llr) and LowerRigth X and Y (lrx,lry) coordinates fields added.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>sandpyper\common.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">add_grid_loc_coords</span><span class="p">(</span><span class="n">grid_gdf</span><span class="p">,</span> <span class="n">location</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Add coordinate fields of the corners of each grid tiles.</span>

<span class="sd">    Args:</span>
<span class="sd">        grid_gdf (gpd.GeoDataFrame): The geodataframe storing the grid, returned by the grid_from_pts function.</span>
<span class="sd">        location (str): The location code associated with the grid. Defaults to None.</span>

<span class="sd">    Returns:</span>
<span class="sd">        grid_gdf (gpd.GeoDataFrame): The original grid, with UpperLeft X and Y (ulx,uly), UpperRight X and Y (urx,ury), LowerLeft X and Y (llx,llr) and LowerRigth X and Y (lrx,lry) coordinates fields added.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">location</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">location</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="n">ulxs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">urxs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">lrxs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">llxs</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">ulys</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">urys</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">lrys</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">llys</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">grid</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">grid_gdf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>

        <span class="n">coords</span> <span class="o">=</span> <span class="n">grid_gdf</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">grid</span><span class="p">]</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">exterior</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">xy</span>

        <span class="c1"># get upper-left, upper-right, lower-right and lower-left X coordinates.</span>
        <span class="n">ulx</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">urx</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">lrx</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">llx</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span>

        <span class="c1"># get upper-left, upper-right, lower-right and lower-left Y coordinates.</span>
        <span class="n">uly</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">ury</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">lry</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">lly</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span>

        <span class="n">ulxs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ulx</span><span class="p">)</span>
        <span class="n">urxs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">urx</span><span class="p">)</span>
        <span class="n">lrxs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lrx</span><span class="p">)</span>
        <span class="n">llxs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">llx</span><span class="p">)</span>

        <span class="n">ulys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">uly</span><span class="p">)</span>
        <span class="n">urys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ury</span><span class="p">)</span>
        <span class="n">lrys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lry</span><span class="p">)</span>
        <span class="n">llys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lly</span><span class="p">)</span>

    <span class="n">grid_gdf</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="s2">&quot;ulx&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ulxs</span>
    <span class="n">grid_gdf</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="s2">&quot;urx&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">urxs</span>
    <span class="n">grid_gdf</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="s2">&quot;lrx&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">lrxs</span>
    <span class="n">grid_gdf</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="s2">&quot;llx&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">llxs</span>

    <span class="n">grid_gdf</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="s2">&quot;uly&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ulys</span>
    <span class="n">grid_gdf</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="s2">&quot;ury&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">urys</span>
    <span class="n">grid_gdf</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="s2">&quot;lry&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">lrys</span>
    <span class="n">grid_gdf</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="s2">&quot;lly&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">llys</span>

    <span class="n">grid_gdf</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="s2">&quot;location&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">location</span>

    <span class="k">return</span> <span class="n">grid_gdf</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 class="doc doc-heading" id="sandpyper.common.arr2geotiff">
<code class="highlight language-python"><span class="n">arr2geotiff</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">transform</span><span class="p">,</span> <span class="n">location</span><span class="p">,</span> <span class="n">crs_dict_string</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">driver</span><span class="o">=</span><span class="s1">&#39;GTiff&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=&lt;</span><span class="k">class</span> <span class="err">&#39;</span><span class="nc">numpy</span><span class="o">.</span><span class="n">float32</span><span class="s1">&#39;&gt;, save=None)</span></code>


<a class="headerlink" href="#sandpyper.common.arr2geotiff" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Transform an array into a Geotiff given its Shapely transform and location code.</p>
<div class="codehilite"><pre><span></span><code><span class="o">!!!</span> <span class="nv">args</span>
    <span class="nv">array</span> <span class="ss">(</span><span class="nv">array</span><span class="ss">)</span>: <span class="nv">array</span> <span class="nv">to</span> <span class="nv">be</span> <span class="nv">transformed</span>.
    <span class="nv">transform</span> <span class="ss">(</span><span class="nv">tuple</span><span class="ss">)</span>: <span class="nv">tuple</span> <span class="nv">with</span> <span class="nv">Shapely</span> <span class="nv">transform</span> <span class="nv">parameters</span>.
    <span class="nv">location</span> <span class="ss">(</span><span class="nv">str</span><span class="ss">)</span>: <span class="nv">Location</span> <span class="nv">code</span> <span class="nv">of</span> <span class="nv">the</span> <span class="nv">shoreline</span> <span class="nv">to</span> <span class="nv">convert</span>.
    <span class="nv">crs_dict_string</span> <span class="ss">(</span><span class="nv">dict</span><span class="ss">)</span>:  <span class="nv">Dictionary</span> <span class="nv">storing</span> <span class="nv">location</span> <span class="nv">codes</span> <span class="nv">as</span> <span class="nv">key</span> <span class="nv">and</span> <span class="nv">crs</span> <span class="nv">information</span> <span class="nv">as</span> <span class="nv">EPSG</span> <span class="nv">code</span> <span class="ss">(</span><span class="nv">int</span><span class="ss">)</span>.
    <span class="nv">shape</span> <span class="ss">(</span><span class="nv">tuple</span><span class="ss">)</span>: <span class="nv">Tuple</span> <span class="nv">of</span> <span class="nv">size</span> <span class="mi">3</span> <span class="nv">of</span> <span class="nv">the</span> <span class="nv">shape</span> <span class="nv">of</span> <span class="nv">the</span> <span class="nv">array</span>. <span class="nv">Default</span> <span class="nv">to</span> <span class="ss">(</span><span class="mi">64</span>,<span class="mi">64</span>,<span class="mi">1</span><span class="ss">)</span>
    <span class="nv">driver</span> <span class="ss">(</span><span class="s2">&quot;</span><span class="s">GTiff</span><span class="s2">&quot;</span><span class="ss">)</span>: <span class="nv">Driver</span> <span class="nv">used</span> <span class="nv">by</span> <span class="nv">Fiona</span> <span class="nv">to</span> <span class="nv">save</span> <span class="nv">file</span>.
    <span class="nv">dtype</span> <span class="ss">(</span><span class="nv">data</span> <span class="nv">type</span> <span class="nv">object</span><span class="ss">)</span>: <span class="nv">Default</span> <span class="nv">to</span> <span class="nv">numpy</span>.<span class="nv">float32</span>.
    <span class="nv">save</span> <span class="ss">(</span><span class="nv">None</span>,<span class="nv">path</span><span class="ss">)</span>. <span class="k">If</span> <span class="nv">a</span> <span class="nv">full</span> <span class="nv">path</span> <span class="nv">is</span> <span class="nv">provided</span>, <span class="nv">save</span> <span class="nv">the</span> <span class="nv">file</span> <span class="nv">to</span> <span class="nv">a</span> <span class="nv">geotiff</span> <span class="nv">image</span> <span class="ss">(</span><span class="nv">C</span>:\<span class="nv">my</span>
</code></pre></div>

<p>ew\image.tif). If None (default), the geotiff is saved in the memory but not to the disk.</p>
<div class="codehilite"><pre><span></span><code>!!! returns
    mem_dataset (rasterio.io.MemoryFile): Geotiff image saved into memory or optionally saved to a new raster.
</code></pre></div>

        <details class="quote">
          <summary>Source code in <code>sandpyper\common.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">arr2geotiff</span><span class="p">(</span>
    <span class="n">array</span><span class="p">,</span>
    <span class="n">transform</span><span class="p">,</span>
    <span class="n">location</span><span class="p">,</span>
    <span class="n">crs_dict_string</span><span class="p">,</span>
    <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
    <span class="n">driver</span><span class="o">=</span><span class="s2">&quot;GTiff&quot;</span><span class="p">,</span>
    <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span>
    <span class="n">save</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Transform an array into a Geotiff given its Shapely transform and location code.</span>

<span class="sd">    Args:</span>
<span class="sd">        array (array): array to be transformed.</span>
<span class="sd">        transform (tuple): tuple with Shapely transform parameters.</span>
<span class="sd">        location (str): Location code of the shoreline to convert.</span>
<span class="sd">        crs_dict_string (dict):  Dictionary storing location codes as key and crs information as EPSG code (int).</span>
<span class="sd">        shape (tuple): Tuple of size 3 of the shape of the array. Default to (64,64,1)</span>
<span class="sd">        driver (&quot;GTiff&quot;): Driver used by Fiona to save file.</span>
<span class="sd">        dtype (data type object): Default to numpy.float32.</span>
<span class="sd">        save (None,path). If a full path is provided, save the file to a geotiff image (C:\my\new\image.tif). If None (default), the geotiff is saved in the memory but not to the disk.</span>

<span class="sd">    Returns:</span>
<span class="sd">        mem_dataset (rasterio.io.MemoryFile): Geotiff image saved into memory or optionally saved to a new raster.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">with</span> <span class="n">MemoryFile</span><span class="p">()</span> <span class="k">as</span> <span class="n">memfile</span><span class="p">:</span>
        <span class="n">mem_dataset</span> <span class="o">=</span> <span class="n">memfile</span><span class="o">.</span><span class="n">open</span><span class="p">(</span>
            <span class="n">driver</span><span class="o">=</span><span class="s2">&quot;GTiff&quot;</span><span class="p">,</span>
            <span class="n">height</span><span class="o">=</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">width</span><span class="o">=</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="n">count</span><span class="o">=</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
            <span class="n">transform</span><span class="o">=</span><span class="n">transform</span><span class="p">,</span>
            <span class="n">crs</span><span class="o">=</span><span class="n">crs_dict_string</span><span class="p">[</span><span class="n">loc</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="n">mem_dataset</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span> <span class="n">indexes</span><span class="o">=</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">save</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">ras</span><span class="o">.</span><span class="n">open</span><span class="p">(</span>
                <span class="n">save</span><span class="p">,</span>
                <span class="s2">&quot;w&quot;</span><span class="p">,</span>
                <span class="n">driver</span><span class="o">=</span><span class="n">driver</span><span class="p">,</span>
                <span class="n">height</span><span class="o">=</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                <span class="n">width</span><span class="o">=</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                <span class="n">count</span><span class="o">=</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
                <span class="n">transform</span><span class="o">=</span><span class="n">transform</span><span class="p">,</span>
                <span class="n">crs</span><span class="o">=</span><span class="n">crs_dict_string</span><span class="p">[</span><span class="n">loc</span><span class="p">]</span>
            <span class="p">)</span> <span class="k">as</span> <span class="n">dest</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">driver</span> <span class="o">==</span> <span class="s2">&quot;PNG&quot;</span><span class="p">:</span>
                    <span class="n">dest</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">mem_dataset</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">ras</span><span class="o">.</span><span class="n">uint16</span><span class="p">),</span> <span class="n">indexes</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">dest</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span> <span class="n">indexes</span><span class="o">=</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">mem_dataset</span>
</code></pre></div>
        </details>
    </div>

  </div>




  <div class="doc doc-object doc-function">



<h2 class="doc doc-heading" id="sandpyper.common.check_overlaps_poly_label">
<code class="highlight language-python"><span class="n">check_overlaps_poly_label</span><span class="p">(</span><span class="n">label_corrections</span><span class="p">,</span> <span class="n">profiles</span><span class="p">,</span> <span class="n">crs</span><span class="p">)</span></code>


<a class="headerlink" href="#sandpyper.common.check_overlaps_poly_label" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Function to check whether overlapping areas of label correction polygons targeting the same label_k in the same surveys but assigning different new classes do not contain points that would be affected by those polygons.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>label_corrections</code></td>
        <td><code>gpd.GeoDataFrame</code></td>
        <td><p>GeodataFrame of the label correction polygons.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>profiles</code></td>
        <td><code>gpd.GeoDataFrame</code></td>
        <td><p>Geodataframe of the extracted elevation profiles.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>crs</code></td>
        <td><code>dict, int</code></td>
        <td><p>Either an EPSG code (int) or a dictionary. If dictionary, it must store location codes as keys and crs information as values, in dictionary form (example: {'init' :'epsg:4326'}).</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>sandpyper\common.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">check_overlaps_poly_label</span><span class="p">(</span><span class="n">label_corrections</span><span class="p">,</span> <span class="n">profiles</span><span class="p">,</span><span class="n">crs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function to check whether overlapping areas of label correction polygons targeting the same label_k in the same surveys but assigning different new classes do not contain points that would be affected by those polygons.</span>
<span class="sd">    Args:</span>
<span class="sd">        label_corrections (gpd.GeoDataFrame): GeodataFrame of the label correction polygons.</span>
<span class="sd">        profiles (gpd.GeoDataFrame): Geodataframe of the extracted elevation profiles.</span>
<span class="sd">        crs (dict, int): Either an EPSG code (int) or a dictionary. If dictionary, it must store location codes as keys and crs information as values, in dictionary form (example: {&#39;init&#39; :&#39;epsg:4326&#39;}).</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">loc</span> <span class="ow">in</span> <span class="n">label_corrections</span><span class="o">.</span><span class="n">location</span><span class="o">.</span><span class="n">unique</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">raw_date</span> <span class="ow">in</span> <span class="n">label_corrections</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;location==&#39;</span><span class="si">{</span><span class="n">loc</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">raw_date</span><span class="o">.</span><span class="n">unique</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">target_label_k</span> <span class="ow">in</span> <span class="n">label_corrections</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;location==&#39;</span><span class="si">{</span><span class="n">loc</span><span class="si">}</span><span class="s2">&#39; and raw_date==</span><span class="si">{</span><span class="n">raw_date</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">target_label_k</span><span class="o">.</span><span class="n">unique</span><span class="p">():</span>

                <span class="n">date_labelk_subset</span><span class="o">=</span><span class="n">label_corrections</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;location==&#39;</span><span class="si">{</span><span class="n">loc</span><span class="si">}</span><span class="s2">&#39; and raw_date==</span><span class="si">{</span><span class="n">raw_date</span><span class="si">}</span><span class="s2"> and target_label_k==</span><span class="si">{</span><span class="nb">int</span><span class="p">(</span><span class="n">target_label_k</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                <span class="c1"># if more than one polygons target the same label k, check if they overlap</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">date_labelk_subset</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>

                    <span class="c1"># check if there are any one of them that overlaps</span>
                    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">z</span> <span class="ow">in</span> <span class="n">comb</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">date_labelk_subset</span><span class="p">)),</span><span class="mi">2</span><span class="p">):</span>
                        <span class="n">intersection_gdf</span> <span class="o">=</span> <span class="n">overlay</span><span class="p">(</span><span class="n">date_labelk_subset</span><span class="o">.</span><span class="n">iloc</span><span class="p">[[</span><span class="n">i</span><span class="p">]],</span> <span class="n">date_labelk_subset</span><span class="o">.</span><span class="n">iloc</span><span class="p">[[</span><span class="n">z</span><span class="p">]],</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;intersection&#39;</span><span class="p">)</span>

                        <span class="k">if</span> <span class="ow">not</span> <span class="n">intersection_gdf</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>

                           <span class="c1"># check if the overlapping polygons have assigns different new_classes</span>
                            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">intersection_gdf</span><span class="o">.</span><span class="n">new_class_1</span> <span class="o">!=</span> <span class="n">intersection_gdf</span><span class="o">.</span><span class="n">new_class_2</span><span class="p">):</span>

                                <span class="c1"># if overlap areas assign different classes, check if this area contains points with label_k equal to both polygons target_label_k..</span>
                                <span class="c1"># if contains points, raise an error as it does not make sense and the polygons must be corrected</span>
                                <span class="c1"># by the user</span>

                                <span class="n">pts</span><span class="o">=</span><span class="n">profiles</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;location==&#39;</span><span class="si">{</span><span class="n">loc</span><span class="si">}</span><span class="s2">&#39; and raw_date==</span><span class="si">{</span><span class="n">raw_date</span><span class="si">}</span><span class="s2"> and label_k==</span><span class="si">{</span><span class="nb">int</span><span class="p">(</span><span class="n">target_label_k</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pts</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;coordinates&#39;</span><span class="p">],</span><span class="n">Point</span><span class="p">):</span>
                                    <span class="n">pts_gdf</span><span class="o">=</span><span class="n">pts</span>
                                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pts</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;coordinates&#39;</span><span class="p">],</span><span class="nb">str</span><span class="p">):</span>
                                    <span class="n">pts</span><span class="p">[</span><span class="s1">&#39;coordinates&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">pts</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">coords_to_points</span><span class="p">)</span>
                                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">crs</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                                        <span class="n">pts_gdf</span><span class="o">=</span><span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span><span class="n">pts</span><span class="p">,</span> <span class="n">geometry</span><span class="o">=</span><span class="s1">&#39;coordinates&#39;</span><span class="p">,</span> <span class="n">crs</span><span class="o">=</span><span class="n">crs</span><span class="p">[</span><span class="n">loc</span><span class="p">])</span>
                                    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">crs</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                                        <span class="n">crs_adhoc</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;init&#39;</span><span class="p">:</span> <span class="sa">f</span><span class="s1">&#39;epsg:</span><span class="si">{</span><span class="n">crs</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">}</span>
                                        <span class="n">pts_gdf</span><span class="o">=</span><span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span><span class="n">pts</span><span class="p">,</span> <span class="n">geometry</span><span class="o">=</span><span class="s1">&#39;coordinates&#39;</span><span class="p">,</span> <span class="n">crs</span><span class="o">=</span><span class="n">crs_adhoc</span><span class="p">)</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;profiles coordinates field must contain points coordinates either as Shapely Point geometry objects or as a string representing a Shapely Point geometry in well known text. Found </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">pts</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;coordinates&#39;</span><span class="p">])</span><span class="si">}</span><span class="s2"> type instead.&quot;</span><span class="p">)</span>

                                <span class="n">fully_contains</span> <span class="o">=</span> <span class="p">[</span><span class="n">intersection_gdf</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">mask_geom</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">mask_geom</span> <span class="ow">in</span> <span class="n">pts_gdf</span><span class="o">.</span><span class="n">geometry</span><span class="p">]</span>

                                <span class="k">if</span> <span class="kc">True</span> <span class="ow">in</span> <span class="n">fully_contains</span><span class="p">:</span>
                                    <span class="n">idx_true</span><span class="o">=</span><span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">fully_contains</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span><span class="p">]</span>
                                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;There are </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">intersection_gdf</span><span class="p">)</span><span class="si">}</span><span class="s2"> points in the overlap area of two label correction polygons (location: </span><span class="si">{</span><span class="n">loc</span><span class="si">}</span><span class="s2">, raw_date: </span><span class="si">{</span><span class="n">raw_date</span><span class="si">}</span><span class="s2">, target_label_k = </span><span class="si">{</span><span class="n">target_label_k</span><span class="si">}</span><span class="s2">) which assign two different classes: </span><span class="si">{</span><span class="n">intersection_gdf</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span><span class="s1">&#39;new_class_1&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">intersection_gdf</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span><span class="s1">&#39;new_class_2&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">. This doesn&#39;t make sense, please correct your label correction polygons. You can have overlapping polygons which act on the same target label k, but if they overlap points with such target_label_k, then they MUST assign the same new class.&quot;</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Check label correction polygons overlap inconsistencies terminated successfully&quot;</span><span class="p">)</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 class="doc doc-heading" id="sandpyper.common.check_overlay">
<code class="highlight language-python"><span class="n">check_overlay</span><span class="p">(</span><span class="n">line_geometry</span><span class="p">,</span> <span class="n">img_path</span><span class="p">)</span></code>


<a class="headerlink" href="#sandpyper.common.check_overlay" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Evaluates whether a line intesects the extent of a raster.
    Returns True if a valid intersection is found or False if not. In case of MultiLine features,
    evaluate if any of the lines intersects with the raster extent,
    which confirms that the CRS of both shapes geometries are correctly matched.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>line_geometry</code></td>
        <td><code>Shapely Line or MultiLinestring objects</code></td>
        <td><p>geometry of line to evaluate its overlay on raster.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>img_path</code></td>
        <td><code>str</code></td>
        <td><p>Path to the geotiff to evaluate line overlay with.</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>bool (bool)</code></td>
      <td><p>True, if a valid match is found. False, if the line do not intersect the raster.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>sandpyper\common.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">check_overlay</span><span class="p">(</span><span class="n">line_geometry</span><span class="p">,</span> <span class="n">img_path</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Evaluates whether a line intesects the extent of a raster.</span>
<span class="sd">        Returns True if a valid intersection is found or False if not. In case of MultiLine features,</span>
<span class="sd">        evaluate if any of the lines intersects with the raster extent,</span>
<span class="sd">        which confirms that the CRS of both shapes geometries are correctly matched.</span>

<span class="sd">    Args:</span>
<span class="sd">        line_geometry (Shapely Line or MultiLinestring objects): geometry of line to evaluate its overlay on raster.</span>
<span class="sd">        img_path (str): Path to the geotiff to evaluate line overlay with.</span>

<span class="sd">    Returns:</span>
<span class="sd">        bool (bool): True, if a valid match is found. False, if the line do not intersect the raster.&quot;&quot;&quot;</span>

    <span class="c1"># create a polygon with raster bounds</span>
    <span class="k">with</span> <span class="n">ras</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">img_path</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">dataset</span><span class="p">:</span>

        <span class="n">ul</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">xy</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">ur</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">xy</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dataset</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">lr</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">xy</span><span class="p">(</span><span class="n">dataset</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dataset</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">ll</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">xy</span><span class="p">(</span><span class="n">dataset</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>

        <span class="n">ext_poly</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoSeries</span><span class="p">(</span><span class="n">Polygon</span><span class="p">([</span><span class="n">ul</span><span class="p">,</span> <span class="n">ur</span><span class="p">,</span> <span class="n">lr</span><span class="p">,</span> <span class="n">ll</span><span class="p">,</span> <span class="n">ul</span><span class="p">]),</span> <span class="n">crs</span><span class="o">=</span><span class="n">dataset</span><span class="o">.</span><span class="n">crs</span><span class="p">)</span>

    <span class="c1"># get geom_type</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">line_geometry</span><span class="o">.</span><span class="n">geom_type</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">geom_type</span> <span class="o">=</span> <span class="n">line_geometry</span><span class="o">.</span><span class="n">geom_type</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">line_geometry</span><span class="o">.</span><span class="n">geom_type</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">):</span>
        <span class="n">geom_type</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">geom_type</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">geom_type</span> <span class="o">==</span> <span class="s2">&quot;MultiLineString&quot;</span><span class="p">:</span>

        <span class="n">geom_in</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">line_geometry</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">ext_poly</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">intersects</span><span class="p">(</span><span class="n">geom_in</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="k">elif</span> <span class="n">geom_type</span> <span class="o">==</span> <span class="s2">&quot;LineString&quot;</span><span class="p">:</span>

        <span class="n">geom_in</span> <span class="o">=</span> <span class="n">line_geometry</span>

        <span class="k">if</span> <span class="n">ext_poly</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">intersects</span><span class="p">(</span><span class="n">geom_in</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s2">&quot;Shape is not a line.&quot;</span><span class="p">)</span>
</code></pre></div>
        </details>
    </div>

  </div>





  <div class="doc doc-object doc-function">



<h2 class="doc doc-heading" id="sandpyper.common.compute_multitemporal">
<code class="highlight language-python"><span class="n">compute_multitemporal</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">geometry_column</span><span class="o">=</span><span class="s1">&#39;coordinates&#39;</span><span class="p">,</span> <span class="n">date_field</span><span class="o">=</span><span class="s1">&#39;survey_date&#39;</span><span class="p">,</span> <span class="n">filter_class</span><span class="o">=</span><span class="s1">&#39;sand&#39;</span><span class="p">)</span></code>


<a class="headerlink" href="#sandpyper.common.compute_multitemporal" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>From a dataframe containing the extracted points and a column specifying whether they are sand or non-sand, returns a multitemporal dataframe
with time-periods sand-specific elevation changes.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>date_field</code></td>
        <td><code>str</code></td>
        <td><p>The name of the column storing the survey date.</p></td>
        <td><code>&#39;survey_date&#39;</code></td>
      </tr>
      <tr>
        <td><code>geometry_column</code></td>
        <td><code>str</code></td>
        <td><p>Name of the column containing the geometry.</p></td>
        <td><code>&#39;coordinates&#39;</code></td>
      </tr>
      <tr>
        <td><code>filter_classes</code></td>
        <td><code>str,list</code></td>
        <td><p>Name of the class of list of classes to be retained in the multitemporal computation.</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>multiteporal_df (pd.DataFrame)</code></td>
      <td><p>A multitemporal dataframe of sand-specific elevation changes.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>sandpyper\common.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">compute_multitemporal</span> <span class="p">(</span><span class="n">df</span><span class="p">,</span>
                            <span class="n">geometry_column</span><span class="o">=</span><span class="s2">&quot;coordinates&quot;</span><span class="p">,</span>
                           <span class="n">date_field</span><span class="o">=</span><span class="s1">&#39;survey_date&#39;</span><span class="p">,</span>
                           <span class="n">filter_class</span><span class="o">=</span><span class="s1">&#39;sand&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    From a dataframe containing the extracted points and a column specifying whether they are sand or non-sand, returns a multitemporal dataframe</span>
<span class="sd">    with time-periods sand-specific elevation changes.</span>

<span class="sd">    Args:</span>
<span class="sd">        date_field (str): The name of the column storing the survey date.</span>
<span class="sd">        geometry_column (str): Name of the column containing the geometry.</span>
<span class="sd">        filter_classes (str,list): Name of the class of list of classes to be retained in the multitemporal computation.</span>

<span class="sd">    Returns:</span>
<span class="sd">        multiteporal_df (pd.DataFrame): A multitemporal dataframe of sand-specific elevation changes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">filter_class</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># check if pt_class in columns</span>
        <span class="k">if</span> <span class="s2">&quot;pt_class&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The data is not classified as no &#39;pt_class&#39; column is present. Please run the method cleanit on the ProfileDynamics object first.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">filter_class</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">filter_classes_in</span><span class="o">=</span><span class="p">[</span><span class="n">filter_class</span><span class="p">]</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">filter_class</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">filter_classes_in</span><span class="o">=</span><span class="n">filter_class</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot; If provided, class_filter must be either a string or a list of strings containing the classes to retain.&quot;</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Filter activated: only </span><span class="si">{</span><span class="n">filter_classes_in</span><span class="si">}</span><span class="s2"> points will be retained.&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">filter_classes_in</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;no_filters_applied&quot;</span><span class="p">]</span>
        <span class="k">pass</span>

    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;spatial_id&quot;</span><span class="p">]</span><span class="o">=</span><span class="p">[</span><span class="n">create_spatial_id</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>
    <span class="n">fusion_long</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>


    <span class="k">for</span> <span class="n">location</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">location</span><span class="o">.</span><span class="n">unique</span><span class="p">():</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;working on </span><span class="si">{</span><span class="n">location</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">loc_data</span><span class="o">=</span><span class="n">df</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;location==&#39;</span><span class="si">{</span><span class="n">location</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>
        <span class="n">list_dates</span><span class="o">=</span><span class="n">loc_data</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span><span class="n">date_field</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
        <span class="n">list_dates</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>


        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">list_dates</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>

            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">list_dates</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">date_pre</span><span class="o">=</span><span class="n">list_dates</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">date_post</span><span class="o">=</span><span class="n">list_dates</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Calculating dt</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">, from </span><span class="si">{</span><span class="n">date_pre</span><span class="si">}</span><span class="s2"> to </span><span class="si">{</span><span class="n">date_post</span><span class="si">}</span><span class="s2"> in </span><span class="si">{</span><span class="n">location</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">filter_class</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">df_pre</span><span class="o">=</span><span class="n">loc_data</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">date_field</span><span class="si">}</span><span class="s2"> ==</span><span class="si">{</span><span class="n">date_pre</span><span class="si">}</span><span class="s2"> &amp; pt_class in </span><span class="si">{</span><span class="n">filter_classes_in</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;z&#39;</span><span class="p">])</span>
                    <span class="n">df_post</span><span class="o">=</span><span class="n">loc_data</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">date_field</span><span class="si">}</span><span class="s2"> ==</span><span class="si">{</span><span class="n">date_post</span><span class="si">}</span><span class="s2"> &amp; pt_class in </span><span class="si">{</span><span class="n">filter_classes_in</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;z&#39;</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">df_pre</span><span class="o">=</span><span class="n">loc_data</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">date_field</span><span class="si">}</span><span class="s2"> ==</span><span class="si">{</span><span class="n">date_pre</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;z&#39;</span><span class="p">])</span>
                    <span class="n">df_post</span><span class="o">=</span><span class="n">loc_data</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">date_field</span><span class="si">}</span><span class="s2"> ==</span><span class="si">{</span><span class="n">date_post</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;z&#39;</span><span class="p">])</span>

                <span class="n">merged</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">df_pre</span><span class="p">,</span><span class="n">df_post</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;inner&#39;</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="s1">&#39;spatial_id&#39;</span><span class="p">,</span> <span class="n">validate</span><span class="o">=</span><span class="s2">&quot;one_to_one&quot;</span><span class="p">,</span><span class="n">suffixes</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;_pre&#39;</span><span class="p">,</span><span class="s1">&#39;_post&#39;</span><span class="p">))</span>
                <span class="n">merged</span><span class="p">[</span><span class="s2">&quot;dh&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">merged</span><span class="o">.</span><span class="n">z_post</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span> <span class="o">-</span> <span class="n">merged</span><span class="o">.</span><span class="n">z_pre</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>

                <span class="n">dict_short</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;geometry&quot;</span><span class="p">:</span><span class="n">merged</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">like</span><span class="o">=</span><span class="n">geometry_column</span><span class="p">)</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span>
                            <span class="s2">&quot;location&quot;</span><span class="p">:</span><span class="n">location</span><span class="p">,</span>
                            <span class="s2">&quot;tr_id&quot;</span><span class="p">:</span><span class="n">merged</span><span class="o">.</span><span class="n">tr_id_pre</span><span class="p">,</span>
                            <span class="s2">&quot;distance&quot;</span><span class="p">:</span><span class="n">merged</span><span class="o">.</span><span class="n">distance_pre</span><span class="p">,</span>
                            <span class="s2">&quot;class_filter&quot;</span><span class="p">:</span><span class="s1">&#39;_&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">filter_classes_in</span><span class="p">),</span>
                            <span class="s2">&quot;dt&quot;</span><span class="p">:</span>  <span class="sa">f</span><span class="s2">&quot;dt_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                            <span class="s2">&quot;date_pre&quot;</span><span class="p">:</span><span class="n">date_pre</span><span class="p">,</span>
                            <span class="s2">&quot;date_post&quot;</span><span class="p">:</span><span class="n">date_post</span><span class="p">,</span>
                            <span class="s2">&quot;z_pre&quot;</span><span class="p">:</span><span class="n">merged</span><span class="o">.</span><span class="n">z_pre</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">),</span>
                            <span class="s2">&quot;z_post&quot;</span><span class="p">:</span><span class="n">merged</span><span class="o">.</span><span class="n">z_post</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">),</span>
                            <span class="s2">&quot;dh&quot;</span><span class="p">:</span><span class="n">merged</span><span class="o">.</span><span class="n">dh</span><span class="p">}</span>

                <span class="n">short_df</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">dict_short</span><span class="p">)</span>
                <span class="n">fusion_long</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">short_df</span><span class="p">,</span><span class="n">fusion_long</span><span class="p">],</span><span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;done&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">fusion_long</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 class="doc doc-heading" id="sandpyper.common.consecutive_ids">
<code class="highlight language-python"><span class="n">consecutive_ids</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></code>


<a class="headerlink" href="#sandpyper.common.consecutive_ids" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Returns indices of consecutive tr_ids in groups. Covenient to create multi-line geometries in case of disconnected shorelines.</p>

        <details class="quote">
          <summary>Source code in <code>sandpyper\common.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">consecutive_ids</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns indices of consecutive tr_ids in groups. Covenient to create multi-line geometries in case of disconnected shorelines.&quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">bool</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
        <span class="n">return_i</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># return data values</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">return_i</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">groups</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">groupby</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">ix</span><span class="p">:</span> <span class="n">ix</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">ix</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
        <span class="n">groups</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">itemgetter</span><span class="p">(</span><span class="n">return_i</span><span class="p">),</span> <span class="n">g</span><span class="p">)))</span>

    <span class="n">groups</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">groups</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">limit</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">groups</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 class="doc doc-heading" id="sandpyper.common.coords_to_points">
<code class="highlight language-python"><span class="n">coords_to_points</span><span class="p">(</span><span class="n">string_of_coords</span><span class="p">)</span></code>


<a class="headerlink" href="#sandpyper.common.coords_to_points" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Function to create Shapely Point geometries from strings representing Shapely Point geometries.
Used when loading CSV with point geometries in string type.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>string_of_coords</code></td>
        <td><code>str</code></td>
        <td><p>the string version of Shapely Point geometry</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>pt_geom </code></td>
      <td><p>Shapely Point geometry</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>sandpyper\common.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">coords_to_points</span><span class="p">(</span><span class="n">string_of_coords</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function to create Shapely Point geometries from strings representing Shapely Point geometries.</span>
<span class="sd">    Used when loading CSV with point geometries in string type.</span>

<span class="sd">    args:</span>
<span class="sd">        string_of_coords (str): the string version of Shapely Point geometry</span>

<span class="sd">    returns:</span>
<span class="sd">        pt_geom : Shapely Point geometry</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">num_ditis</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\\</span><span class="s2">d+&quot;</span><span class="p">,</span> <span class="n">string_of_coords</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">coord_x</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">num_ditis</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;.&quot;</span> <span class="o">+</span> <span class="n">num_ditis</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">coord_y</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">num_ditis</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;.&quot;</span> <span class="o">+</span> <span class="n">num_ditis</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
        <span class="n">pt_geom</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="n">coord_x</span><span class="p">,</span> <span class="n">coord_y</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">BaseException</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;point creation failed! Assigning NaN. Check the format of the input string.&quot;</span>
        <span class="p">)</span>
        <span class="n">pt_geom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="k">return</span> <span class="n">pt_geom</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 class="doc doc-heading" id="sandpyper.common.corr_baseline_distance">
<code class="highlight language-python"><span class="n">corr_baseline_distance</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="n">slope</span><span class="p">,</span> <span class="n">z_tide</span><span class="p">)</span></code>


<a class="headerlink" href="#sandpyper.common.corr_baseline_distance" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Applies a simple geometric tidal correction of the points along a shoreline</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>dist</code></td>
        <td><code>float, pd.Series</code></td>
        <td><p>Uncorrected distance or pd.Series of distances from the baseline.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>slope</code></td>
        <td><code>float</code></td>
        <td><p>Subaerial beach profile slope in percentage.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>z_tide</code></td>
        <td><code>float</code></td>
        <td><p>Water level or tidal height.</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>float, list</code></td>
      <td><p>The corrected value or list of corrected values.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>sandpyper\common.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">corr_baseline_distance</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="n">slope</span><span class="p">,</span> <span class="n">z_tide</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Applies a simple geometric tidal correction of the points along a shoreline</span>

<span class="sd">    Args:</span>
<span class="sd">        dist (float, pd.Series): Uncorrected distance or pd.Series of distances from the baseline.</span>
<span class="sd">        slope (float): Subaerial beach profile slope in percentage.</span>
<span class="sd">        z_tide (float): Water level or tidal height.</span>

<span class="sd">    Returns:</span>
<span class="sd">        float, list: The corrected value or list of corrected values.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">complex</span><span class="p">)):</span>

        <span class="n">tan_b</span> <span class="o">=</span> <span class="n">tan</span><span class="p">(</span><span class="n">radians</span><span class="p">(</span><span class="n">slope</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">dist</span> <span class="o">+</span> <span class="p">(</span><span class="n">z_tide</span> <span class="o">/</span> <span class="n">tan_b</span><span class="p">)</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">)):</span>

        <span class="n">tans_b</span> <span class="o">=</span> <span class="p">[</span><span class="n">tan</span><span class="p">(</span><span class="n">radians</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">slope</span><span class="p">]</span>
        <span class="n">corrs</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span> <span class="o">+</span> <span class="p">(</span><span class="n">z</span> <span class="o">/</span> <span class="n">sl</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span><span class="p">,</span> <span class="n">sl</span><span class="p">,</span> <span class="n">z</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="n">tans_b</span><span class="p">,</span> <span class="n">z_tide</span><span class="p">)]</span>

        <span class="k">return</span> <span class="n">corrs</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Input must be either Pandas.Series or numeric (int,float).&quot;</span><span class="p">)</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 class="doc doc-heading" id="sandpyper.common.correct_multi_detections">
<code class="highlight language-python"><span class="n">correct_multi_detections</span><span class="p">(</span><span class="n">shore_pts</span><span class="p">,</span> <span class="n">transects</span><span class="p">)</span></code>


<a class="headerlink" href="#sandpyper.common.correct_multi_detections" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Corrects for multiple points detections on shorelines transects. Multi detections occur when the shoreline bends considerably and the transects intersect it more than once.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>shore_pts</code></td>
        <td><code>np.array</code></td>
        <td><p>array to be transformed.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>transects</code></td>
        <td><code>pd.DataFRame</code></td>
        <td><p>transects to correct.</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>geometries (list)</code></td>
      <td><p>List of geometries of correct points.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>sandpyper\common.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">correct_multi_detections</span><span class="p">(</span><span class="n">shore_pts</span><span class="p">,</span> <span class="n">transects</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Corrects for multiple points detections on shorelines transects. Multi detections occur when the shoreline bends considerably and the transects intersect it more than once.</span>

<span class="sd">    Args:</span>
<span class="sd">        shore_pts (np.array): array to be transformed.</span>
<span class="sd">        transects (pd.DataFRame): transects to correct.</span>
<span class="sd">    Returns:</span>
<span class="sd">        geometries (list): List of geometries of correct points.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">geometries</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">shore_pts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">pt_i</span> <span class="o">=</span> <span class="n">shore_pts</span><span class="o">.</span><span class="n">iloc</span><span class="p">[[</span><span class="n">i</span><span class="p">]]</span>
        <span class="k">if</span> <span class="n">pt_i</span><span class="o">.</span><span class="n">qa</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">geometries</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">pt_i</span><span class="o">.</span><span class="n">qa</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>

                <span class="n">start_line</span> <span class="o">=</span> <span class="n">transects</span><span class="o">.</span><span class="n">query</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;tr_id==&#39;</span><span class="si">{</span><span class="n">pt_i</span><span class="o">.</span><span class="n">tr_id</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&#39;&quot;</span>
                <span class="p">)</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">boundary</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

                <span class="n">min_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">start_line</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span> <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">pt_i</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                <span class="p">)</span>
                <span class="n">geometries</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pt_i</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">min_idx</span><span class="p">])</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">geometries</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pt_i</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">geometries</span>
</code></pre></div>
        </details>
    </div>

  </div>




  <div class="doc doc-object doc-function">



<h2 class="doc doc-heading" id="sandpyper.common.create_id">
<code class="highlight language-python"><span class="n">create_id</span><span class="p">(</span><span class="n">series</span><span class="p">,</span> <span class="n">tr_id_field</span><span class="o">=</span><span class="s1">&#39;tr_id&#39;</span><span class="p">,</span> <span class="n">loc_field</span><span class="o">=</span><span class="s1">&#39;location&#39;</span><span class="p">,</span> <span class="n">dist_field</span><span class="o">=</span><span class="s1">&#39;distance&#39;</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span></code>


<a class="headerlink" href="#sandpyper.common.create_id" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Function to create unique IDs from random permutations of integers and letters from the distance, tr_id, location, coordinates and survey_date fields of the rgb and z tables.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>series</code></td>
        <td><code>pd.Series</code></td>
        <td><p>series having the selected fields.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>tr_id_field</code></td>
        <td><code>str</code></td>
        <td><p>Field name holding the transect ID (Default="tr_id").</p></td>
        <td><code>&#39;tr_id&#39;</code></td>
      </tr>
      <tr>
        <td><code>loc_field</code></td>
        <td><code>str</code></td>
        <td><p>Field name holding the location of the survey (Default="location").</p></td>
        <td><code>&#39;location&#39;</code></td>
      </tr>
      <tr>
        <td><code>dist_field</code></td>
        <td><code>str</code></td>
        <td><p>Field name holding the distance from start of the transect (Default="distance").</p></td>
        <td><code>&#39;distance&#39;</code></td>
      </tr>
      <tr>
        <td><code>random_state</code></td>
        <td><code>int</code></td>
        <td><p>Random seed.</p></td>
        <td><code>42</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>ids (list)</code></td>
      <td><p>A series od unique IDs.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>sandpyper\common.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">create_id</span><span class="p">(</span>
    <span class="n">series</span><span class="p">,</span>
    <span class="n">tr_id_field</span><span class="o">=</span><span class="s2">&quot;tr_id&quot;</span><span class="p">,</span>
    <span class="n">loc_field</span><span class="o">=</span><span class="s2">&quot;location&quot;</span><span class="p">,</span>
    <span class="n">dist_field</span><span class="o">=</span><span class="s2">&quot;distance&quot;</span><span class="p">,</span>
    <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Function to create unique IDs from random permutations of integers and letters from the distance, tr_id, location, coordinates and survey_date fields of the rgb and z tables.</span>

<span class="sd">    args:</span>
<span class="sd">        series (pd.Series): series having the selected fields.</span>
<span class="sd">        tr_id_field (str): Field name holding the transect ID (Default=&quot;tr_id&quot;).</span>
<span class="sd">        loc_field (str): Field name holding the location of the survey (Default=&quot;location&quot;).</span>
<span class="sd">        dist_field (str): Field name holding the distance from start of the transect (Default=&quot;distance&quot;).</span>
<span class="sd">        random_state (int): Random seed.</span>

<span class="sd">    returns:</span>
<span class="sd">        ids (list): A series od unique IDs.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">dist_c</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">series</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">dist_field</span><span class="p">]),</span> <span class="mi">2</span><span class="p">))</span>
    <span class="n">tr_id_c</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">series</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">tr_id_field</span><span class="p">])</span>
    <span class="n">loc_d</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">series</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">loc_field</span><span class="p">])</span>

    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">series</span><span class="o">.</span><span class="n">coordinates</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">coord_c</span> <span class="o">=</span> <span class="n">series</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">wkt</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">3</span><span class="p">:]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">coord_c</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">series</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">3</span><span class="p">:])</span>

    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">series</span><span class="o">.</span><span class="n">survey_date</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">date_c</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">series</span><span class="o">.</span><span class="n">survey_date</span><span class="o">.</span><span class="n">date</span><span class="p">())</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">date_c</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">series</span><span class="o">.</span><span class="n">survey_date</span><span class="p">)</span>

    <span class="n">ids_tmp</span> <span class="o">=</span> <span class="n">dist_c</span> <span class="o">+</span> <span class="s2">&quot;0&quot;</span> <span class="o">+</span> <span class="n">tr_id_c</span> <span class="o">+</span> <span class="n">loc_d</span> <span class="o">+</span> <span class="n">coord_c</span> <span class="o">+</span> <span class="n">date_c</span>

    <span class="n">ids</span> <span class="o">=</span> <span class="n">ids_tmp</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">,</span> <span class="s2">&quot;0&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
    <span class="n">char_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ids</span><span class="p">)</span>  <span class="c1"># convert string inti list</span>
    <span class="n">random</span><span class="o">.</span><span class="n">Random</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span>
        <span class="n">char_list</span><span class="p">,</span>
    <span class="p">)</span>  <span class="c1"># shuffle the list</span>
    <span class="n">ids</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">char_list</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">ids</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 class="doc doc-heading" id="sandpyper.common.create_spatial_id">
<code class="highlight language-python"><span class="n">create_spatial_id</span><span class="p">(</span><span class="n">series</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span></code>


<a class="headerlink" href="#sandpyper.common.create_spatial_id" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Function to create IDs indipended on the survey_date, but related to to distance, tr_id and location only. Equivalent to use coordinates field.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>series</code></td>
        <td><code>pd.Series</code></td>
        <td><p>series of merged table.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>random_state</code></td>
        <td><code>int</code></td>
        <td><p>Random seed.</p></td>
        <td><code>42</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>ids (list)</code></td>
      <td><p>A series od unique spatial IDs.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>sandpyper\common.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">create_spatial_id</span><span class="p">(</span><span class="n">series</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Function to create IDs indipended on the survey_date, but related to to distance, tr_id and location only. Equivalent to use coordinates field.</span>

<span class="sd">    args:</span>
<span class="sd">        series (pd.Series): series of merged table.</span>
<span class="sd">        random_state (int): Random seed.</span>

<span class="sd">    returns:</span>
<span class="sd">        ids (list): A series od unique spatial IDs.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ID indipended on the survey_date, but only related to distance, tr_id</span>
    <span class="c1"># and location. Useful ID, but equivalent to use coordinates field.</span>

    <span class="n">ids</span> <span class="o">=</span> <span class="p">(</span>
        <span class="nb">str</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">series</span><span class="o">.</span><span class="n">distance</span><span class="p">),</span> <span class="mi">2</span><span class="p">))</span>
        <span class="o">+</span> <span class="s2">&quot;0&quot;</span>
        <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">series</span><span class="o">.</span><span class="n">tr_id</span><span class="p">)</span>
        <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">series</span><span class="o">.</span><span class="n">location</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="n">ids</span> <span class="o">=</span> <span class="n">ids</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">,</span> <span class="s2">&quot;0&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
    <span class="n">char_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ids</span><span class="p">)</span>  <span class="c1"># convert string inti list</span>
    <span class="n">random</span><span class="o">.</span><span class="n">Random</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span>
        <span class="n">char_list</span><span class="p">,</span>
    <span class="p">)</span>  <span class="c1"># shuffle the list</span>
    <span class="n">ids</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">char_list</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">ids</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 class="doc doc-heading" id="sandpyper.common.create_transects">
<code class="highlight language-python"><span class="n">create_transects</span><span class="p">(</span><span class="n">baseline</span><span class="p">,</span> <span class="n">sampling_step</span><span class="p">,</span> <span class="n">tick_length</span><span class="p">,</span> <span class="n">location</span><span class="p">,</span> <span class="n">crs</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s1">&#39;both&#39;</span><span class="p">)</span></code>


<a class="headerlink" href="#sandpyper.common.create_transects" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Creates a GeoDataFrame with transects normal to the baseline, with defined spacing and length.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>baseline</code></td>
        <td><code>gdp.GeoDataFrame</code></td>
        <td><p>baseline geodataframe.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>sampling_step</code></td>
        <td><code>int,float</code></td>
        <td><p>alognshore spacing of transects in the CRS reference unit.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>tick_length</code></td>
        <td><code>int,float</code></td>
        <td><p>transects length</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>location</code></td>
        <td><code>str</code></td>
        <td><p>location code</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>crs</code></td>
        <td><code>dict</code></td>
        <td><p>coordinate reference system to georeference the transects. It must be in dictionary form.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>side</code></td>
        <td><code>str</code></td>
        <td><p>If "both", the transects will be centered on the baseline. If "left" or "right", transects will start from the baseline and extend to the left/right of it.</p></td>
        <td><code>&#39;both&#39;</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>gdf_transects (gpd.GeoDataFrame)</code></td>
      <td><p>Geodataframe of transects.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>sandpyper\common.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">create_transects</span><span class="p">(</span><span class="n">baseline</span><span class="p">,</span> <span class="n">sampling_step</span><span class="p">,</span> <span class="n">tick_length</span><span class="p">,</span> <span class="n">location</span><span class="p">,</span> <span class="n">crs</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s2">&quot;both&quot;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Creates a GeoDataFrame with transects normal to the baseline, with defined spacing and length.</span>

<span class="sd">    args:</span>
<span class="sd">        baseline (gdp.GeoDataFrame): baseline geodataframe.</span>
<span class="sd">        sampling_step (int,float): alognshore spacing of transects in the CRS reference unit.</span>
<span class="sd">        tick_length (int,float): transects length</span>
<span class="sd">        location (str): location code</span>
<span class="sd">        crs (dict): coordinate reference system to georeference the transects. It must be in dictionary form.</span>
<span class="sd">        side (str): If &quot;both&quot;, the transects will be centered on the baseline. If &quot;left&quot; or &quot;right&quot;, transects will start from the baseline and extend to the left/right of it.</span>

<span class="sd">    returns:</span>
<span class="sd">        gdf_transects (gpd.GeoDataFrame): Geodataframe of transects.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">side</span> <span class="o">!=</span> <span class="s2">&quot;both&quot;</span><span class="p">:</span>
        <span class="n">tick_length</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">tick_length</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="k">if</span> <span class="n">sampling_step</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">sampling_step</span> <span class="o">&gt;=</span> <span class="n">baseline</span><span class="o">.</span><span class="n">length</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Sampling step provided (</span><span class="si">{</span><span class="n">sampling_step</span><span class="si">}</span><span class="s2">) cannot be zero or equal or greater than the baseline length (</span><span class="si">{</span><span class="n">baseline</span><span class="o">.</span><span class="n">length</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">).&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">dists</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">baseline</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">length</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sampling_step</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">BaseException</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">dists</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">baseline</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">length</span><span class="p">,</span> <span class="n">sampling_step</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">BaseException</span><span class="p">:</span>
                <span class="n">dists</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">baseline</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">length</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sampling_step</span><span class="p">)</span>

        <span class="n">points_coords</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="p">[</span><span class="n">baseline</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">dists</span><span class="p">]:</span>
                <span class="n">points_coords</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">j</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">j</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="k">except</span> <span class="ne">BaseException</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="p">[</span><span class="n">baseline</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">dists</span><span class="p">]:</span>
                <span class="n">points_coords</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">j</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">j</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">y</span><span class="p">))</span>

                <span class="c1"># create transects as Shapely linestrings</span>

        <span class="n">ticks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">num</span><span class="p">,</span> <span class="n">pt</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">points_coords</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
            <span class="c1"># start chainage 0</span>
            <span class="k">if</span> <span class="n">num</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">angle</span> <span class="o">=</span> <span class="n">getAngle</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="n">points_coords</span><span class="p">[</span><span class="n">num</span><span class="p">])</span>
                <span class="n">line_end_1</span> <span class="o">=</span> <span class="n">getPoint1</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="n">angle</span><span class="p">,</span> <span class="n">tick_length</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
                <span class="n">angle</span> <span class="o">=</span> <span class="n">getAngle</span><span class="p">([</span><span class="n">line_end_1</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">line_end_1</span><span class="o">.</span><span class="n">y</span><span class="p">],</span> <span class="n">pt</span><span class="p">)</span>
                <span class="n">line_end_2</span> <span class="o">=</span> <span class="n">getPoint2</span><span class="p">([</span><span class="n">line_end_1</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">line_end_1</span><span class="o">.</span><span class="n">y</span><span class="p">],</span> <span class="n">angle</span><span class="p">,</span> <span class="n">tick_length</span><span class="p">)</span>
                <span class="n">tick</span> <span class="o">=</span> <span class="n">LineString</span><span class="p">(</span>
                    <span class="p">[(</span><span class="n">line_end_1</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">line_end_1</span><span class="o">.</span><span class="n">y</span><span class="p">),</span> <span class="p">(</span><span class="n">line_end_2</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">line_end_2</span><span class="o">.</span><span class="n">y</span><span class="p">)]</span>
                <span class="p">)</span>

            <span class="c1">## everything in between</span>
            <span class="k">if</span> <span class="n">num</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">points_coords</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">angle</span> <span class="o">=</span> <span class="n">getAngle</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="n">points_coords</span><span class="p">[</span><span class="n">num</span><span class="p">])</span>
                <span class="n">line_end_1</span> <span class="o">=</span> <span class="n">getPoint1</span><span class="p">(</span><span class="n">points_coords</span><span class="p">[</span><span class="n">num</span><span class="p">],</span> <span class="n">angle</span><span class="p">,</span> <span class="n">tick_length</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
                <span class="n">angle</span> <span class="o">=</span> <span class="n">getAngle</span><span class="p">([</span><span class="n">line_end_1</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">line_end_1</span><span class="o">.</span><span class="n">y</span><span class="p">],</span> <span class="n">points_coords</span><span class="p">[</span><span class="n">num</span><span class="p">])</span>
                <span class="n">line_end_2</span> <span class="o">=</span> <span class="n">getPoint2</span><span class="p">([</span><span class="n">line_end_1</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">line_end_1</span><span class="o">.</span><span class="n">y</span><span class="p">],</span> <span class="n">angle</span><span class="p">,</span> <span class="n">tick_length</span><span class="p">)</span>
                <span class="n">tick</span> <span class="o">=</span> <span class="n">LineString</span><span class="p">(</span>
                    <span class="p">[(</span><span class="n">line_end_1</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">line_end_1</span><span class="o">.</span><span class="n">y</span><span class="p">),</span> <span class="p">(</span><span class="n">line_end_2</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">line_end_2</span><span class="o">.</span><span class="n">y</span><span class="p">)]</span>
                <span class="p">)</span>

            <span class="c1"># end chainage</span>
            <span class="k">if</span> <span class="n">num</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">points_coords</span><span class="p">):</span>
                <span class="n">angle</span> <span class="o">=</span> <span class="n">getAngle</span><span class="p">(</span><span class="n">points_coords</span><span class="p">[</span><span class="n">num</span> <span class="o">-</span> <span class="mi">2</span><span class="p">],</span> <span class="n">pt</span><span class="p">)</span>
                <span class="n">line_end_1</span> <span class="o">=</span> <span class="n">getPoint1</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="n">angle</span><span class="p">,</span> <span class="n">tick_length</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
                <span class="n">angle</span> <span class="o">=</span> <span class="n">getAngle</span><span class="p">([</span><span class="n">line_end_1</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">line_end_1</span><span class="o">.</span><span class="n">y</span><span class="p">],</span> <span class="n">pt</span><span class="p">)</span>
                <span class="n">line_end_2</span> <span class="o">=</span> <span class="n">getPoint2</span><span class="p">([</span><span class="n">line_end_1</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">line_end_1</span><span class="o">.</span><span class="n">y</span><span class="p">],</span> <span class="n">angle</span><span class="p">,</span> <span class="n">tick_length</span><span class="p">)</span>
                <span class="n">tick</span> <span class="o">=</span> <span class="n">LineString</span><span class="p">(</span>
                    <span class="p">[(</span><span class="n">line_end_1</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">line_end_1</span><span class="o">.</span><span class="n">y</span><span class="p">),</span> <span class="p">(</span><span class="n">line_end_2</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">line_end_2</span><span class="o">.</span><span class="n">y</span><span class="p">)]</span>
                <span class="p">)</span>

            <span class="n">ticks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tick</span><span class="p">)</span>

        <span class="n">gdf_transects</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span>
            <span class="p">{</span>
                <span class="s2">&quot;tr_id&quot;</span><span class="p">:</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ticks</span><span class="p">)),</span>
                <span class="s2">&quot;geometry&quot;</span><span class="p">:</span> <span class="n">ticks</span><span class="p">,</span>
                <span class="s2">&quot;location&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">location</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ticks</span><span class="p">))],</span>
            <span class="p">},</span>
            <span class="n">crs</span><span class="o">=</span><span class="n">crs</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># clip the transects</span>

        <span class="k">if</span> <span class="n">side</span> <span class="o">==</span> <span class="s2">&quot;both&quot;</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>

            <span class="n">gdf_transects</span><span class="p">[</span><span class="s2">&quot;geometry&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gdf_transects</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
                <span class="n">split_transects</span><span class="p">,</span> <span class="o">**</span><span class="p">{</span><span class="s2">&quot;side&quot;</span><span class="p">:</span> <span class="n">side</span><span class="p">}</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">gdf_transects</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 class="doc doc-heading" id="sandpyper.common.cross_ref">
<code class="highlight language-python"><span class="n">cross_ref</span><span class="p">(</span><span class="n">dir_inputs</span><span class="p">,</span> <span class="n">dirNameTrans</span><span class="p">,</span> <span class="n">loc_search_dict</span><span class="p">,</span> <span class="n">list_loc_codes</span><span class="p">,</span> <span class="n">print_info</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>


<a class="headerlink" href="#sandpyper.common.cross_ref" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Returns a dataframe with location, raw_date, filenames (paths) and CRS of each raster and associated transect files. Used to double-check.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>dir_inputs</code></td>
        <td><code>str</code></td>
        <td><p>Path of the directory containing the geotiffs datasets (.tiff or .tif).</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>dirNameTrans</code></td>
        <td><code>str</code></td>
        <td><p>Path of the directory containing the transects (geopackages, .gpkg).</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>loc_search_dict</code></td>
        <td><code>list</code></td>
        <td><p>Dictionary used to match filename with right location code.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>list_loc_codes</code></td>
        <td><code>list</code></td>
        <td><p>list of strings containing location codes.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>print_info</code></td>
        <td><code>bool</code></td>
        <td><p>If True, prints count of datasets/location and total. Default = False.</p></td>
        <td><code>False</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>rasters_df (pd.DataFRame)</code></td>
      <td><p>Dataframe and information about raster-transect files matches.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>sandpyper\common.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">cross_ref</span><span class="p">(</span>
    <span class="n">dir_inputs</span><span class="p">,</span> <span class="n">dirNameTrans</span><span class="p">,</span> <span class="n">loc_search_dict</span><span class="p">,</span> <span class="n">list_loc_codes</span><span class="p">,</span> <span class="n">print_info</span><span class="o">=</span><span class="kc">False</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns a dataframe with location, raw_date, filenames (paths) and CRS of each raster and associated transect files. Used to double-check.</span>

<span class="sd">    args:</span>
<span class="sd">        dir_inputs (str): Path of the directory containing the geotiffs datasets (.tiff or .tif).</span>
<span class="sd">        dirNameTrans (str): Path of the directory containing the transects (geopackages, .gpkg).</span>
<span class="sd">        loc_search_dict (list): Dictionary used to match filename with right location code.</span>
<span class="sd">        list_loc_codes (list): list of strings containing location codes.</span>
<span class="sd">        print_info (bool): If True, prints count of datasets/location and total. Default = False.</span>

<span class="sd">    returns:</span>
<span class="sd">        rasters_df (pd.DataFRame): Dataframe and information about raster-transect files matches.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">ras_type_dict</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">:</span><span class="s2">&quot;dsm&quot;</span><span class="p">,</span>
                  <span class="mi">1</span><span class="p">:</span><span class="s2">&quot;ortho&quot;</span><span class="p">}</span>

    <span class="c1"># DF transects</span>
    <span class="n">list_transects</span> <span class="o">=</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="sa">rf</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">dirNameTrans</span><span class="si">}</span><span class="s2">/*.gpkg&quot;</span><span class="p">)</span>
    <span class="n">locs_transects</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
        <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span>
            <span class="p">[</span><span class="n">getLoc</span><span class="p">(</span><span class="n">trs</span><span class="p">,</span> <span class="n">list_loc_codes</span><span class="p">)</span> <span class="k">for</span> <span class="n">trs</span> <span class="ow">in</span> <span class="n">list_transects</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;location&quot;</span>
        <span class="p">)</span>
    <span class="p">)</span>

    <span class="n">df_tmp_trd</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">locs_transects</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;location&quot;</span><span class="p">])</span>
    <span class="n">df_tmp_trd</span><span class="p">[</span><span class="s2">&quot;filename_trs&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">list_transects</span>
    <span class="n">df_tmp_trd</span><span class="p">[</span><span class="s2">&quot;crs_transect&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df_tmp_trd</span><span class="o">.</span><span class="n">filename_trs</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">getCrs_from_transect</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dir_inputs</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">dirs</span><span class="o">=</span><span class="n">dir_inputs</span>
        <span class="n">list_rasters_check_dsm</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">list_rasters_check_orthos</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dirs</span><span class="o">=</span><span class="p">[</span><span class="n">dir_inputs</span><span class="p">]</span>

    <span class="n">rasters_df</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">path_in</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dirs</span><span class="p">):</span>

        <span class="n">list_rasters</span> <span class="o">=</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="sa">rf</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">path_in</span><span class="si">}</span><span class="s2">/*.ti*&quot;</span><span class="p">)</span>
        <span class="n">raster_types</span><span class="o">=</span><span class="p">[</span><span class="n">filepath_raster_type</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">list_rasters</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">raster_types</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Mixed input types have been found in </span><span class="si">{</span><span class="n">ras_type_dict</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s2"> folder. Each folder has to contain either DSMs or orthos only.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dir_inputs</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">list_rasters_check_dsm</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">extract_loc_date</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">i</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">loc_search_dict</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">list_rasters</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">list_rasters_check_orthos</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">extract_loc_date</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">i</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">loc_search_dict</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">list_rasters</span><span class="p">])</span>

        <span class="n">loc_date_labels_raster</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">extract_loc_date</span><span class="p">(</span><span class="n">file1</span><span class="p">,</span> <span class="n">loc_search_dict</span><span class="o">=</span><span class="n">loc_search_dict</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">file1</span> <span class="ow">in</span> <span class="n">list_rasters</span>
        <span class="p">]</span>

        <span class="n">df_tmp_raster</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="n">loc_date_labels_raster</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;location&quot;</span><span class="p">,</span> <span class="s2">&quot;raw_date&quot;</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">df_tmp_raster</span><span class="p">[</span><span class="s2">&quot;filename_raster&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">list_rasters</span>
        <span class="n">df_tmp_raster</span><span class="p">[</span><span class="s2">&quot;crs_raster&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df_tmp_raster</span><span class="o">.</span><span class="n">filename_raster</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
            <span class="n">getCrs_from_raster_path</span>
        <span class="p">)</span>
        <span class="n">df_tmp_raster</span><span class="p">[</span><span class="s2">&quot;raster_type&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">raster_types</span>

        <span class="n">rasters_df</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">rasters_df</span><span class="p">,</span><span class="n">df_tmp_raster</span><span class="p">],</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>


    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dir_inputs</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>

            <span class="n">missing_dsms</span><span class="o">=</span><span class="nb">set</span><span class="p">(</span><span class="o">*</span><span class="n">list_rasters_check_orthos</span><span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="o">*</span><span class="n">list_rasters_check_dsm</span><span class="p">))</span>
            <span class="n">missing_orthos</span><span class="o">=</span><span class="nb">set</span><span class="p">(</span><span class="o">*</span><span class="n">list_rasters_check_dsm</span><span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="o">*</span><span class="n">list_rasters_check_orthos</span><span class="p">))</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">missing_dsms</span><span class="p">)</span> <span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;WARNING: </span><span class="si">{</span><span class="n">missing_dsms</span><span class="si">}</span><span class="s2"> missing or misnamed from the DSMs folder.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">pass</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">missing_orthos</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;WARNING: </span><span class="si">{</span><span class="n">missing_orthos</span><span class="si">}</span><span class="s2"> missing or misnamed from orthos folder.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">pass</span>

    <span class="n">matched</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">rasters_df</span><span class="p">,</span> <span class="n">df_tmp_trd</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="s2">&quot;location&quot;</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span>
        <span class="p">[</span><span class="s2">&quot;location&quot;</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="n">check_formatted</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">matched</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="s2">&quot;raster_type==&#39;ortho&#39;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(),</span>
         <span class="n">matched</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="s2">&quot;raster_type==&#39;dsm&#39;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(),</span>
        <span class="n">on</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;location&quot;</span><span class="p">,</span><span class="s2">&quot;raw_date&quot;</span><span class="p">],</span><span class="n">suffixes</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;_ortho&quot;</span><span class="p">,</span><span class="s2">&quot;_dsm&quot;</span><span class="p">))</span>

    <span class="n">check_formatted</span><span class="o">=</span><span class="n">check_formatted</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,[</span> <span class="s1">&#39;raw_date&#39;</span><span class="p">,</span><span class="s1">&#39;location&#39;</span><span class="p">,</span><span class="s1">&#39;filename_trs_ortho&#39;</span><span class="p">,</span><span class="s1">&#39;crs_transect_dsm&#39;</span><span class="p">,</span>
     <span class="s1">&#39;filename_raster_dsm&#39;</span><span class="p">,</span><span class="s1">&#39;filename_raster_ortho&#39;</span><span class="p">,</span>
    <span class="s1">&#39;crs_raster_dsm&#39;</span><span class="p">,</span><span class="s1">&#39;crs_raster_ortho&#39;</span><span class="p">]]</span>


    <span class="k">if</span> <span class="nb">bool</span><span class="p">(</span><span class="n">print_info</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">counts</span><span class="o">=</span><span class="n">matched</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s2">&quot;location&quot;</span><span class="p">,</span><span class="s2">&quot;raster_type&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">count</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">row</span> <span class="ow">in</span> <span class="n">counts</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">row</span><span class="p">[</span><span class="s1">&#39;raster_type&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> from </span><span class="si">{</span><span class="n">row</span><span class="p">[</span><span class="s1">&#39;location&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">row</span><span class="p">[</span><span class="s1">&#39;raw_date&#39;</span><span class="p">]</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">umber OF DATASETS TO PROCESS: </span><span class="si">{</span><span class="n">counts</span><span class="o">.</span><span class="n">raw_date</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">check_formatted</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 class="doc doc-heading" id="sandpyper.common.dissolve_shores">
<code class="highlight language-python"><span class="n">dissolve_shores</span><span class="p">(</span><span class="n">gdf_shores</span><span class="p">,</span> <span class="n">field</span><span class="o">=</span><span class="s1">&#39;date&#39;</span><span class="p">)</span></code>


<a class="headerlink" href="#sandpyper.common.dissolve_shores" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Dissolves multi-part shorelines into one geometry per location-date. Uses GeoPandas.GeoDataFrame.dissolve method.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>gdf_shores</code></td>
        <td><code>gpd.GeoDataFrame</code></td>
        <td><p>The geodataframe storing the shoreline.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>field</code></td>
        <td><code>str</code></td>
        <td><p>The field to be used to dissolve shorelines. Default to "date".</p></td>
        <td><code>&#39;date&#39;</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>dissolved (gpd.GeoDataFrame)</code></td>
      <td><p>GeoDataFrame with one geometry per location-date combination.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>sandpyper\common.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">dissolve_shores</span><span class="p">(</span><span class="n">gdf_shores</span><span class="p">,</span> <span class="n">field</span><span class="o">=</span><span class="s2">&quot;date&quot;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Dissolves multi-part shorelines into one geometry per location-date. Uses GeoPandas.GeoDataFrame.dissolve method.</span>

<span class="sd">    args:</span>
<span class="sd">        gdf_shores (gpd.GeoDataFrame): The geodataframe storing the shoreline.</span>
<span class="sd">        field (str): The field to be used to dissolve shorelines. Default to &quot;date&quot;.</span>

<span class="sd">    returns:</span>
<span class="sd">        dissolved (gpd.GeoDataFrame): GeoDataFrame with one geometry per location-date combination.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">gdf_shores</span><span class="o">.</span><span class="n">location</span><span class="o">.</span><span class="n">unique</span><span class="p">())</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">multi_location</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">multi_location</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="n">dissolved</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
    <span class="k">if</span> <span class="nb">bool</span><span class="p">(</span><span class="n">multi_location</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">loc</span> <span class="ow">in</span> <span class="n">gdf_shores</span><span class="o">.</span><span class="n">location</span><span class="o">.</span><span class="n">unique</span><span class="p">():</span>
            <span class="n">geom</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">gdf_shores</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;location==&#39;</span><span class="si">{</span><span class="n">loc</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">dissolve</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="n">field</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
            <span class="p">)</span>
            <span class="n">dissolved</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">dissolved</span><span class="p">,</span> <span class="n">geom</span><span class="p">],</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">gdf_shores</span><span class="p">[</span><span class="s2">&quot;diss&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">geom</span> <span class="o">=</span> <span class="n">gdf_shores</span><span class="o">.</span><span class="n">dissolve</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="s2">&quot;diss&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
        <span class="n">dissolved</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">dissolved</span><span class="p">,</span> <span class="n">geom</span><span class="p">],</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">dissolved</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s2">&quot;diss&quot;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">dissolved</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 class="doc doc-heading" id="sandpyper.common.error_from_gt">
<code class="highlight language-python"><span class="n">error_from_gt</span><span class="p">(</span><span class="n">shorelines</span><span class="p">,</span> <span class="n">groundtruths</span><span class="p">,</span> <span class="n">crs_dict_string</span><span class="p">,</span> <span class="n">location</span><span class="p">,</span> <span class="n">sampling_step</span><span class="p">,</span> <span class="n">tick_length</span><span class="p">,</span> <span class="n">shore_geometry_field</span><span class="p">,</span> <span class="n">gt_geometry_field</span><span class="p">,</span> <span class="n">gt_date_field</span><span class="o">=</span><span class="s1">&#39;raw_date&#39;</span><span class="p">,</span> <span class="n">shore_date_field</span><span class="o">=</span><span class="s1">&#39;raw_date&#39;</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s1">&#39;both&#39;</span><span class="p">,</span> <span class="n">baseline_mode</span><span class="o">=</span><span class="s1">&#39;dynamic&#39;</span><span class="p">,</span> <span class="n">tidal_correct</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>


<a class="headerlink" href="#sandpyper.common.error_from_gt" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Compute shorelines errors from a groundtruth references. You can use a fixed baseline shoreline or let the baseline be dynamic, which means
that a new set of transects will be created on each groundtruth shoreline.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>shorelines</code></td>
        <td><code>gpd.GeoDataFrame</code></td>
        <td><p>GeoDataFrame of shorelines to test.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>groundtruths</code></td>
        <td><code>gpd.GeoDataFrame</code></td>
        <td><p>GeoDataFrame of shorelines to test.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>crs_dict_string</code></td>
        <td><code>dict</code></td>
        <td><p>Dictionary storing location codes as key and crs information as EPSG code (int).</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>location</code></td>
        <td><code>str</code></td>
        <td><p>Strings of location code ("apo").</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>sampling_step</code></td>
        <td><code>int, float</code></td>
        <td><p>Alongshore distanace to separate each evaluation transect.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>tick_length</code></td>
        <td><code>int, float</code></td>
        <td><p>Length of transects.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>shore_geometry_field</code></td>
        <td><code>str</code></td>
        <td><p>Field where the geometry of the test shoreline is stored.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>gt_geometry_field</code></td>
        <td><code>str</code></td>
        <td><p>Field where the geometry of the groundtruth shoreline is stored.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>gt_date_field</code></td>
        <td><code>str</code></td>
        <td><p>Field where the survey dates are stored in the groundtruth dataset.</p></td>
        <td><code>&#39;raw_date&#39;</code></td>
      </tr>
      <tr>
        <td><code>shore_date_field</code></td>
        <td><code>str</code></td>
        <td><p>Field where the survey dates are stored in the to-correct dataset.</p></td>
        <td><code>&#39;raw_date&#39;</code></td>
      </tr>
      <tr>
        <td><code>side</code></td>
        <td><code>str</code></td>
        <td><p>Whether to create transect on the right, left or both sides. Default to "both".</p></td>
        <td><code>&#39;both&#39;</code></td>
      </tr>
      <tr>
        <td><code>baseline_mode</code></td>
        <td><code>str</code></td>
        <td><p>If "dynamic" (default), statistics will be computed from transects created from each groundtruth shoreline. If path to a .gpkg is provided, then use those arbitrary location specific baselines and transects will be fixed.</p></td>
        <td><code>&#39;dynamic&#39;</code></td>
      </tr>
      <tr>
        <td><code>tidal_correct</code></td>
        <td><code>str, None</code></td>
        <td><p>If str, apply tidal correction.</p></td>
        <td><code>None</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>pd.DataFrame</code></td>
      <td><p>Dataframe containing the distances from groundtruth at each timestep.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>sandpyper\common.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">error_from_gt</span><span class="p">(</span>
    <span class="n">shorelines</span><span class="p">,</span>
    <span class="n">groundtruths</span><span class="p">,</span>
    <span class="n">crs_dict_string</span><span class="p">,</span>
    <span class="n">location</span><span class="p">,</span>
    <span class="n">sampling_step</span><span class="p">,</span>
    <span class="n">tick_length</span><span class="p">,</span>
    <span class="n">shore_geometry_field</span><span class="p">,</span>
    <span class="n">gt_geometry_field</span><span class="p">,</span>
    <span class="n">gt_date_field</span><span class="o">=</span><span class="s2">&quot;raw_date&quot;</span><span class="p">,</span>
    <span class="n">shore_date_field</span><span class="o">=</span><span class="s2">&quot;raw_date&quot;</span><span class="p">,</span>
    <span class="n">side</span><span class="o">=</span><span class="s2">&quot;both&quot;</span><span class="p">,</span>
    <span class="n">baseline_mode</span><span class="o">=</span><span class="s2">&quot;dynamic&quot;</span><span class="p">,</span>
    <span class="n">tidal_correct</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute shorelines errors from a groundtruth references. You can use a fixed baseline shoreline or let the baseline be dynamic, which means</span>
<span class="sd">    that a new set of transects will be created on each groundtruth shoreline.</span>

<span class="sd">    Args:</span>
<span class="sd">        shorelines (gpd.GeoDataFrame): GeoDataFrame of shorelines to test.</span>
<span class="sd">        groundtruths (gpd.GeoDataFrame): GeoDataFrame of shorelines to test.</span>
<span class="sd">        crs_dict_string (dict): Dictionary storing location codes as key and crs information as EPSG code (int).</span>
<span class="sd">        location (str): Strings of location code (&quot;apo&quot;).</span>
<span class="sd">        sampling_step (int, float): Alongshore distanace to separate each evaluation transect.</span>
<span class="sd">        tick_length (int, float): Length of transects.</span>
<span class="sd">        shore_geometry_field (str): Field where the geometry of the test shoreline is stored.</span>
<span class="sd">        gt_geometry_field (str): Field where the geometry of the groundtruth shoreline is stored.</span>
<span class="sd">        gt_date_field (str): Field where the survey dates are stored in the groundtruth dataset.</span>
<span class="sd">        shore_date_field (str): Field where the survey dates are stored in the to-correct dataset.</span>
<span class="sd">        side (str): Whether to create transect on the right, left or both sides. Default to &quot;both&quot;.</span>
<span class="sd">        baseline_mode (str): If &quot;dynamic&quot; (default), statistics will be computed from transects created from each groundtruth shoreline. If path to a .gpkg is provided, then use those arbitrary location specific baselines and transects will be fixed.</span>
<span class="sd">        tidal_correct (str, None): If str, apply tidal correction.</span>
<span class="sd">    Returns:</span>
<span class="sd">        pd.DataFrame: Dataframe containing the distances from groundtruth at each timestep.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">crs</span> <span class="o">=</span> <span class="n">crs_dict_string</span><span class="p">[</span><span class="n">loc</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">baseline_mode</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Fixed baseline mode selected.&quot;</span><span class="p">)</span>
        <span class="n">baseline_loc</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="n">baseline_mode</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">baseline_loc</span><span class="o">.</span><span class="n">crs</span> <span class="o">!=</span> <span class="n">crs</span><span class="p">:</span>
            <span class="n">baseline_loc</span> <span class="o">=</span> <span class="n">baseline_loc</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span><span class="n">crs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="n">transects</span> <span class="o">=</span> <span class="n">create_transects</span><span class="p">(</span>
            <span class="n">baseline_loc</span><span class="p">,</span>
            <span class="n">sampling_step</span><span class="o">=</span><span class="n">sampling_step</span><span class="p">,</span>
            <span class="n">tick_length</span><span class="o">=</span><span class="n">tick_length</span><span class="p">,</span>
            <span class="n">crs</span><span class="o">=</span><span class="n">crs</span><span class="p">,</span>
            <span class="n">location</span><span class="o">=</span><span class="n">location</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">df_temp</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span>
            <span class="p">{</span>
                <span class="s2">&quot;geometry&quot;</span><span class="p">:</span> <span class="p">[</span>
                    <span class="n">Point</span><span class="p">(</span><span class="n">tr_geom</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">tr_geom</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
                    <span class="k">for</span> <span class="n">tr_geom</span> <span class="ow">in</span> <span class="n">transects</span><span class="o">.</span><span class="n">geometry</span>
                <span class="p">],</span>
                <span class="s2">&quot;tr_id&quot;</span><span class="p">:</span> <span class="n">transects</span><span class="o">.</span><span class="n">tr_id</span><span class="p">,</span>
            <span class="p">}</span>
        <span class="p">)</span>
        <span class="n">baseline_pts</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span><span class="n">df_temp</span><span class="p">,</span> <span class="n">geometry</span><span class="o">=</span><span class="s2">&quot;geometry&quot;</span><span class="p">,</span> <span class="n">crs</span><span class="o">=</span><span class="n">crs</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">baseline_mode</span> <span class="o">==</span> <span class="s2">&quot;dynamic&quot;</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Dynamic baseline mode selected.&quot;</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s2">&quot;Baseline mode must be either &#39;dynamic&#39; or a valid path to a .gpkg.&quot;</span>
        <span class="p">)</span>

    <span class="n">shore_shift_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>

    <span class="c1"># subset CS shorelines with a location</span>
    <span class="n">cs_shore_in</span> <span class="o">=</span> <span class="n">groundtruths</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;location==&#39;</span><span class="si">{</span><span class="n">location</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>
    <span class="c1"># select all Sentinel-2 shorelines in that location</span>
    <span class="n">tests</span> <span class="o">=</span> <span class="n">shorelines</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;location==&#39;</span><span class="si">{</span><span class="n">location</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>

    <span class="c1"># if cs_shore_in.crs != crs:</span>
    <span class="c1">#     cs_shore_in=cs_shore_in.to_crs(crs)</span>
    <span class="c1"># else:</span>
    <span class="c1">#     pass</span>
    <span class="c1">#</span>
    <span class="c1"># if tests.crs != crs:</span>
    <span class="c1">#     tests=tests.to_crs(crs)</span>
    <span class="c1"># else:</span>
    <span class="c1">#     pass</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cs_shore_in</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>  <span class="c1"># for all CS groundtruths in location</span>

        <span class="n">groundtruth</span> <span class="o">=</span> <span class="n">cs_shore_in</span><span class="o">.</span><span class="n">iloc</span><span class="p">[[</span><span class="n">i</span><span class="p">]]</span>  <span class="c1"># select the current groundtruth</span>

        <span class="c1"># get survey date           # HARDCODED DATE FIELD! BAD</span>
        <span class="n">survey_date</span> <span class="o">=</span> <span class="n">groundtruth</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">gt_date_field</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">survey_date</span> <span class="ow">in</span> <span class="n">tests</span><span class="o">.</span><span class="n">raw_date</span><span class="o">.</span><span class="n">unique</span><span class="p">():</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Working on </span><span class="si">{</span><span class="n">survey_date</span><span class="si">}</span><span class="s2">...&quot;</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Groundtruth in date </span><span class="si">{</span><span class="n">survey_date</span><span class="si">}</span><span class="s2"> not matched with any shorelines date.&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">baseline_mode</span> <span class="o">==</span> <span class="s2">&quot;dynamic&quot;</span><span class="p">:</span>
            <span class="c1"># create transects and baselines pts dynamically from each groundtruth</span>
            <span class="c1"># shoreline</span>
            <span class="n">transects</span> <span class="o">=</span> <span class="n">create_transects</span><span class="p">(</span>
                <span class="n">groundtruth</span><span class="p">,</span>
                <span class="n">sampling_step</span><span class="o">=</span><span class="n">sampling_step</span><span class="p">,</span>
                <span class="n">tick_length</span><span class="o">=</span><span class="n">tick_length</span><span class="p">,</span>
                <span class="n">crs</span><span class="o">=</span><span class="n">crs</span><span class="p">,</span>
                <span class="n">location</span><span class="o">=</span><span class="n">location</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="c1"># create a geodataframe of transects starting points to compute distance</span>
            <span class="c1"># from</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span>
                <span class="p">{</span>
                    <span class="s2">&quot;geometry&quot;</span><span class="p">:</span> <span class="p">[</span>
                        <span class="n">Point</span><span class="p">(</span><span class="n">tr_geom</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">tr_geom</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
                        <span class="k">for</span> <span class="n">tr_geom</span> <span class="ow">in</span> <span class="n">transects</span><span class="o">.</span><span class="n">geometry</span>
                    <span class="p">],</span>
                    <span class="s2">&quot;tr_id&quot;</span><span class="p">:</span> <span class="n">transects</span><span class="o">.</span><span class="n">tr_id</span><span class="p">,</span>
                <span class="p">}</span>
            <span class="p">)</span>
            <span class="n">baseline_pts</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">geometry</span><span class="o">=</span><span class="s2">&quot;geometry&quot;</span><span class="p">,</span> <span class="n">crs</span><span class="o">=</span><span class="n">crs</span><span class="p">)</span>

            <span class="c1"># extract groundtruth distance from baseline (should be half transect,</span>
            <span class="c1"># i.e. transect centroid)</span>
            <span class="n">gt_pts</span> <span class="o">=</span> <span class="n">extract_shore_pts</span><span class="p">(</span><span class="n">transects</span><span class="p">,</span> <span class="n">groundtruth</span><span class="p">)</span>

        <span class="n">transects</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="s2">&quot;raw_date&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">survey_date</span>

        <span class="c1"># list all the satellite shorelines that corresponds to the groundtruth</span>
        <span class="n">sat_shores_in</span> <span class="o">=</span> <span class="n">tests</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;raw_date==&#39;</span><span class="si">{</span><span class="n">survey_date</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sat_shores_in</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>

            <span class="n">shore_sat</span> <span class="o">=</span> <span class="n">sat_shores_in</span><span class="o">.</span><span class="n">iloc</span><span class="p">[[</span><span class="n">j</span><span class="p">]]</span>

            <span class="n">new_transects</span> <span class="o">=</span> <span class="n">shore_shift</span><span class="p">(</span>
                <span class="n">transects</span><span class="o">=</span><span class="n">transects</span><span class="p">,</span>
                <span class="n">gt</span><span class="o">=</span><span class="n">groundtruth</span><span class="p">,</span>
                <span class="n">sat</span><span class="o">=</span><span class="n">shore_sat</span><span class="p">,</span>
                <span class="n">crs</span><span class="o">=</span><span class="n">crs</span><span class="p">,</span>
                <span class="n">baseline_pts</span><span class="o">=</span><span class="n">baseline_pts</span><span class="p">,</span>
                <span class="n">sat_from_baseline</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="n">shore_sat</span><span class="o">.</span><span class="n">rename</span><span class="p">({</span><span class="s2">&quot;geometry&quot;</span><span class="p">:</span> <span class="s2">&quot;geom_shoreline&quot;</span><span class="p">},</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">merged</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">shore_sat</span><span class="p">,</span> <span class="n">new_transects</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="s2">&quot;raw_date&quot;</span><span class="p">)</span>
            <span class="n">merged</span><span class="o">.</span><span class="n">rename</span><span class="p">({</span><span class="s2">&quot;location_x&quot;</span><span class="p">:</span> <span class="s2">&quot;location&quot;</span><span class="p">},</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="n">shore_shift_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">shore_shift_df</span><span class="p">,</span> <span class="n">merged</span><span class="p">],</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">shore_shift_df</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 class="doc doc-heading" id="sandpyper.common.extract_from_folder">
<code class="highlight language-python"><span class="n">extract_from_folder</span><span class="p">(</span><span class="n">dataset_folder</span><span class="p">,</span> <span class="n">transect_folder</span><span class="p">,</span> <span class="n">tr_ids</span><span class="p">,</span> <span class="n">list_loc_codes</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">sampling_step</span><span class="p">,</span> <span class="n">add_xy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">add_slope</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">default_nan_values</span><span class="o">=-</span><span class="mi">10000</span><span class="p">)</span></code>


<a class="headerlink" href="#sandpyper.common.extract_from_folder" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Wrapper to extract profiles from all rasters inside a folder.</p>
<p>Warning: The folders must contain the geotiffs and geopackages only.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>dataset_folder</code></td>
        <td><code>str</code></td>
        <td><p>Path of the directory containing the datasets (geotiffs, .tiff).</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>transect_folder</code></td>
        <td><code>str</code></td>
        <td><p>Path of the directory containing the transects (geopackages, .gpkg).</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>tr_ids</code></td>
        <td><code>str</code></td>
        <td><p>If 'reset', a new incremental transect_id will be automatically assigned. If the name of a column in the transect files is provided, use that column as transect IDs.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>list_loc_codes</code></td>
        <td><code>list</code></td>
        <td><p>list of strings containing location codes.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>mode</code></td>
        <td><code>str</code></td>
        <td><p>If 'dsm', extract from DSMs. If 'ortho', extracts from orthophotos.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>sampling_step</code></td>
        <td><code>float</code></td>
        <td><p>Distance along-transect to sample points at. In meters.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>add_xy</code></td>
        <td><code>bool</code></td>
        <td><p>If True, adds extra columns with long and lat coordinates in the input CRS.</p></td>
        <td><code>False</code></td>
      </tr>
      <tr>
        <td><code>add_slope</code></td>
        <td><code>bool</code></td>
        <td><p>If True, computes slope raster in degrees (increased processing time) and extract slope values across transects.</p></td>
        <td><code>False</code></td>
      </tr>
      <tr>
        <td><code>default_nan_values</code></td>
        <td><code>int</code></td>
        <td><p>Value used for NoData in the raster format. In Pix4D, this is -10000 (Default).</p></td>
        <td><code>-10000</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>gdf (gpd.GeoDataFrame)</code></td>
      <td><p>A geodataframe with survey and topographical or color information extracted.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>sandpyper\common.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">extract_from_folder</span><span class="p">(</span>
    <span class="n">dataset_folder</span><span class="p">,</span>
    <span class="n">transect_folder</span><span class="p">,</span>
    <span class="n">tr_ids</span><span class="p">,</span>
    <span class="n">list_loc_codes</span><span class="p">,</span>
    <span class="n">mode</span><span class="p">,</span>
    <span class="n">sampling_step</span><span class="p">,</span>
    <span class="n">add_xy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">add_slope</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">default_nan_values</span><span class="o">=-</span><span class="mi">10000</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Wrapper to extract profiles from all rasters inside a folder.</span>

<span class="sd">    Warning: The folders must contain the geotiffs and geopackages only.</span>

<span class="sd">    Args:</span>
<span class="sd">        dataset_folder (str): Path of the directory containing the datasets (geotiffs, .tiff).</span>
<span class="sd">        transect_folder (str): Path of the directory containing the transects (geopackages, .gpkg).</span>
<span class="sd">        tr_ids (str): If &#39;reset&#39;, a new incremental transect_id will be automatically assigned. If the name of a column in the transect files is provided, use that column as transect IDs.</span>
<span class="sd">        list_loc_codes (list): list of strings containing location codes.</span>
<span class="sd">        mode (str): If &#39;dsm&#39;, extract from DSMs. If &#39;ortho&#39;, extracts from orthophotos.</span>
<span class="sd">        sampling_step (float): Distance along-transect to sample points at. In meters.</span>
<span class="sd">        add_xy (bool): If True, adds extra columns with long and lat coordinates in the input CRS.</span>
<span class="sd">        add_slope (bool): If True, computes slope raster in degrees (increased processing time) and extract slope values across transects.</span>
<span class="sd">        default_nan_values (int): Value used for NoData in the raster format. In Pix4D, this is -10000 (Default).</span>

<span class="sd">    Returns:</span>
<span class="sd">        gdf (gpd.GeoDataFrame): A geodataframe with survey and topographical or color information extracted.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Get a list of all the filenames and path</span>
    <span class="n">list_files</span> <span class="o">=</span> <span class="n">filter_filename_list</span><span class="p">(</span>
        <span class="n">getListOfFiles</span><span class="p">(</span><span class="n">dataset_folder</span><span class="p">),</span> <span class="n">fmt</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;.tif&quot;</span><span class="p">,</span> <span class="s2">&quot;.tiff&quot;</span><span class="p">]</span>
    <span class="p">)</span>

    <span class="n">dates</span> <span class="o">=</span> <span class="p">[</span><span class="n">getDate</span><span class="p">(</span><span class="n">dsm_in</span><span class="p">)</span> <span class="k">for</span> <span class="n">dsm_in</span> <span class="ow">in</span> <span class="n">list_files</span><span class="p">]</span>

    <span class="c1"># List all the transects datasets</span>
    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">transect_folder</span><span class="p">):</span>
        <span class="n">list_trans</span> <span class="o">=</span> <span class="n">getListOfFiles</span><span class="p">(</span><span class="n">transect_folder</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">transect_folder</span><span class="p">):</span>
        <span class="n">list_trans</span> <span class="o">=</span> <span class="n">getListOfFiles</span><span class="p">(</span><span class="n">transect_folder</span><span class="p">)</span>

    <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="c1"># Set the sampling distance (step) for your profiles</span>

    <span class="n">gdf</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
    <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">if</span> <span class="nb">bool</span><span class="p">(</span><span class="n">add_slope</span><span class="p">):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;WARNING: add_terrain could increase processing time considerably for fine scale DSMs.&quot;</span>
        <span class="p">)</span>

    <span class="k">for</span> <span class="n">dsm</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">list_files</span><span class="p">):</span>
        <span class="k">with</span> <span class="n">ras</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">dsm</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">ds</span><span class="p">:</span>
            <span class="n">nan_values</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">nodata</span>
            <span class="k">if</span> <span class="n">nan_values</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">nan_values</span><span class="o">=</span><span class="n">default_nan_values</span>

        <span class="n">date_string</span> <span class="o">=</span> <span class="n">getDate</span><span class="p">(</span><span class="n">dsm</span><span class="p">)</span>
        <span class="n">location</span> <span class="o">=</span> <span class="n">getLoc</span><span class="p">(</span><span class="n">dsm</span><span class="p">,</span> <span class="n">list_loc_codes</span><span class="p">)</span>


        <span class="k">if</span> <span class="nb">bool</span><span class="p">(</span><span class="n">add_slope</span><span class="p">):</span>

            <span class="n">terr</span> <span class="o">=</span> <span class="n">rd</span><span class="o">.</span><span class="n">LoadGDAL</span><span class="p">(</span><span class="n">dsm</span><span class="p">,</span> <span class="n">no_data</span><span class="o">=</span><span class="n">nan_values</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Computing slope DSM in degrees in </span><span class="si">{</span><span class="n">location</span><span class="si">}</span><span class="s2"> at date: </span><span class="si">{</span><span class="n">date_string</span><span class="si">}</span><span class="s2"> . . .&quot;</span>
            <span class="p">)</span>
            <span class="n">slope</span> <span class="o">=</span> <span class="n">rd</span><span class="o">.</span><span class="n">TerrainAttribute</span><span class="p">(</span><span class="n">terr</span><span class="p">,</span> <span class="n">attrib</span><span class="o">=</span><span class="s2">&quot;slope_degrees&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">slope</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="n">transect_file_input</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">list_trans</span> <span class="k">if</span> <span class="n">location</span> <span class="ow">in</span> <span class="n">a</span><span class="p">]</span>
        <span class="n">transect_file</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="n">transect_file_input</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="n">tr_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">transect_file</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">tr_list</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;dsm&quot;</span><span class="p">:</span>
                <span class="n">temp</span> <span class="o">=</span> <span class="n">get_profiles</span><span class="p">(</span>
                    <span class="n">dsm</span><span class="o">=</span><span class="n">dsm</span><span class="p">,</span>
                    <span class="n">transect_file</span><span class="o">=</span><span class="n">transect_file</span><span class="p">,</span>
                    <span class="n">tr_ids</span><span class="o">=</span><span class="n">tr_ids</span><span class="p">,</span>
                    <span class="n">transect_index</span><span class="o">=</span><span class="n">i</span><span class="p">,</span>
                    <span class="n">step</span><span class="o">=</span><span class="n">sampling_step</span><span class="p">,</span>
                    <span class="n">location</span><span class="o">=</span><span class="n">location</span><span class="p">,</span>
                    <span class="n">date_string</span><span class="o">=</span><span class="n">date_string</span><span class="p">,</span>
                    <span class="n">add_xy</span><span class="o">=</span><span class="n">add_xy</span><span class="p">,</span>
                    <span class="n">add_terrain</span><span class="o">=</span><span class="n">slope</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;ortho&quot;</span><span class="p">:</span>
                <span class="n">temp</span> <span class="o">=</span> <span class="n">get_profile_dn</span><span class="p">(</span>
                    <span class="n">ortho</span><span class="o">=</span><span class="n">dsm</span><span class="p">,</span>
                    <span class="n">transect_file</span><span class="o">=</span><span class="n">transect_file</span><span class="p">,</span>
                    <span class="n">transect_index</span><span class="o">=</span><span class="n">i</span><span class="p">,</span>
                    <span class="n">step</span><span class="o">=</span><span class="n">sampling_step</span><span class="p">,</span>
                    <span class="n">location</span><span class="o">=</span><span class="n">location</span><span class="p">,</span>
                    <span class="n">tr_ids</span><span class="o">=</span><span class="n">tr_ids</span><span class="p">,</span>
                    <span class="n">date_string</span><span class="o">=</span><span class="n">date_string</span><span class="p">,</span>
                    <span class="n">add_xy</span><span class="o">=</span><span class="n">add_xy</span><span class="p">,</span>
                <span class="p">)</span>

            <span class="n">gdf</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">temp</span><span class="p">,</span> <span class="n">gdf</span><span class="p">],</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">if</span> <span class="n">counter</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">list_files</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Extraction successful&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;There is something wrong with this dataset: </span><span class="si">{</span><span class="n">list_files</span><span class="p">[</span><span class="n">counter</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">end</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">timepassed</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span>

    <span class="nb">print</span><span class="p">(</span>
        <span class="sa">f</span><span class="s2">&quot;Number of points extracted:</span><span class="si">{</span><span class="n">gdf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="se">\n</span><span class="s2">Time for processing=</span><span class="si">{</span><span class="n">timepassed</span><span class="si">}</span><span class="s2"> seconds</span><span class="se">\n</span><span class="s2">First 10 rows are printed below&quot;</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;dsm&quot;</span><span class="p">:</span>
        <span class="n">nan_out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">gdf</span><span class="o">.</span><span class="n">z</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;f&quot;</span><span class="p">)))</span>
        <span class="n">nan_raster</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">gdf</span><span class="o">.</span><span class="n">z</span> <span class="o">==</span> <span class="n">nan_values</span><span class="p">)</span>
        <span class="n">gdf</span><span class="o">.</span><span class="n">z</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="o">-</span><span class="mi">10000</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;ortho&quot;</span><span class="p">:</span>
        <span class="n">nan_out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">gdf</span><span class="p">[[</span><span class="s2">&quot;band1&quot;</span><span class="p">,</span> <span class="s2">&quot;band2&quot;</span><span class="p">,</span> <span class="s2">&quot;band3&quot;</span><span class="p">]])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;f&quot;</span><span class="p">))</span>
        <span class="p">)</span>
        <span class="n">nan_raster</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">gdf</span><span class="o">.</span><span class="n">band1</span> <span class="o">==</span> <span class="n">nan_values</span><span class="p">)</span>
        <span class="n">gdf</span><span class="o">.</span><span class="n">band1</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">gdf</span><span class="o">.</span><span class="n">band2</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">gdf</span><span class="o">.</span><span class="n">band3</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span>
        <span class="sa">f</span><span class="s2">&quot;Number of points outside the raster extents: </span><span class="si">{</span><span class="n">nan_out</span><span class="si">}</span><span class="se">\n</span><span class="s2">The extraction assigns NaN.&quot;</span>
    <span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span>
        <span class="sa">f</span><span class="s2">&quot;Number of points in NoData areas within the raster extents: </span><span class="si">{</span><span class="n">nan_raster</span><span class="si">}</span><span class="se">\n</span><span class="s2">The extraction assigns NaN.&quot;</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">gdf</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 class="doc doc-heading" id="sandpyper.common.extract_loc_date">
<code class="highlight language-python"><span class="n">extract_loc_date</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">loc_search_dict</span><span class="p">,</span> <span class="n">split_by</span><span class="o">=</span><span class="s1">&#39;_&#39;</span><span class="p">)</span></code>


<a class="headerlink" href="#sandpyper.common.extract_loc_date" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Get the location code (e.g. wbl, por) and raw dates (e.g. 20180902) from filenames using the search dictionary.
If no location is found using exact matches, a fuzzy word match is implemented, searching closest matches
between locations in filenames and search candidates provided in the loc_search_dict dictionary.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>name</code></td>
        <td><code>str</code></td>
        <td><p>full filenames of the tipy 'C:\jupyter\data_in_gcp\20180601_mar_gcps.csv').</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>loc_search_dict</code></td>
        <td><code>dict</code></td>
        <td><p>a dictionary where keys are the location codes and values are lists containing the expected full location string (["Warrnambool", "warrnambool","warrny"]).</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>split_by</code></td>
        <td><code>str</code></td>
        <td><p>the character used to split the name (default= '_').</p></td>
        <td><code>&#39;_&#39;</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>(&#39;location&#39;,raw_date) </code></td>
      <td><p>tuple with location and raw date.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>sandpyper\common.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">extract_loc_date</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">loc_search_dict</span><span class="p">,</span> <span class="n">split_by</span><span class="o">=</span><span class="s2">&quot;_&quot;</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Get the location code (e.g. wbl, por) and raw dates (e.g. 20180902) from filenames using the search dictionary.</span>
<span class="sd">    If no location is found using exact matches, a fuzzy word match is implemented, searching closest matches</span>
<span class="sd">    between locations in filenames and search candidates provided in the loc_search_dict dictionary.</span>

<span class="sd">    Args:</span>

<span class="sd">        name (str): full filenames of the tipy &#39;C:\\jupyter\\data_in_gcp\\20180601_mar_gcps.csv&#39;).</span>
<span class="sd">        loc_search_dict (dict): a dictionary where keys are the location codes and values are lists containing the expected full location string ([&quot;Warrnambool&quot;, &quot;warrnambool&quot;,&quot;warrny&quot;]).</span>
<span class="sd">        split_by (str): the character used to split the name (default= &#39;_&#39;).</span>

<span class="sd">    Returns:</span>

<span class="sd">        (&#39;location&#39;,raw_date) : tuple with location and raw date.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">try</span><span class="p">:</span>

        <span class="n">date</span><span class="o">=</span><span class="n">getDate</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

    <span class="k">except</span><span class="p">:</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Proceeding with automated regular expression match&quot;</span><span class="p">)</span>

        <span class="n">date</span><span class="o">=</span><span class="n">find_date_string</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Date found: </span><span class="si">{</span><span class="n">date</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>



    <span class="n">names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">((</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">name</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">split_by</span><span class="p">)))</span>

    <span class="n">locations_search_names</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">loc_search_dict</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
    <span class="n">locations_codes</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">loc_search_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

    <span class="k">for</span> <span class="n">loc_code</span><span class="p">,</span> <span class="n">raw_strings_loc</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">locations_codes</span><span class="p">,</span> <span class="n">locations_search_names</span><span class="p">):</span>  <span class="c1"># loop trhough all possible lists of raw strings</span>

        <span class="n">raw_str_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">raw_strings_loc</span><span class="p">)</span>

        <span class="n">match</span> <span class="o">=</span> <span class="n">raw_str_set</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">match</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>

            <span class="n">location_code_found</span> <span class="o">=</span> <span class="n">loc_code</span>

            <span class="k">break</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">location_code_found</span><span class="p">,</span> <span class="n">date</span><span class="p">)</span>

    <span class="k">except</span><span class="p">:</span>
        <span class="c1"># location not found. Let&#39;s implement fuzzy string match.</span>

        <span class="n">scores</span> <span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">search_loc</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">locations_search_names</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">search_loc</span><span class="p">:</span>
                <span class="n">score</span><span class="o">=</span><span class="n">fuzz</span><span class="o">.</span><span class="n">ratio</span><span class="p">(</span><span class="n">word</span><span class="p">,</span><span class="n">names</span><span class="p">)</span> <span class="c1"># how close is each candidate word to the list of names which contain the location?</span>
                <span class="n">scores</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">score</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">word</span><span class="p">])</span>

        <span class="n">scores_arr</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">scores</span><span class="p">)</span> <span class="c1"># just to safely use np.argmax on a specified dimension</span>

        <span class="n">max_score_idx</span><span class="o">=</span><span class="n">scores_arr</span><span class="p">[:,:</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># returns the index of the maximum score in scores array</span>
        <span class="n">closest_loc_code_idx</span><span class="o">=</span><span class="n">scores</span><span class="p">[</span><span class="n">max_score_idx</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># closest code found</span>

        <span class="n">closest_word</span><span class="o">=</span><span class="n">scores</span><span class="p">[</span><span class="n">max_score_idx</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">loc_code</span><span class="o">=</span><span class="n">locations_codes</span><span class="p">[</span><span class="n">closest_loc_code_idx</span><span class="p">]</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Location not understood in </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">.</span><span class="se">\n\</span>
<span class="s2">        Fuzzy word matching found </span><span class="si">{</span><span class="n">closest_word</span><span class="si">}</span><span class="s2">, which corresponds to location code: </span><span class="si">{</span><span class="n">loc_code</span><span class="si">}</span><span class="s2"> &quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">loc_code</span><span class="p">,</span> <span class="n">date</span><span class="p">)</span>
</code></pre></div>
        </details>
    </div>

  </div>




  <div class="doc doc-object doc-function">



<h2 class="doc doc-heading" id="sandpyper.common.filepath_raster_type">
<code class="highlight language-python"><span class="n">filepath_raster_type</span><span class="p">(</span><span class="n">raster_path</span><span class="p">)</span></code>


<a class="headerlink" href="#sandpyper.common.filepath_raster_type" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Returns 'dsm' if the path provided (raster_path) is of a DSM (1 single band) or 'ortho' if has multiple bands.</p>

        <details class="quote">
          <summary>Source code in <code>sandpyper\common.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">filepath_raster_type</span><span class="p">(</span><span class="n">raster_path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns &#39;dsm&#39; if the path provided (raster_path) is of a DSM (1 single band) or &#39;ortho&#39; if has multiple bands.&quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="n">ras</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">raster_path</span><span class="p">))</span> <span class="k">as</span> <span class="n">raster</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">raster</span><span class="o">.</span><span class="n">count</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&quot;dsm&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&quot;ortho&quot;</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 class="doc doc-heading" id="sandpyper.common.fill_gaps">
<code class="highlight language-python"><span class="n">fill_gaps</span><span class="p">(</span><span class="n">data_in</span><span class="p">,</span> <span class="n">y_heat_bottom_limit</span><span class="p">,</span> <span class="n">spacing</span><span class="p">,</span> <span class="n">bottom</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">y_heat_start</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></code>


<a class="headerlink" href="#sandpyper.common.fill_gaps" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Function to fill the pivoted table (returned from prep_heatmap function) with missing across-shore distances, due to align data on heatmaps. Empty rows (NaN) will be added on top (from 0 to the first valid distance) and, optionally on the bottom of each transect, (from the last valid distance to a specified seaward limit).</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This function assume along-transect distances to be going from land to water, which is not what the profiles distances represent originally.</p>
</div>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>data_in</code></td>
        <td><code>pd.DataFrame</code></td>
        <td><p>Pivoted dataframe, where each column is a transect and row is a along-shore distance.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>y_heat_bottom_limit</code></td>
        <td><code>int</code></td>
        <td><p>Lower boundary distance to extend all transects.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>bottom</code></td>
        <td><code>bool</code></td>
        <td><p>If True (default), rows are extended seaward too, up to y_heat_bottom_limit. If False, only distances from 0 to the first valid values will be added.</p></td>
        <td><code>True</code></td>
      </tr>
      <tr>
        <td><code>y_heat_start</code></td>
        <td><code>int</code></td>
        <td><p>Landward starting distance value (default=0)</p></td>
        <td><code>0</code></td>
      </tr>
      <tr>
        <td><code>spacing</code></td>
        <td><code>float</code></td>
        <td><p>Sampling step (meters) used to extract points (default=0.1)</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>complete_df (pd.DataFrame)</code></td>
      <td><p>Complete dataframe with extra rows of NaN added.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>sandpyper\common.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">fill_gaps</span><span class="p">(</span><span class="n">data_in</span><span class="p">,</span> <span class="n">y_heat_bottom_limit</span><span class="p">,</span> <span class="n">spacing</span><span class="p">,</span> <span class="n">bottom</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">y_heat_start</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Function to fill the pivoted table (returned from prep_heatmap function) with missing across-shore distances, due to align data on heatmaps. Empty rows (NaN) will be added on top (from 0 to the first valid distance) and, optionally on the bottom of each transect, (from the last valid distance to a specified seaward limit).</span>

<span class="sd">    Warning:</span>
<span class="sd">        This function assume along-transect distances to be going from land to water, which is not what the profiles distances represent originally.</span>

<span class="sd">    Args:</span>
<span class="sd">        data_in (pd.DataFrame): Pivoted dataframe, where each column is a transect and row is a along-shore distance.</span>
<span class="sd">        y_heat_bottom_limit (int): Lower boundary distance to extend all transects.</span>
<span class="sd">        bottom (bool): If True (default), rows are extended seaward too, up to y_heat_bottom_limit. If False, only distances from 0 to the first valid values will be added.</span>
<span class="sd">        y_heat_start (int): Landward starting distance value (default=0)</span>
<span class="sd">        spacing (float): Sampling step (meters) used to extract points (default=0.1)</span>

<span class="sd">    Returns:</span>
<span class="sd">        complete_df (pd.DataFrame): Complete dataframe with extra rows of NaN added.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">y_heat_bottom_limit</span> <span class="o">&lt;</span> <span class="n">data_in</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;y_heat_bottom_limit (</span><span class="si">{</span><span class="n">y_heat_bottom_limit</span><span class="si">}</span><span class="s2">) cannot be lower than the maximum distance already present in the data (</span><span class="si">{</span><span class="n">data_in</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">).&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">bool</span><span class="p">(</span><span class="n">bottom</span><span class="p">):</span>
        <span class="n">bottom_fill_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span>
            <span class="p">(</span>
                <span class="p">(</span>
                    <span class="nb">int</span><span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">y_heat_bottom_limit</span> <span class="o">+</span> <span class="n">spacing</span> <span class="o">-</span> <span class="n">data_in</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="p">)</span>
                <span class="p">),</span>
                <span class="n">data_in</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="n">bottom_fill_array</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span>
        <span class="n">to_concat_after</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">bottom_fill_array</span><span class="p">,</span>
            <span class="n">index</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">data_in</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">y_heat_bottom_limit</span> <span class="o">+</span> <span class="n">spacing</span><span class="p">,</span> <span class="n">spacing</span><span class="p">),</span>
            <span class="n">columns</span><span class="o">=</span><span class="n">data_in</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="n">before_fill_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">int</span><span class="p">(</span><span class="n">data_in</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">data_in</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
    <span class="n">before_fill_array</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span>
    <span class="n">to_concat_before</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
        <span class="n">data</span><span class="o">=</span><span class="n">before_fill_array</span><span class="p">,</span>
        <span class="n">index</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">y_heat_start</span><span class="p">,</span> <span class="n">data_in</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">spacing</span><span class="p">),</span>
        <span class="n">columns</span><span class="o">=</span><span class="n">data_in</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="nb">bool</span><span class="p">(</span><span class="n">bottom</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">to_concat_before</span><span class="p">,</span> <span class="n">data_in</span><span class="p">,</span> <span class="n">to_concat_after</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">1</span><span class="p">:]])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">to_concat_before</span><span class="p">,</span> <span class="n">data_in</span><span class="p">])</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 class="doc doc-heading" id="sandpyper.common.filter_filename_list">
<code class="highlight language-python"><span class="n">filter_filename_list</span><span class="p">(</span><span class="n">filenames_list</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;.tif&#39;</span><span class="p">,</span> <span class="s1">&#39;.tiff&#39;</span><span class="p">])</span></code>


<a class="headerlink" href="#sandpyper.common.filter_filename_list" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>It returns a list of only specific file formats from a list of filenames.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>filenames_list</code></td>
        <td><code>list</code></td>
        <td><p>list of filenames.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>fmt</code></td>
        <td><code>list</code></td>
        <td><p>list of formats to be filtered (DEFAULT = [".tif",".tiff"])</p></td>
        <td><code>[&#39;.tif&#39;, &#39;.tiff&#39;]</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>filtered_list (list)</code></td>
      <td><p>A filtered list of filenames.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>sandpyper\common.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">filter_filename_list</span><span class="p">(</span><span class="n">filenames_list</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;.tif&quot;</span><span class="p">,</span> <span class="s2">&quot;.tiff&quot;</span><span class="p">]):</span>
    <span class="sd">&quot;&quot;&quot;It returns a list of only specific file formats from a list of filenames.</span>

<span class="sd">    Args:</span>
<span class="sd">        filenames_list (list): list of filenames.</span>
<span class="sd">        fmt (list): list of formats to be filtered (DEFAULT = [&quot;.tif&quot;,&quot;.tiff&quot;])</span>

<span class="sd">    Returns:</span>
<span class="sd">        filtered_list (list): A filtered list of filenames.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">name</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">filenames_list</span> <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">name</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">fmt</span><span class="p">]</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 class="doc doc-heading" id="sandpyper.common.find_date_string">
<code class="highlight language-python"><span class="n">find_date_string</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">list_months</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;jan&#39;</span><span class="p">,</span> <span class="s1">&#39;feb&#39;</span><span class="p">,</span> <span class="s1">&#39;mar&#39;</span><span class="p">,</span> <span class="s1">&#39;apr&#39;</span><span class="p">,</span> <span class="s1">&#39;may&#39;</span><span class="p">,</span> <span class="s1">&#39;jun&#39;</span><span class="p">,</span> <span class="s1">&#39;jul&#39;</span><span class="p">,</span> <span class="s1">&#39;aug&#39;</span><span class="p">,</span> <span class="s1">&#39;sept&#39;</span><span class="p">,</span> <span class="s1">&#39;oct&#39;</span><span class="p">,</span> <span class="s1">&#39;nov&#39;</span><span class="p">,</span> <span class="s1">&#39;dec&#39;</span><span class="p">],</span> <span class="n">to_rawdate</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></code>


<a class="headerlink" href="#sandpyper.common.find_date_string" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>It finds the date in the filename and returns True if it is already in the Sandpyper format. If it is not formatted and a date is found, it returns a formatted version of it. For example, dates in raw filenames should be similar to "Seaspray_22_Oct_2020_GeoTIFF_DSM_GDA94_MGA_zone_55.tiff".</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>filename</code></td>
        <td><code>str</code></td>
        <td><p>filename to test, of the type "Seaspray_22_Oct_2020_GeoTIFF_DSM_GDA94_MGA_zone_55.tiff".</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>list_months</code></td>
        <td><code>list</code></td>
        <td><p>expected denominations for the months. Default to ['jan','feb','mar',...,'dec'].</p></td>
        <td><code>[&#39;jan&#39;, &#39;feb&#39;, &#39;mar&#39;, &#39;apr&#39;, &#39;may&#39;, &#39;jun&#39;, &#39;jul&#39;, &#39;aug&#39;, &#39;sept&#39;, &#39;oct&#39;, &#39;nov&#39;, &#39;dec&#39;]</code></td>
      </tr>
      <tr>
        <td><code>to_rawdate</code></td>
        <td><code>bool</code></td>
        <td><p>True to format the found date into raw_date (20201022). False, return True if the date is found or False if not.</p></td>
        <td><code>True</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>bool (bool, str)</code></td>
      <td><p>True if it was already formatted or a new string formatted correctly.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>sandpyper\common.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">find_date_string</span><span class="p">(</span>
    <span class="n">filename</span><span class="p">,</span>
    <span class="n">list_months</span><span class="o">=</span><span class="p">[</span>
        <span class="s2">&quot;jan&quot;</span><span class="p">,</span>
        <span class="s2">&quot;feb&quot;</span><span class="p">,</span>
        <span class="s2">&quot;mar&quot;</span><span class="p">,</span>
        <span class="s2">&quot;apr&quot;</span><span class="p">,</span>
        <span class="s2">&quot;may&quot;</span><span class="p">,</span>
        <span class="s2">&quot;jun&quot;</span><span class="p">,</span>
        <span class="s2">&quot;jul&quot;</span><span class="p">,</span>
        <span class="s2">&quot;aug&quot;</span><span class="p">,</span>
        <span class="s2">&quot;sept&quot;</span><span class="p">,</span>
        <span class="s2">&quot;oct&quot;</span><span class="p">,</span>
        <span class="s2">&quot;nov&quot;</span><span class="p">,</span>
        <span class="s2">&quot;dec&quot;</span><span class="p">,</span>
    <span class="p">],</span>
    <span class="n">to_rawdate</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;It finds the date in the filename and returns True if it is already in the Sandpyper format. If it is not formatted and a date is found, it returns a formatted version of it. For example, dates in raw filenames should be similar to &quot;Seaspray_22_Oct_2020_GeoTIFF_DSM_GDA94_MGA_zone_55.tiff&quot;.</span>

<span class="sd">    Args:</span>
<span class="sd">        filename (str): filename to test, of the type &quot;Seaspray_22_Oct_2020_GeoTIFF_DSM_GDA94_MGA_zone_55.tiff&quot;.</span>
<span class="sd">        list_months (list): expected denominations for the months. Default to [&#39;jan&#39;,&#39;feb&#39;,&#39;mar&#39;,...,&#39;dec&#39;].</span>
<span class="sd">        to_rawdate (bool): True to format the found date into raw_date (20201022). False, return True if the date is found or False if not.</span>

<span class="sd">    Returns:</span>
<span class="sd">        bool (bool, str): True if it was already formatted or a new string formatted correctly.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">re_list_months</span> <span class="o">=</span> <span class="s2">&quot;|&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">list_months</span><span class="p">)</span>
    <span class="n">regx</span> <span class="o">=</span> <span class="sa">rf</span><span class="s2">&quot;_\d</span><span class="se">{{</span><span class="s2">2</span><span class="se">}}</span><span class="s2">_(</span><span class="si">{</span><span class="n">re_list_months</span><span class="si">}</span><span class="s2">)_\d</span><span class="se">{{</span><span class="s2">4</span><span class="se">}}</span><span class="s2">_&quot;</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">group</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">regx</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">IGNORECASE</span><span class="p">)</span><span class="o">.</span><span class="n">group</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">to_rawdate</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">group_split</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)</span>
            <span class="n">dt</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">group_split</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}{</span><span class="n">group_split</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="si">}{</span><span class="n">group_split</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;</span><span class="si">%d</span><span class="s2">%b%Y&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">dt</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;%Y%m</span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 class="doc doc-heading" id="sandpyper.common.get_beachface_length">
<code class="highlight language-python"><span class="n">get_beachface_length</span><span class="p">(</span><span class="n">series</span><span class="p">)</span></code>


<a class="headerlink" href="#sandpyper.common.get_beachface_length" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Get across-shore beachface length from series of elevation change with distance as indices.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>series</code></td>
        <td><code>pd.Series</code></td>
        <td><p>series of elevation change with distance as indices.</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>beachface_length (float)</code></td>
      <td><p>Across-shore beachface length in meters.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>sandpyper\common.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">get_beachface_length</span><span class="p">(</span><span class="n">series</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get across-shore beachface length from series of elevation change with distance as indices.</span>

<span class="sd">    Args:</span>
<span class="sd">        series (pd.Series): series of elevation change with distance as indices.</span>

<span class="sd">    Returns:</span>
<span class="sd">        beachface_length (float): Across-shore beachface length in meters.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">min_dist</span><span class="p">,</span> <span class="n">max_dist</span> <span class="o">=</span> <span class="n">series</span><span class="o">.</span><span class="n">first_valid_index</span><span class="p">(),</span> <span class="n">series</span><span class="o">.</span><span class="n">last_valid_index</span><span class="p">()</span>

    <span class="n">across_shore_beachface_length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">max_dist</span> <span class="o">-</span> <span class="n">min_dist</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">across_shore_beachface_length</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 class="doc doc-heading" id="sandpyper.common.get_coastal_Markov">
<code class="highlight language-python"><span class="n">get_coastal_Markov</span><span class="p">(</span><span class="n">arr_markov</span><span class="p">,</span> <span class="n">weights_dict</span><span class="p">,</span> <span class="n">store_neg</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></code>


<a class="headerlink" href="#sandpyper.common.get_coastal_Markov" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Compute BCDs from first-order transition matrices of dh magnitude classes (as states).</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>arr_markov</code></td>
        <td><code>np.array</code></td>
        <td><p>Numpy array of markov transition matrix.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>weights_dict</code></td>
        <td><code>dict</code></td>
        <td><p>Dictionary with keys:dh classes, values: weight (int). Especially useful for the e-BCDs magnitude trend (sign).</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>store_neg</code></td>
        <td><code>bool</code></td>
        <td><p>If True (default), use the subtraction for diminishing trends.</p></td>
        <td><code>True</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>(tuple)</code></td>
      <td><p>Tuple containing:
    BCD(float) the actual BCD indices
    trend(float) value of the indices trend
    sign(str) can be '-' or '+' for plotting purposes.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>sandpyper\common.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">get_coastal_Markov</span><span class="p">(</span><span class="n">arr_markov</span><span class="p">,</span> <span class="n">weights_dict</span><span class="p">,</span> <span class="n">store_neg</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute BCDs from first-order transition matrices of dh magnitude classes (as states).</span>

<span class="sd">    Args:</span>
<span class="sd">        arr_markov (np.array): Numpy array of markov transition matrix.</span>
<span class="sd">        weights_dict (dict): Dictionary with keys:dh classes, values: weight (int). Especially useful for the e-BCDs magnitude trend (sign).</span>
<span class="sd">        store_neg (bool): If True (default), use the subtraction for diminishing trends.</span>

<span class="sd">    Returns:</span>
<span class="sd">        (tuple): Tuple containing:</span>
<span class="sd">            BCD(float) the actual BCD indices</span>
<span class="sd">            trend(float) value of the indices trend</span>
<span class="sd">            sign(str) can be &#39;-&#39; or &#39;+&#39; for plotting purposes.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">combs</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">product</span><span class="p">(</span><span class="n">arr_markov</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="p">(</span><span class="n">arr_markov</span><span class="o">.</span><span class="n">columns</span><span class="p">)))</span>

    <span class="n">value_trans</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">value_trend</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="n">state1</span><span class="p">,</span> <span class="n">state2</span> <span class="ow">in</span> <span class="n">combs</span><span class="p">:</span>

        <span class="n">state_1_w</span> <span class="o">=</span> <span class="n">weights_dict</span><span class="p">[</span><span class="n">state1</span><span class="p">]</span>  <span class="c1"># extract the weights</span>
        <span class="n">state_2_w</span> <span class="o">=</span> <span class="n">weights_dict</span><span class="p">[</span><span class="n">state2</span><span class="p">]</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">arr_markov</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">state1</span><span class="p">,</span> <span class="n">state2</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">state_1_w</span> <span class="o">&gt;</span> <span class="n">state_2_w</span><span class="p">:</span>  <span class="c1"># check if the change is decr</span>

            <span class="k">if</span> <span class="nb">bool</span><span class="p">(</span><span class="n">store_neg</span><span class="p">):</span>
                <span class="n">weigth_adhoc_trend</span> <span class="o">=</span> <span class="n">state_1_w</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">state_2_w</span><span class="p">))</span>

            <span class="n">value_trans</span> <span class="o">+=</span> <span class="n">value</span>
            <span class="n">value_trend</span> <span class="o">+=</span> <span class="n">value</span> <span class="o">*</span> <span class="n">weigth_adhoc_trend</span>

        <span class="k">elif</span> <span class="n">state_1_w</span> <span class="o">&lt;</span> <span class="n">state_2_w</span><span class="p">:</span>
            <span class="n">weigth_adhoc_trend</span> <span class="o">=</span> <span class="n">state_1_w</span> <span class="o">*</span> <span class="n">state_2_w</span>

            <span class="n">value_trans</span> <span class="o">+=</span> <span class="n">value</span>
            <span class="n">value_trend</span> <span class="o">+=</span> <span class="n">value</span> <span class="o">*</span> <span class="n">weigth_adhoc_trend</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">weigth_adhoc_trend</span> <span class="o">=</span> <span class="n">state_1_w</span> <span class="o">*</span> <span class="n">state_2_w</span>

            <span class="n">value_trans</span> <span class="o">+=</span> <span class="n">value</span>
            <span class="n">value_trend</span> <span class="o">+=</span> <span class="n">value</span> <span class="o">*</span> <span class="n">weigth_adhoc_trend</span>

    <span class="k">if</span> <span class="n">value_trend</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">sign</span> <span class="o">=</span> <span class="s2">&quot;+&quot;</span>
    <span class="k">elif</span> <span class="n">value_trend</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">sign</span> <span class="o">=</span> <span class="s2">&quot;-&quot;</span>
    <span class="k">elif</span> <span class="n">value_trend</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">sign</span> <span class="o">=</span> <span class="s2">&quot;0&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">sign</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">value_trans</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">value_trend</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">sign</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 class="doc doc-heading" id="sandpyper.common.get_dn">
<code class="highlight language-python"><span class="n">get_dn</span><span class="p">(</span><span class="n">x_coord</span><span class="p">,</span> <span class="n">y_coord</span><span class="p">,</span> <span class="n">raster</span><span class="p">,</span> <span class="n">bands</span><span class="p">,</span> <span class="n">transform</span><span class="p">)</span></code>


<a class="headerlink" href="#sandpyper.common.get_dn" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Returns the value of the raster at a specified location and band.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>x_coord</code></td>
        <td><code>float</code></td>
        <td><p>Projected X coordinates of pixel to extract value.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>y_coord</code></td>
        <td><code>float</code></td>
        <td><p>Projected Y coordinates of pixel to extract value.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>raster</code></td>
        <td><code>rasterio open file</code></td>
        <td><p>Open raster object, from rasterio.open(raster_filepath).</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>bands</code></td>
        <td><code>int</code></td>
        <td><p>number of bands.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>transform</code></td>
        <td><code>Shapely Affine obj</code></td>
        <td><p>Geotransform of the raster.</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>px (int, float)</code></td>
      <td><p>raster pixel value.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>sandpyper\common.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">get_dn</span><span class="p">(</span><span class="n">x_coord</span><span class="p">,</span> <span class="n">y_coord</span><span class="p">,</span> <span class="n">raster</span><span class="p">,</span> <span class="n">bands</span><span class="p">,</span> <span class="n">transform</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns the value of the raster at a specified location and band.</span>

<span class="sd">    args:</span>
<span class="sd">        x_coord (float): Projected X coordinates of pixel to extract value.</span>
<span class="sd">        y_coord (float): Projected Y coordinates of pixel to extract value.</span>
<span class="sd">        raster (rasterio open file): Open raster object, from rasterio.open(raster_filepath).</span>
<span class="sd">        bands (int): number of bands.</span>
<span class="sd">        transform (Shapely Affine obj): Geotransform of the raster.</span>

<span class="sd">    returns:</span>
<span class="sd">        px (int, float): raster pixel value.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Let&#39;s create an empty list where we will store the elevation (z) from points</span>
    <span class="c1"># With GDAL, we extract 4 components of the geotransform (gt) of our north-up image.</span>

    <span class="n">dn_val</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">row</span><span class="p">,</span> <span class="n">col</span> <span class="o">=</span> <span class="n">rowcol</span><span class="p">(</span><span class="n">transform</span><span class="p">,</span> <span class="n">x_coord</span><span class="p">,</span> <span class="n">y_coord</span><span class="p">,</span> <span class="nb">round</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">):</span>  <span class="c1"># we could iterate thru multiple bands</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">raster</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">Window</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">dn_val</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">except</span> <span class="ne">BaseException</span><span class="p">:</span>
            <span class="n">dn_val</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dn_val</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 class="doc doc-heading" id="sandpyper.common.get_elevation">
<code class="highlight language-python"><span class="n">get_elevation</span><span class="p">(</span><span class="n">x_coord</span><span class="p">,</span> <span class="n">y_coord</span><span class="p">,</span> <span class="n">raster</span><span class="p">,</span> <span class="n">bands</span><span class="p">,</span> <span class="n">transform</span><span class="p">)</span></code>


<a class="headerlink" href="#sandpyper.common.get_elevation" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Returns the value of the raster at a specified location and band.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>x_coord</code></td>
        <td><code>float</code></td>
        <td><p>Projected X coordinates of pixel to extract value.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>y_coord</code></td>
        <td><code>float</code></td>
        <td><p>Projected Y coordinates of pixel to extract value.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>raster</code></td>
        <td><code>rasterio open file</code></td>
        <td><p>Open raster object, from rasterio.open(raster_filepath).</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>bands</code></td>
        <td><code>int</code></td>
        <td><p>number of bands.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>transform</code></td>
        <td><code>Shapely Affine obj</code></td>
        <td><p>Geotransform of the raster.</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>px (int,float)</code></td>
      <td><p>raster pixel value.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>sandpyper\common.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">get_elevation</span><span class="p">(</span><span class="n">x_coord</span><span class="p">,</span> <span class="n">y_coord</span><span class="p">,</span> <span class="n">raster</span><span class="p">,</span> <span class="n">bands</span><span class="p">,</span> <span class="n">transform</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the value of the raster at a specified location and band.</span>

<span class="sd">    Args:</span>
<span class="sd">        x_coord (float): Projected X coordinates of pixel to extract value.</span>
<span class="sd">        y_coord (float): Projected Y coordinates of pixel to extract value.</span>
<span class="sd">        raster (rasterio open file): Open raster object, from rasterio.open(raster_filepath).</span>
<span class="sd">        bands (int): number of bands.</span>
<span class="sd">        transform (Shapely Affine obj): Geotransform of the raster.</span>
<span class="sd">    Returns:</span>
<span class="sd">        px (int,float): raster pixel value.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">elevation</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">row</span><span class="p">,</span> <span class="n">col</span> <span class="o">=</span> <span class="n">rowcol</span><span class="p">(</span><span class="n">transform</span><span class="p">,</span> <span class="n">x_coord</span><span class="p">,</span> <span class="n">y_coord</span><span class="p">,</span> <span class="nb">round</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">bands</span><span class="p">):</span>  <span class="c1"># we could iterate thru multiple bands</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">data_z</span> <span class="o">=</span> <span class="n">raster</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">Window</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">elevation</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data_z</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">except</span> <span class="ne">BaseException</span><span class="p">:</span>
            <span class="n">elevation</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">elevation</span>
</code></pre></div>
        </details>
    </div>

  </div>




  <div class="doc doc-object doc-function">



<h2 class="doc doc-heading" id="sandpyper.common.get_m3_m_location">
<code class="highlight language-python"><span class="n">get_m3_m_location</span><span class="p">(</span><span class="n">data_in</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="n">transect_spacing</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span></code>


<a class="headerlink" href="#sandpyper.common.get_m3_m_location" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Get alongshore-shore net volumetric change in cubic meters per meter of beach.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>data_in</code></td>
        <td><code>pd.Dataframe</code></td>
        <td><p>Dataframe generated by prep_heatmap function.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>transect_spacing</code></td>
        <td><code>int,float</code></td>
        <td><p>Spacing between transects in meters.</p></td>
        <td><code>20</code></td>
      </tr>
      <tr>
        <td><code>dx</code></td>
        <td><code>int,float</code></td>
        <td><p>The along-transect point spacing</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>m3_m (float)</code></td>
      <td><p>Cubic meters of change per meter of beach alongshore, at the site level.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>sandpyper\common.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">get_m3_m_location</span><span class="p">(</span><span class="n">data_in</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="n">transect_spacing</span><span class="o">=</span><span class="mi">20</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get alongshore-shore net volumetric change in cubic meters per meter of beach.</span>

<span class="sd">    Args:</span>
<span class="sd">        data_in (pd.Dataframe): Dataframe generated by prep_heatmap function.</span>
<span class="sd">        transect_spacing (int,float): Spacing between transects in meters.</span>
<span class="sd">        dx (int,float): The along-transect point spacing</span>
<span class="sd">    Returns:</span>
<span class="sd">        m3_m (float): Cubic meters of change per meter of beach alongshore, at the site level.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># compute alongshore beachface length</span>
    <span class="n">along_beach</span> <span class="o">=</span> <span class="n">data_in</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">transect_spacing</span>

    <span class="n">tot_vol</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span>
        <span class="p">(</span><span class="n">data_in</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">interpol_integrate</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">**</span><span class="p">{</span><span class="s1">&#39;dx&#39;</span><span class="p">:</span><span class="n">dx</span><span class="p">}))</span> <span class="o">*</span> <span class="n">transect_spacing</span>
    <span class="p">)</span>  <span class="c1"># compute net volume change</span>

    <span class="k">return</span> <span class="n">tot_vol</span> <span class="o">/</span> <span class="n">along_beach</span>  <span class="c1"># return m3_m alongshore</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 class="doc doc-heading" id="sandpyper.common.get_opt_k">
<code class="highlight language-python"><span class="n">get_opt_k</span><span class="p">(</span><span class="n">sil_df</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></code>


<a class="headerlink" href="#sandpyper.common.get_opt_k" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Function to create a dictionary with optimal number of clusters (k) for all surveys.
It search for the inflexion points where an additional cluster does not degrade the overall clustering performance.
It uses a Gaussian smoothed regression of k against mean silhouette scores to identify relative minima (first order)
as possible inlfexion values.
When multiple relative minimas are found, the smaller k will be the optimal one.
When no relative minima are found, it searches for peaks in the second order derivative of such regression line.
If multiple peaks are found, the mean k, computed so far, will be used as optimal.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>sil_df</code></td>
        <td><code>Pandas dataframe</code></td>
        <td><p>Dataframe containing the mean silhouette score per k in each survey.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>sigma</code></td>
        <td><code>int</code></td>
        <td><p>Number of standard deviations to use in the Gaussian filter. Default is 1.</p></td>
        <td><code>1</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>opt_k (dict)</code></td>
      <td><p>Dictionary with optimal k for each survey.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>sandpyper\common.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">get_opt_k</span><span class="p">(</span><span class="n">sil_df</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function to create a dictionary with optimal number of clusters (k) for all surveys.</span>
<span class="sd">    It search for the inflexion points where an additional cluster does not degrade the overall clustering performance.</span>
<span class="sd">    It uses a Gaussian smoothed regression of k against mean silhouette scores to identify relative minima (first order)</span>
<span class="sd">    as possible inlfexion values.</span>
<span class="sd">    When multiple relative minimas are found, the smaller k will be the optimal one.</span>
<span class="sd">    When no relative minima are found, it searches for peaks in the second order derivative of such regression line.</span>
<span class="sd">    If multiple peaks are found, the mean k, computed so far, will be used as optimal.</span>


<span class="sd">    Args:</span>
<span class="sd">        sil_df (Pandas dataframe): Dataframe containing the mean silhouette score per k in each survey.</span>
<span class="sd">        sigma (int): Number of standard deviations to use in the Gaussian filter. Default is 1.</span>
<span class="sd">    Returns:</span>
<span class="sd">        opt_k (dict): Dictionary with optimal k for each survey.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">si_arr</span> <span class="o">=</span> <span class="n">sil_df</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s2">&quot;location&quot;</span><span class="p">,</span> <span class="s2">&quot;raw_date&quot;</span><span class="p">])[</span><span class="s2">&quot;silhouette_mean&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">array</span>
    <span class="p">)</span>
    <span class="n">k_arr</span> <span class="o">=</span> <span class="n">sil_df</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s2">&quot;location&quot;</span><span class="p">,</span> <span class="s2">&quot;raw_date&quot;</span><span class="p">])[</span><span class="s2">&quot;k&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">)</span>

    <span class="n">dict_data</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;k_numbers&quot;</span><span class="p">:</span> <span class="n">k_arr</span><span class="p">,</span> <span class="s2">&quot;silhouette_mean&quot;</span><span class="p">:</span> <span class="n">si_arr</span><span class="p">}</span>
    <span class="n">sil_group_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">dict_data</span><span class="p">)</span>
    <span class="n">sil_group_df</span> <span class="o">=</span> <span class="n">sil_group_df</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>

    <span class="n">opt_k</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">sil_group_df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>

        <span class="n">location</span> <span class="o">=</span> <span class="n">sil_group_df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">location</span>
        <span class="n">survey_date_in</span> <span class="o">=</span> <span class="n">sil_group_df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">raw_date</span>
        <span class="n">sub</span> <span class="o">=</span> <span class="n">sil_group_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;k_numbers&quot;</span><span class="p">,</span> <span class="s2">&quot;silhouette_mean&quot;</span><span class="p">]]</span>

        <span class="c1"># Passing a gaussian filter to smooth the curve for 1 std sigma</span>
        <span class="n">gauss</span> <span class="o">=</span> <span class="n">gaussian_filter</span><span class="p">(</span><span class="n">sub</span><span class="o">.</span><span class="n">silhouette_mean</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">)</span>

        <span class="c1"># obtaining relative minima for the smoothed line (gauss)</span>
        <span class="n">mina</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">argrelmin</span><span class="p">(</span><span class="n">gauss</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;clip&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mina</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># if no relative minima are found, compute the second order accurate central differences in the interior points</span>
            <span class="c1"># as optimal k</span>

            <span class="n">der</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">gauss</span><span class="p">)</span>
            <span class="n">peak</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">find_peaks</span><span class="p">(</span><span class="n">der</span><span class="p">)</span>

            <span class="k">if</span> <span class="p">(</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">peak</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span>
            <span class="p">):</span>  <span class="c1"># if multiple plateau values are found, obtain the mean k of those values</span>

                <span class="n">peak</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">peak</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="o">+</span> <span class="mi">2</span>
                <span class="c1"># +2: the peaks of mina values are 0-based index. As k started at 2, adding 2 returns k instead of index</span>
                <span class="n">opt_k</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">location</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">survey_date_in</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">peak</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">opt_k</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">location</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">survey_date_in</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">peak</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span>

        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">mina</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>

            <span class="n">opt_k</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">location</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">survey_date_in</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mina</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># if multiple relative minimas are found, use the first one as optimal k</span>
            <span class="n">opt_k</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">location</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">survey_date_in</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mina</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span>

    <span class="k">return</span> <span class="n">opt_k</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 class="doc doc-heading" id="sandpyper.common.get_profile_dn">
<code class="highlight language-python"><span class="n">get_profile_dn</span><span class="p">(</span><span class="n">ortho</span><span class="p">,</span> <span class="n">transect_file</span><span class="p">,</span> <span class="n">transect_index</span><span class="p">,</span> <span class="n">tr_ids</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="n">location</span><span class="p">,</span> <span class="n">date_string</span><span class="p">,</span> <span class="n">add_xy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>


<a class="headerlink" href="#sandpyper.common.get_profile_dn" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Returns a tidy GeoDataFrame of profile data, extracting raster information at a user-defined (step) meters gap along each transect.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>ortho</code></td>
        <td><code>str</code></td>
        <td><p>path to the DSM raster.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>transect_file</code></td>
        <td><code>str</code></td>
        <td><p>path to the transect file.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>transect_index</code></td>
        <td><code>int</code></td>
        <td><p>index of the transect to extract information from.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>step</code></td>
        <td><code>int,float</code></td>
        <td><p>sampling distance from one point to another in meters along the transect.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>location</code></td>
        <td><code>str</code></td>
        <td><p>location code</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>date_string</code></td>
        <td><code>str</code></td>
        <td><p>raw format of the survey date (20180329)</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>add_xy</code></td>
        <td><code>bool</code></td>
        <td><p>True to add X and Y coordinates fields.</p></td>
        <td><code>False</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>gdf (gpd.GeoDataFrame) </code></td>
      <td><p>Profile data extracted from the raster.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>sandpyper\common.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">get_profile_dn</span><span class="p">(</span>
    <span class="n">ortho</span><span class="p">,</span> <span class="n">transect_file</span><span class="p">,</span>
    <span class="n">transect_index</span><span class="p">,</span> <span class="n">tr_ids</span><span class="p">,</span>
    <span class="n">step</span><span class="p">,</span> <span class="n">location</span><span class="p">,</span> <span class="n">date_string</span><span class="p">,</span> <span class="n">add_xy</span><span class="o">=</span><span class="kc">False</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns a tidy GeoDataFrame of profile data, extracting raster information at a user-defined (step) meters gap along each transect.</span>

<span class="sd">    Args:</span>
<span class="sd">        ortho (str): path to the DSM raster.</span>
<span class="sd">        transect_file (str): path to the transect file.</span>
<span class="sd">        transect_index (int): index of the transect to extract information from.</span>
<span class="sd">        step (int,float): sampling distance from one point to another in meters along the transect.</span>
<span class="sd">        location (str): location code</span>
<span class="sd">        date_string (str): raw format of the survey date (20180329)</span>
<span class="sd">        add_xy (bool): True to add X and Y coordinates fields.</span>

<span class="sd">    Returns:</span>
<span class="sd">        gdf (gpd.GeoDataFrame) : Profile data extracted from the raster.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">ds</span> <span class="o">=</span> <span class="n">ras</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">ortho</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span>

    <span class="n">bands</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">count</span>

    <span class="n">transform</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">transform</span>

    <span class="n">line</span> <span class="o">=</span> <span class="n">transect_file</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">transect_index</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">tr_ids</span><span class="o">==</span><span class="s1">&#39;reset&#39;</span><span class="p">:</span>
        <span class="n">line_id</span><span class="o">=</span><span class="n">line</span><span class="o">.</span><span class="n">name</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tr_ids</span><span class="p">,</span><span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">tr_ids</span> <span class="ow">in</span> <span class="n">line</span><span class="o">.</span><span class="n">index</span><span class="p">:</span>
        <span class="n">line_id</span><span class="o">=</span><span class="n">line</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">tr_ids</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&#39;tr_ids&#39; must be either &#39;reset&#39; or the name of an existing column o the transect files. &#39;</span><span class="si">{</span><span class="n">tr_ids</span><span class="si">}</span><span class="s2">&#39; was passed.&quot;</span><span class="p">)</span>


    <span class="n">length_m</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">length</span>

    <span class="n">x</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">y</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">dn</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">distance</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">currentdistance</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">length_m</span><span class="p">),</span> <span class="n">step</span><span class="p">):</span>
        <span class="c1"># creation of the point on the line</span>
        <span class="n">point</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">currentdistance</span><span class="p">)</span>
        <span class="n">xp</span><span class="p">,</span> <span class="n">yp</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">point</span><span class="o">.</span><span class="n">x</span><span class="p">,</span>
            <span class="n">point</span><span class="o">.</span><span class="n">y</span><span class="p">,</span>
        <span class="p">)</span>  <span class="c1"># storing point xy coordinates into xp,xy objects, respectively</span>
        <span class="n">x</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xp</span><span class="p">)</span>  <span class="c1"># see below</span>
        <span class="n">y</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="n">yp</span>
        <span class="p">)</span>  <span class="c1"># append point coordinates to previously created and empty x,y lists</span>
        <span class="n">dn</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">get_dn</span><span class="p">(</span><span class="n">xp</span><span class="p">,</span> <span class="n">yp</span><span class="p">,</span> <span class="n">ds</span><span class="p">,</span> <span class="n">bands</span><span class="p">,</span> <span class="n">transform</span><span class="p">))</span>

        <span class="n">distance</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">currentdistance</span><span class="p">)</span>

    <span class="n">dn1</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">((</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">dn</span><span class="p">))</span>
    <span class="n">dn2</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">((</span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">dn</span><span class="p">))</span>
    <span class="n">dn3</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">((</span><span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">dn</span><span class="p">))</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s2">&quot;distance&quot;</span><span class="p">:</span> <span class="n">distance</span><span class="p">,</span> <span class="s2">&quot;band1&quot;</span><span class="p">:</span> <span class="n">dn1</span><span class="p">,</span> <span class="s2">&quot;band2&quot;</span><span class="p">:</span> <span class="n">dn2</span><span class="p">,</span> <span class="s2">&quot;band3&quot;</span><span class="p">:</span> <span class="n">dn3</span><span class="p">})</span>
    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;coordinates&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;coordinates&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;coordinates&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">Point</span><span class="p">)</span>
    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;location&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">location</span>
    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;survey_date&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">date_string</span><span class="p">,</span> <span class="n">yearfirst</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">dayfirst</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;%Y%m</span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;raw_date&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">date_string</span>
    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;tr_id&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">line_id</span><span class="p">)</span>
    <span class="n">gdf_rgb</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">geometry</span><span class="o">=</span><span class="s2">&quot;coordinates&quot;</span><span class="p">)</span>

    <span class="c1"># Last touch, the proj4 info (coordinate reference system) is gathered with</span>
    <span class="c1"># Geopandas and applied to the newly created one.</span>
    <span class="n">gdf_rgb</span><span class="o">.</span><span class="n">crs</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">transect_file</span><span class="o">.</span><span class="n">crs</span><span class="p">)</span>

    <span class="c1"># Let&#39;s create unique IDs from the coordinates values, so that the Ids</span>
    <span class="c1"># follows the coordinates</span>
    <span class="n">gdf_rgb</span><span class="p">[</span><span class="s2">&quot;point_id&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">create_id</span><span class="p">(</span><span class="n">gdf_rgb</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">gdf_rgb</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="p">]</span>

    <span class="k">if</span> <span class="nb">bool</span><span class="p">(</span><span class="n">add_xy</span><span class="p">):</span>
        <span class="c1"># Adding long/lat fields</span>
        <span class="n">gdf_rgb</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gdf_rgb</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">x</span>
        <span class="n">gdf_rgb</span><span class="p">[</span><span class="s2">&quot;y&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gdf_rgb</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">y</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="k">return</span> <span class="n">gdf_rgb</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 class="doc doc-heading" id="sandpyper.common.get_profiles">
<code class="highlight language-python"><span class="n">get_profiles</span><span class="p">(</span><span class="n">dsm</span><span class="p">,</span> <span class="n">transect_file</span><span class="p">,</span> <span class="n">tr_ids</span><span class="p">,</span> <span class="n">transect_index</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="n">location</span><span class="p">,</span> <span class="n">date_string</span><span class="p">,</span> <span class="n">add_xy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">add_terrain</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>


<a class="headerlink" href="#sandpyper.common.get_profiles" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Returns a tidy GeoDataFrame of profile data, extracting raster information
at a user-defined (step) meters gap along each transect.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>dsm</code></td>
        <td><code>str</code></td>
        <td><p>path to the DSM raster.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>transect_file</code></td>
        <td><code>str</code></td>
        <td><p>path to the transect file.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>transect_index</code></td>
        <td><code>int</code></td>
        <td><p>index of the transect to extract information from.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>step</code></td>
        <td><code>int,float</code></td>
        <td><p>sampling distance from one point to another in meters along the transect.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>location</code></td>
        <td><code>str</code></td>
        <td><p>location code</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>date_string</code></td>
        <td><code>str</code></td>
        <td><p>raw format of the survey date (20180329)</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>add_xy</code></td>
        <td><code>bool</code></td>
        <td><p>True to add X and Y coordinates fields.</p></td>
        <td><code>False</code></td>
      </tr>
      <tr>
        <td><code>add_terrain</code></td>
        <td><code>bool</code></td>
        <td><p>True to add slope in degrees. Default to False.</p></td>
        <td><code>False</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>gdf (gpd.GeoDataFrame) </code></td>
      <td><p>Profile data extracted from the raster.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>sandpyper\common.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">get_profiles</span><span class="p">(</span>
    <span class="n">dsm</span><span class="p">,</span>
    <span class="n">transect_file</span><span class="p">,</span>
    <span class="n">tr_ids</span><span class="p">,</span>
    <span class="n">transect_index</span><span class="p">,</span>
    <span class="n">step</span><span class="p">,</span>
    <span class="n">location</span><span class="p">,</span>
    <span class="n">date_string</span><span class="p">,</span>
    <span class="n">add_xy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">add_terrain</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a tidy GeoDataFrame of profile data, extracting raster information</span>
<span class="sd">    at a user-defined (step) meters gap along each transect.</span>

<span class="sd">    Args:</span>
<span class="sd">        dsm (str): path to the DSM raster.</span>
<span class="sd">        transect_file (str): path to the transect file.</span>
<span class="sd">        transect_index (int): index of the transect to extract information from.</span>
<span class="sd">        step (int,float): sampling distance from one point to another in meters along the transect.</span>
<span class="sd">        location (str): location code</span>
<span class="sd">        date_string (str): raw format of the survey date (20180329)</span>
<span class="sd">        add_xy (bool): True to add X and Y coordinates fields.</span>
<span class="sd">        add_terrain (bool): True to add slope in degrees. Default to False.</span>

<span class="sd">    Returns:</span>
<span class="sd">        gdf (gpd.GeoDataFrame) : Profile data extracted from the raster.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">ds</span> <span class="o">=</span> <span class="n">ras</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">dsm</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span>
    <span class="n">bands</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">count</span>  <span class="c1"># get raster bands. One, in a classic DEM</span>
    <span class="n">transform</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">transform</span>  <span class="c1"># get geotransform info</span>

    <span class="c1"># index each transect and store it a &quot;line&quot; object</span>
    <span class="n">line</span> <span class="o">=</span> <span class="n">transect_file</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">transect_index</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">tr_ids</span><span class="o">==</span><span class="s1">&#39;reset&#39;</span><span class="p">:</span>
        <span class="n">line_id</span><span class="o">=</span><span class="n">line</span><span class="o">.</span><span class="n">name</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tr_ids</span><span class="p">,</span><span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">tr_ids</span> <span class="ow">in</span> <span class="n">line</span><span class="o">.</span><span class="n">index</span><span class="p">:</span>
        <span class="n">line_id</span><span class="o">=</span><span class="n">line</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">tr_ids</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&#39;tr_ids&#39; must be either &#39;reset&#39; or the name of an existing column o the transect files. &#39;</span><span class="si">{</span><span class="n">tr_ids</span><span class="si">}</span><span class="s2">&#39; was passed.&quot;</span><span class="p">)</span>


    <span class="n">length_m</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">length</span>

    <span class="c1"># Creating empty lists of coordinates, elevations and distance (from start</span>
    <span class="c1"># to end points along each transect lines)</span>

    <span class="n">x</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">y</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">z</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">slopes</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># The &quot;distance&quot; object is and empty list which will contain the x variable</span>
    <span class="c1"># which is the displacement from the shoreward end of the transects toward</span>
    <span class="c1"># the foredunes.</span>

    <span class="n">distance</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">currentdistance</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">length_m</span><span class="p">),</span> <span class="n">step</span><span class="p">):</span>

        <span class="c1"># creation of the point on the line</span>
        <span class="n">point</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">currentdistance</span><span class="p">)</span>
        <span class="n">xp</span><span class="p">,</span> <span class="n">yp</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">point</span><span class="o">.</span><span class="n">x</span><span class="p">,</span>
            <span class="n">point</span><span class="o">.</span><span class="n">y</span><span class="p">,</span>
        <span class="p">)</span>  <span class="c1"># storing point xy coordinates into xp,xy objects, respectively</span>
        <span class="n">x</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xp</span><span class="p">)</span>  <span class="c1"># see below</span>
        <span class="n">y</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="n">yp</span>
        <span class="p">)</span>  <span class="c1"># append point coordinates to previously created and empty x,y lists</span>
        <span class="c1"># extraction of the elevation value from DSM</span>
        <span class="n">z</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">get_elevation</span><span class="p">(</span><span class="n">xp</span><span class="p">,</span> <span class="n">yp</span><span class="p">,</span> <span class="n">ds</span><span class="p">,</span> <span class="n">bands</span><span class="p">,</span> <span class="n">transform</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">add_terrain</span><span class="p">))</span> <span class="o">==</span> <span class="s2">&quot;&lt;class &#39;richdem.rdarray&#39;&gt;&quot;</span><span class="p">:</span>
            <span class="n">slopes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">get_terrain_info</span><span class="p">(</span><span class="n">xp</span><span class="p">,</span> <span class="n">yp</span><span class="p">,</span> <span class="n">add_terrain</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="c1"># append the distance value (currentdistance) to distance list</span>
        <span class="n">distance</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">currentdistance</span><span class="p">)</span>

    <span class="c1"># Below, the empty lists tr_id_list and the date_list will be filled by strings</span>
    <span class="c1"># containing the transect_id of every point as stored in the original dataset</span>
    <span class="c1"># and a label with the date as set in the data setting section, after the input.</span>

    <span class="n">zs</span><span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">((</span><span class="n">elev</span> <span class="k">for</span> <span class="n">elev</span> <span class="ow">in</span> <span class="n">z</span><span class="p">))</span>

    <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">add_terrain</span><span class="p">))</span> <span class="o">==</span> <span class="s2">&quot;&lt;class &#39;richdem.rdarray&#39;&gt;&quot;</span><span class="p">:</span>
        <span class="n">slopes_series</span><span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">((</span><span class="n">slope</span> <span class="k">for</span> <span class="n">slope</span> <span class="ow">in</span> <span class="n">slope</span><span class="p">))</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s2">&quot;distance&quot;</span><span class="p">:</span> <span class="n">distance</span><span class="p">,</span> <span class="s2">&quot;z&quot;</span><span class="p">:</span> <span class="n">zs</span><span class="p">,</span> <span class="s2">&quot;slope&quot;</span><span class="p">:</span><span class="n">slopes_series</span><span class="p">})</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s2">&quot;distance&quot;</span><span class="p">:</span> <span class="n">distance</span><span class="p">,</span> <span class="s2">&quot;z&quot;</span><span class="p">:</span> <span class="n">zs</span><span class="p">})</span>


    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;coordinates&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;coordinates&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;coordinates&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">Point</span><span class="p">)</span>
    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;location&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">location</span>
    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;survey_date&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">date_string</span><span class="p">,</span> <span class="n">yearfirst</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">dayfirst</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;%Y%m</span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;raw_date&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">date_string</span>
    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;tr_id&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">line_id</span><span class="p">)</span>
    <span class="n">gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">geometry</span><span class="o">=</span><span class="s2">&quot;coordinates&quot;</span><span class="p">)</span>


    <span class="c1"># The proj4 info (coordinate reference system) is gathered with</span>
    <span class="c1"># Geopandas and applied to the newly created one.</span>
    <span class="n">gdf</span><span class="o">.</span><span class="n">crs</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">transect_file</span><span class="o">.</span><span class="n">crs</span><span class="p">)</span>

    <span class="c1"># Transforming non-hashable Shapely coordinates to hashable strings and</span>
    <span class="c1"># store them into a variable</span>

    <span class="c1"># Let&#39;s create unique IDs from the coordinates values, so that the Ids</span>
    <span class="c1"># follows the coordinates</span>
    <span class="n">gdf</span><span class="p">[</span><span class="s2">&quot;point_id&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">create_id</span><span class="p">(</span><span class="n">gdf</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">gdf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>

    <span class="k">if</span> <span class="nb">bool</span><span class="p">(</span><span class="n">add_xy</span><span class="p">):</span>
        <span class="c1"># Adding long/lat fields</span>
        <span class="n">gdf</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">x</span>
        <span class="n">gdf</span><span class="p">[</span><span class="s2">&quot;y&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">y</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="k">return</span> <span class="n">gdf</span>
</code></pre></div>
        </details>
    </div>

  </div>




  <div class="doc doc-object doc-function">



<h2 class="doc doc-heading" id="sandpyper.common.get_rbcd_transect">
<code class="highlight language-python"><span class="n">get_rbcd_transect</span><span class="p">(</span><span class="n">df_labelled</span><span class="p">,</span> <span class="n">loc_specs</span><span class="p">,</span> <span class="n">reliable_action</span><span class="p">,</span> <span class="n">dirNameTrans</span><span class="p">,</span> <span class="n">labels_order</span><span class="p">,</span> <span class="n">loc_codes</span><span class="p">,</span> <span class="n">crs_dict_string</span><span class="p">)</span></code>


<a class="headerlink" href="#sandpyper.common.get_rbcd_transect" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>It computes the r-BCDs at the transect level, based on the timeseries of elevation change magnituteds across the beachface dataset (markov_tag dataframe).</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>df_labelled</code></td>
        <td><code>pd.DataFrame</code></td>
        <td><p>Pandas dataframe with dh magnitude labelled.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>loc_specs</code></td>
        <td><code>dict</code></td>
        <td><p>Dictionary where keys are the location codes and values are location-specific (inner) dictionaries where keys are 'thresh' and 'min_points' and values are the associated values, like loc_specs={'mar':{'thresh':6,'min_points':6}, 'leo':{'thresh':4,'min_points':20}}.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>reliable_action</code></td>
        <td><code>str) </code></td>
        <td><p>Insert "drop" (default) to remove transects that have less than the specified number of non-nnn points (thresh) or "keep" to keep them.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>dirNameTrans</code></td>
        <td><code>str</code></td>
        <td><p>Path of the directory containing the transects (geopackages, .gpkg).</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>labels_order</code></td>
        <td><code>list</code></td>
        <td><p>Order of labels (magnitude of change) to be preserved.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>loc_codes</code></td>
        <td><code>list</code></td>
        <td><p>List of strings containing location codes.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>crs_dict_string</code></td>
        <td><code>dict</code></td>
        <td><p>Dictionary storing location codes as key and crs information as values, in dictionary form.</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>rbcd_transects (gpd.GeoDataFrame)</code></td>
      <td><p>A GeoDataFrames containing the steady-state distribution of each transect.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>sandpyper\common.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">get_rbcd_transect</span><span class="p">(</span><span class="n">df_labelled</span><span class="p">,</span> <span class="n">loc_specs</span><span class="p">,</span> <span class="n">reliable_action</span><span class="p">,</span> <span class="n">dirNameTrans</span><span class="p">,</span> <span class="n">labels_order</span><span class="p">,</span> <span class="n">loc_codes</span><span class="p">,</span> <span class="n">crs_dict_string</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;It computes the r-BCDs at the transect level, based on the timeseries of elevation change magnituteds across the beachface dataset (markov_tag dataframe).</span>

<span class="sd">    Args:</span>
<span class="sd">        df_labelled (pd.DataFrame): Pandas dataframe with dh magnitude labelled.</span>
<span class="sd">        loc_specs (dict): Dictionary where keys are the location codes and values are location-specific (inner) dictionaries where keys are &#39;thresh&#39; and &#39;min_points&#39; and values are the associated values, like loc_specs={&#39;mar&#39;:{&#39;thresh&#39;:6,&#39;min_points&#39;:6}, &#39;leo&#39;:{&#39;thresh&#39;:4,&#39;min_points&#39;:20}}.</span>
<span class="sd">        reliable_action (str) : Insert &quot;drop&quot; (default) to remove transects that have less than the specified number of non-nnn points (thresh) or &quot;keep&quot; to keep them.</span>
<span class="sd">        dirNameTrans (str): Path of the directory containing the transects (geopackages, .gpkg).</span>
<span class="sd">        labels_order (list): Order of labels (magnitude of change) to be preserved.</span>
<span class="sd">        loc_codes (list): List of strings containing location codes.</span>
<span class="sd">        crs_dict_string (dict): Dictionary storing location codes as key and crs information as values, in dictionary form.</span>

<span class="sd">    Returns:</span>
<span class="sd">       rbcd_transects (gpd.GeoDataFrame): A GeoDataFrames containing the steady-state distribution of each transect.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">steady_state_tr</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>

    <span class="n">df_labelled</span><span class="p">[</span><span class="s2">&quot;spatial_id&quot;</span><span class="p">]</span><span class="o">=</span><span class="p">[</span><span class="n">spatial_id</span><span class="p">(</span><span class="n">geometry_in</span><span class="p">)</span> <span class="k">for</span> <span class="n">geometry_in</span> <span class="ow">in</span> <span class="n">df_labelled</span><span class="o">.</span><span class="n">geometry</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">loc</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">df_labelled</span><span class="o">.</span><span class="n">location</span><span class="o">.</span><span class="n">unique</span><span class="p">()):</span>
        <span class="n">data_loc</span> <span class="o">=</span> <span class="n">df_labelled</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;location==&#39;</span><span class="si">{</span><span class="n">loc</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">loc</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">loc_specs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No threshold and mi_points provided in loc_specs for </span><span class="si">{</span><span class="n">loc</span><span class="si">}</span><span class="s2">. Using no filters.&quot;</span><span class="p">)</span>
            <span class="n">loc_thresh</span><span class="o">=</span><span class="mi">0</span>
            <span class="n">loc_min_pts</span><span class="o">=</span><span class="mi">0</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">loc_thresh</span><span class="o">=</span><span class="n">loc_specs</span><span class="p">[</span><span class="n">loc</span><span class="p">][</span><span class="s1">&#39;thresh&#39;</span><span class="p">]</span>
            <span class="n">loc_min_pts</span><span class="o">=</span><span class="n">loc_specs</span><span class="p">[</span><span class="n">loc</span><span class="p">][</span><span class="s1">&#39;min_points&#39;</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">tr_id</span> <span class="ow">in</span> <span class="n">data_loc</span><span class="o">.</span><span class="n">tr_id</span><span class="o">.</span><span class="n">unique</span><span class="p">():</span>

            <span class="n">data_tr</span> <span class="o">=</span> <span class="n">data_loc</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;tr_id==&#39;</span><span class="si">{</span><span class="n">tr_id</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">data_tr</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
                <span class="n">data_tr</span> <span class="o">=</span> <span class="n">data_loc</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;tr_id==</span><span class="si">{</span><span class="n">tr_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">data_tr</span><span class="p">[</span><span class="s2">&quot;spatial_id&quot;</span><span class="p">]</span><span class="o">=</span><span class="p">[</span><span class="n">spatial_id</span><span class="p">(</span><span class="n">geometry_in</span><span class="p">)</span> <span class="k">for</span> <span class="n">geometry_in</span> <span class="ow">in</span> <span class="n">data_tr</span><span class="o">.</span><span class="n">geometry</span><span class="p">]</span>

            <span class="n">data_piv</span> <span class="o">=</span> <span class="n">data_tr</span><span class="o">.</span><span class="n">pivot</span><span class="p">(</span>
                <span class="n">values</span><span class="o">=</span><span class="s1">&#39;markov_tag&#39;</span><span class="p">,</span>
                <span class="n">index</span><span class="o">=</span><span class="s2">&quot;spatial_id&quot;</span><span class="p">,</span>
                <span class="n">columns</span><span class="o">=</span><span class="s1">&#39;dt&#39;</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="c1"># identify the points that have less than the required number of transitions (thresh) of non nan states</span>
            <span class="n">valid_pts</span><span class="o">=</span><span class="p">((</span><span class="o">~</span><span class="n">data_piv</span><span class="o">.</span><span class="n">isnull</span><span class="p">())</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">&gt;=</span><span class="n">loc_thresh</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

            <span class="c1"># has this transect a number of valid points above the specified min_pts parameter?</span>
            <span class="n">valid_transect</span><span class="o">=</span> <span class="n">valid_pts</span> <span class="o">&gt;=</span> <span class="n">loc_min_pts</span>

            <span class="c1"># drop ivalid points</span>
            <span class="n">data_piv</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">thresh</span><span class="o">=</span><span class="n">loc_thresh</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="c1"># all the  NaN will be named &#39;nnn&#39;</span>
            <span class="n">data_piv</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="s2">&quot;nnn&quot;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="n">n</span> <span class="o">=</span> <span class="n">data_piv</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data_piv</span><span class="p">)</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">Markov</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">steady_state</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">steady_state</span>
                <span class="n">steady_state</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
                    <span class="n">m</span><span class="o">.</span><span class="n">steady_state</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">m</span><span class="o">.</span><span class="n">classes</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="n">tr_id</span><span class="p">]</span>
                <span class="p">)</span>

                <span class="n">steady_state</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">steady_state</span><span class="o">.</span><span class="n">rename</span><span class="p">({</span><span class="s2">&quot;index&quot;</span><span class="p">:</span> <span class="s2">&quot;markov_tag&quot;</span><span class="p">},</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">steady_state</span> <span class="o">=</span> <span class="n">steady_state</span><span class="o">.</span><span class="n">melt</span><span class="p">(</span>
                    <span class="n">id_vars</span><span class="o">=</span><span class="s2">&quot;markov_tag&quot;</span><span class="p">,</span> <span class="n">value_name</span><span class="o">=</span><span class="s2">&quot;p&quot;</span><span class="p">,</span> <span class="n">var_name</span><span class="o">=</span><span class="s2">&quot;tr_id&quot;</span>
                <span class="p">)</span>
                <span class="n">steady_state</span><span class="p">[</span><span class="s2">&quot;location&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">loc</span>
                <span class="n">steady_state</span><span class="p">[</span><span class="s2">&quot;thresh&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">loc_thresh</span>
                <span class="n">steady_state</span><span class="p">[</span><span class="s2">&quot;min_pts&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">loc_min_pts</span>
                <span class="n">steady_state</span><span class="p">[</span><span class="s2">&quot;valid_pts&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">valid_pts</span>
                <span class="n">steady_state</span><span class="p">[</span><span class="s2">&quot;reliable&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">valid_transect</span>

                <span class="n">steady_state_tr</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">steady_state</span><span class="p">,</span> <span class="n">steady_state_tr</span><span class="p">],</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span>
                <span class="p">)</span>

            <span class="k">except</span> <span class="ne">BaseException</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;tr_id </span><span class="si">{</span><span class="n">tr_id</span><span class="si">}</span><span class="s2"> has </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2"> valid points.&quot;</span><span class="p">)</span>
                <span class="n">null_df</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;markov_tag&#39;</span><span class="p">:</span><span class="n">df_labelled</span><span class="o">.</span><span class="n">markov_tag</span><span class="o">.</span><span class="n">unique</span><span class="p">(),</span>
                                    <span class="s1">&#39;p&#39;</span><span class="p">:[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">df_labelled</span><span class="o">.</span><span class="n">markov_tag</span><span class="o">.</span><span class="n">unique</span><span class="p">()]})</span>
                <span class="n">null_df</span><span class="p">[</span><span class="s2">&quot;tr_id&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">tr_id</span>
                <span class="n">null_df</span><span class="p">[</span><span class="s2">&quot;location&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">loc</span>
                <span class="n">null_df</span><span class="p">[</span><span class="s2">&quot;thresh&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">loc_thresh</span>
                <span class="n">null_df</span><span class="p">[</span><span class="s2">&quot;min_pts&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">loc_min_pts</span>
                <span class="n">null_df</span><span class="p">[</span><span class="s2">&quot;valid_pts&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">valid_pts</span>
                <span class="n">null_df</span><span class="p">[</span><span class="s2">&quot;reliable&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">valid_transect</span>

                <span class="n">steady_state_tr</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">null_df</span><span class="p">,</span> <span class="n">steady_state_tr</span><span class="p">],</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span>
                <span class="p">)</span>

    <span class="c1"># what to do with unreliable transects?</span>
    <span class="k">if</span> <span class="n">reliable_action</span> <span class="o">==</span><span class="s1">&#39;drop&#39;</span><span class="p">:</span>
        <span class="n">steady_state_tr</span><span class="o">=</span><span class="n">steady_state_tr</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="s2">&quot;reliable == True&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">reliable_action</span> <span class="o">==</span><span class="s1">&#39;keep&#39;</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The parameter &#39;reliable_action&#39; must be either &#39;drop&#39; or &#39;keep&#39;.&quot;</span><span class="p">)</span>

    <span class="n">ss_transects_idx</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>

    <span class="n">idx_matrix</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">labels_order</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span>

    <span class="k">for</span> <span class="n">loc</span> <span class="ow">in</span> <span class="n">steady_state_tr</span><span class="o">.</span><span class="n">location</span><span class="o">.</span><span class="n">unique</span><span class="p">():</span>

        <span class="n">sub</span> <span class="o">=</span> <span class="n">steady_state_tr</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;location==&#39;</span><span class="si">{</span><span class="n">loc</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>
        <span class="n">sub</span> <span class="o">=</span> <span class="n">sub</span><span class="o">.</span><span class="n">pivot</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="s2">&quot;markov_tag&quot;</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="s2">&quot;tr_id&quot;</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;p&quot;</span><span class="p">))</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sub</span><span class="o">.</span><span class="n">index</span><span class="p">)</span><span class="o">!=</span><span class="nb">len</span><span class="p">(</span><span class="n">labels_order</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot; The following magnitude labels are missing from the steady state dataset: </span><span class="si">{</span><span class="nb">set</span><span class="p">(</span><span class="n">sub</span><span class="o">.</span><span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="n">symmetric_difference</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">labels_order</span><span class="p">))</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="n">sub</span> <span class="o">=</span> <span class="n">sub</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">labels_order</span><span class="p">,</span> <span class="p">:]</span>

        <span class="c1"># Create erosion and deposition sub-matrix</span>
        <span class="n">erosion</span> <span class="o">=</span> <span class="n">sub</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">idx_matrix</span><span class="p">:,</span> <span class="p">:]</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
        <span class="n">erosion</span><span class="p">[</span><span class="s2">&quot;erosion&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">erosion</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">erosion</span><span class="o">=</span><span class="n">erosion</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()[[</span><span class="s2">&quot;tr_id&quot;</span><span class="p">,</span><span class="s2">&quot;erosion&quot;</span><span class="p">]]</span>

        <span class="n">deposition</span> <span class="o">=</span> <span class="n">sub</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:</span><span class="o">-</span><span class="n">idx_matrix</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
        <span class="n">deposition</span><span class="p">[</span><span class="s2">&quot;deposition&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">deposition</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">deposition</span><span class="o">=</span><span class="n">deposition</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()[[</span><span class="s2">&quot;tr_id&quot;</span><span class="p">,</span><span class="s2">&quot;deposition&quot;</span><span class="p">]]</span>
        <span class="n">merged_erodepo</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">erosion</span><span class="p">,</span> <span class="n">deposition</span><span class="p">)</span>

        <span class="n">merged_erodepo</span><span class="p">[</span><span class="s2">&quot;residual&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">merged_erodepo</span><span class="o">.</span><span class="n">deposition</span> <span class="o">-</span> <span class="n">merged_erodepo</span><span class="o">.</span><span class="n">erosion</span>
        <span class="n">merged_erodepo</span><span class="p">[</span><span class="s2">&quot;location&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">loc</span>

        <span class="n">to_plot</span> <span class="o">=</span> <span class="n">merged_erodepo</span><span class="o">.</span><span class="n">melt</span><span class="p">(</span>
            <span class="n">id_vars</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;tr_id&quot;</span><span class="p">],</span> <span class="n">var_name</span><span class="o">=</span><span class="s2">&quot;process&quot;</span><span class="p">,</span> <span class="n">value_name</span><span class="o">=</span><span class="s2">&quot;coastal_index&quot;</span>
        <span class="p">)</span>
        <span class="n">to_plot</span><span class="p">[</span><span class="s2">&quot;location&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">loc</span>

        <span class="n">path_trs</span><span class="o">=</span><span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="sa">rf</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">dirNameTrans</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">loc</span><span class="si">}</span><span class="s2">*&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">transect_in</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="n">path_trs</span><span class="p">)</span>
        <span class="n">transect_in</span><span class="o">.</span><span class="n">columns</span><span class="o">=</span> <span class="n">transect_in</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

        <span class="n">merged_erodepo</span><span class="p">[</span><span class="s2">&quot;geometry&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span>
                    <span class="n">merged_erodepo</span><span class="p">,</span> <span class="n">transect_in</span><span class="p">[[</span><span class="s2">&quot;tr_id&quot;</span><span class="p">,</span><span class="s2">&quot;geometry&quot;</span><span class="p">]],</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="s2">&quot;tr_id&quot;</span>
                <span class="p">)</span><span class="o">.</span><span class="n">geometry</span>

        <span class="n">ss_transects_idx_loc</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span>
                        <span class="n">merged_erodepo</span><span class="p">,</span> <span class="n">geometry</span><span class="o">=</span><span class="s2">&quot;geometry&quot;</span><span class="p">,</span> <span class="n">crs</span><span class="o">=</span><span class="n">crs_dict_string</span><span class="p">[</span><span class="n">loc</span><span class="p">]</span>  <span class="p">)</span>

        <span class="n">ss_transects_idx</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">ss_transects_idx_loc</span><span class="p">,</span><span class="n">ss_transects_idx</span><span class="p">],</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">ss_transects_idx</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 class="doc doc-heading" id="sandpyper.common.get_sil_location">
<code class="highlight language-python"><span class="n">get_sil_location</span><span class="p">(</span><span class="n">merged_df</span><span class="p">,</span> <span class="n">ks</span><span class="p">,</span> <span class="n">feature_set</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span></code>


<a class="headerlink" href="#sandpyper.common.get_sil_location" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Function to obtain average Silhouette scores for a list of number of clusters (k) in all surveys.
It uses KMeans as a clusteres and parallel processing for improved speed.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>It might take up to 8h for tables of 6,000,000 observations.</p>
</div>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>merged_df</code></td>
        <td><code>pd.DataFrame</code></td>
        <td><p>The clean and merged dataframe containing the features.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>ks</code></td>
        <td><code>tuple</code></td>
        <td><p>starting and ending number of clusters to run KMeans and compute SA on.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>feature_set</code></td>
        <td><code>list</code></td>
        <td><p>List of strings of features in the dataframe to use for clustering.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>random_state</code></td>
        <td><code>int</code></td>
        <td><p>Random seed used to make the randomisation deterministic.</p></td>
        <td><code>10</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>sil_df (pd.DataFrame)</code></td>
      <td><p>A dataframe containing average Silhouette scores for each survey, based on the provided feature set.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>sandpyper\common.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">get_sil_location</span><span class="p">(</span><span class="n">merged_df</span><span class="p">,</span> <span class="n">ks</span><span class="p">,</span> <span class="n">feature_set</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function to obtain average Silhouette scores for a list of number of clusters (k) in all surveys.</span>
<span class="sd">    It uses KMeans as a clusteres and parallel processing for improved speed.</span>

<span class="sd">    Warning:</span>
<span class="sd">        It might take up to 8h for tables of 6,000,000 observations.</span>

<span class="sd">    Args:</span>
<span class="sd">        merged_df (pd.DataFrame): The clean and merged dataframe containing the features.</span>
<span class="sd">        ks (tuple): starting and ending number of clusters to run KMeans and compute SA on.</span>
<span class="sd">        feature_set (list): List of strings of features in the dataframe to use for clustering.</span>
<span class="sd">        random_state (int): Random seed used to make the randomisation deterministic.</span>

<span class="sd">    Returns:</span>
<span class="sd">        sil_df (pd.DataFrame): A dataframe containing average Silhouette scores for each survey, based on the provided feature set.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Creates the range of k to be used for Silhouette Analysis</span>
    <span class="n">k_rng</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="o">*</span><span class="n">ks</span><span class="p">)</span>

    <span class="c1"># Get list of locations</span>
    <span class="n">list_locs</span> <span class="o">=</span> <span class="n">merged_df</span><span class="o">.</span><span class="n">location</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>

    <span class="c1"># Setting up the estimator to scale and translate each feature</span>
    <span class="c1"># individually to a 0 to 1 range.</span>
    <span class="n">scaler</span> <span class="o">=</span> <span class="n">MinMaxScaler</span><span class="p">()</span>

    <span class="n">location_series</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">dates_series</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">n_clusters_series</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">silhouette_avg_series</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">location</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">list_locs</span><span class="p">):</span>

        <span class="n">list_dates</span> <span class="o">=</span> <span class="n">merged_df</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;location==&#39;</span><span class="si">{</span><span class="n">location</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">raw_date</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">survey_date_in</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">list_dates</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Working on : </span><span class="si">{</span><span class="n">location</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">survey_date_in</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>

            <span class="n">data_in</span> <span class="o">=</span> <span class="n">merged_df</span><span class="o">.</span><span class="n">query</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;location==&#39;</span><span class="si">{</span><span class="n">location</span><span class="si">}</span><span class="s2">&#39; &amp; raw_date == </span><span class="si">{</span><span class="n">survey_date_in</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="n">data_in</span> <span class="o">=</span> <span class="n">data_in</span><span class="p">[</span><span class="n">feature_set</span><span class="p">]</span>
            <span class="n">data_in</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">n_clusters</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">k_rng</span><span class="p">):</span>

                <span class="n">minmax_scaled_df</span> <span class="o">=</span> <span class="n">scaler</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">data_in</span><span class="p">)</span>
                <span class="n">minmax_scaled_df</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">minmax_scaled_df</span><span class="p">)</span>

                <span class="n">clusterer</span> <span class="o">=</span> <span class="n">KMeans</span><span class="p">(</span>
                    <span class="n">n_clusters</span><span class="o">=</span><span class="n">n_clusters</span><span class="p">,</span>
                    <span class="n">init</span><span class="o">=</span><span class="s2">&quot;k-means++&quot;</span><span class="p">,</span>
                    <span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;elkan&quot;</span><span class="p">,</span>
                    <span class="n">tol</span><span class="o">=</span><span class="mf">0.0001</span><span class="p">,</span>
                    <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">,</span>
                <span class="p">)</span>

                <span class="n">cluster_labels</span> <span class="o">=</span> <span class="n">clusterer</span><span class="o">.</span><span class="n">fit_predict</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">minmax_scaled_df</span><span class="p">))</span>

                <span class="c1"># The silhouette_score gives the average value for all the samples.</span>
                <span class="c1"># This gives a perspective into the density and separation of the formed</span>
                <span class="c1"># clusters</span>
                <span class="n">silhouette_avg</span> <span class="o">=</span> <span class="n">silhouette_score</span><span class="p">(</span><span class="n">minmax_scaled_df</span><span class="p">,</span> <span class="n">cluster_labels</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="s2">&quot;For n_clusters =&quot;</span><span class="p">,</span>
                    <span class="n">n_clusters</span><span class="p">,</span>
                    <span class="s2">&quot;The average silhouette_score is :&quot;</span><span class="p">,</span>
                    <span class="n">silhouette_avg</span><span class="p">,</span>
                <span class="p">)</span>

                <span class="n">location_series</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">location</span><span class="p">)</span>
                <span class="n">dates_series</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">survey_date_in</span><span class="p">)</span>
                <span class="n">n_clusters_series</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n_clusters</span><span class="p">)</span>
                <span class="n">silhouette_avg_series</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">silhouette_avg</span><span class="p">)</span>

    <span class="n">items_dict</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;location&quot;</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">location_series</span><span class="p">),</span>
        <span class="s2">&quot;raw_date&quot;</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">dates_series</span><span class="p">),</span>
        <span class="s2">&quot;k&quot;</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">n_clusters_series</span><span class="p">),</span>
        <span class="s2">&quot;silhouette_mean&quot;</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">silhouette_avg_series</span><span class="p">),</span>
    <span class="p">}</span>

    <span class="n">sil_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">items_dict</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">sil_df</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 class="doc doc-heading" id="sandpyper.common.get_state_vol_table">
<code class="highlight language-python"><span class="n">get_state_vol_table</span><span class="p">(</span><span class="n">sand_pts</span><span class="p">,</span> <span class="n">lod</span><span class="p">,</span> <span class="n">full_specs_table</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="n">transect_spacing</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">outliers</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sigma_n</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span></code>


<a class="headerlink" href="#sandpyper.common.get_state_vol_table" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Function to compute location-level altimetric beach change statistics from the multitemporal table.
By default, only sand points beyond LoD are accounted for. Optionally, LoD filter can be turned off.
The table contains info on:
- monitoring period: location code, full name, period code, dates, number of days and valid points
- absolute altimetric change: total beachface rising, lowering and net change
- normalised altimetric change: meters of rising, lowering and net elevation change per valid survey point (MEC)</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>sand_pts</code></td>
        <td><code>Pandas dataframe</code></td>
        <td><p>multitemporal table.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>lod</code></td>
        <td><code>str, bool</code></td>
        <td><p>if valid path to an LoD table, use the table. If a value is provided, use the value across all surveys. If False, do not apply LoD filter.cAll elevation change (dh) values within LoD will be set to zero.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>full_specs_table</code></td>
        <td><code>False, path</code></td>
        <td><p>Full path to the table with extended monitoring info. If False, monitoring period information are limited.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>dx</code></td>
        <td><code>int,float</code></td>
        <td><p>The along-transect point spacing.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>transect_spacing</code></td>
        <td><code>int</code></td>
        <td><p>Alongshore spacing of transects (m)</p></td>
        <td><code>20</code></td>
      </tr>
      <tr>
        <td><code>outliers</code></td>
        <td><code>bool</code></td>
        <td><p>when True, use the specified number of standard deviation to exclude outliers. If False, retain all the points.</p></td>
        <td><code>False</code></td>
      </tr>
      <tr>
        <td><code>sigma_n</code></td>
        <td><code>int</code></td>
        <td><p>number of standard deviation to use to exclude outliers (default=3).</p></td>
        <td><code>3</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>volumetrics_location (pd.DataFrame)</code></td>
      <td><p>A dataframe storing altimetric beach change info and other information for every period and location.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>sandpyper\common.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">get_state_vol_table</span><span class="p">(</span>
    <span class="n">sand_pts</span><span class="p">,</span> <span class="n">lod</span><span class="p">,</span> <span class="n">full_specs_table</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="n">transect_spacing</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">outliers</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sigma_n</span><span class="o">=</span><span class="mi">3</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function to compute location-level altimetric beach change statistics from the multitemporal table.</span>
<span class="sd">    By default, only sand points beyond LoD are accounted for. Optionally, LoD filter can be turned off.</span>
<span class="sd">    The table contains info on:</span>
<span class="sd">    - monitoring period: location code, full name, period code, dates, number of days and valid points</span>
<span class="sd">    - absolute altimetric change: total beachface rising, lowering and net change</span>
<span class="sd">    - normalised altimetric change: meters of rising, lowering and net elevation change per valid survey point (MEC)</span>


<span class="sd">    Args:</span>
<span class="sd">        sand_pts (Pandas dataframe): multitemporal table.</span>
<span class="sd">        lod (str, bool): if valid path to an LoD table, use the table. If a value is provided, use the value across all surveys. If False, do not apply LoD filter.cAll elevation change (dh) values within LoD will be set to zero.</span>
<span class="sd">        full_specs_table (False, path): Full path to the table with extended monitoring info. If False, monitoring period information are limited.</span>
<span class="sd">        dx (int,float): The along-transect point spacing.</span>
<span class="sd">        transect_spacing (int): Alongshore spacing of transects (m)</span>
<span class="sd">        outliers (bool): when True, use the specified number of standard deviation to exclude outliers. If False, retain all the points.</span>
<span class="sd">        sigma_n (int): number of standard deviation to use to exclude outliers (default=3).</span>


<span class="sd">    Returns:</span>
<span class="sd">        volumetrics_location (pd.DataFrame): A dataframe storing altimetric beach change info and other information for every period and location.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">full_specs_table</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">bool</span><span class="p">(</span><span class="n">full_specs_table</span><span class="p">)</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">skip_details</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Please provide the path to the specs table.&quot;</span><span class="p">)</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">full_specs_table</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">full_specs_table</span><span class="p">):</span>
            <span class="n">table_details</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">full_specs_table</span><span class="p">)</span>
            <span class="n">skip_details</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Not a valid path to the .csv file for the specs table.&quot;</span><span class="p">)</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">full_specs_table</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
        <span class="n">table_details</span> <span class="o">=</span> <span class="n">full_specs_table</span>
        <span class="n">skip_details</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Not a valid path to the .csv file for the specs table.&quot;</span><span class="p">)</span>


    <span class="n">tr_df_full</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>

    <span class="n">locs</span> <span class="o">=</span> <span class="n">sand_pts</span><span class="o">.</span><span class="n">location</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">loc</span> <span class="ow">in</span> <span class="n">locs</span><span class="p">:</span>
        <span class="n">test_loc</span> <span class="o">=</span> <span class="n">sand_pts</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;location == &#39;</span><span class="si">{</span><span class="n">loc</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">dt</span> <span class="ow">in</span> <span class="n">test_loc</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">unique</span><span class="p">():</span>
            <span class="n">test_dt</span> <span class="o">=</span> <span class="n">test_loc</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot; dt ==&#39;</span><span class="si">{</span><span class="n">dt</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>
            <span class="n">data_in</span> <span class="o">=</span> <span class="n">prep_heatmap</span><span class="p">(</span><span class="n">test_dt</span><span class="p">,</span> <span class="n">lod</span><span class="o">=</span><span class="n">lod</span><span class="p">,</span> <span class="n">outliers</span><span class="o">=</span><span class="n">outliers</span><span class="p">,</span> <span class="n">sigma_n</span><span class="o">=</span><span class="n">sigma_n</span><span class="p">)</span>

            <span class="c1"># compute erosion and deposition volumes at site level</span>
            <span class="n">data_in_erosion</span> <span class="o">=</span> <span class="n">data_in</span><span class="p">[</span><span class="n">data_in</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">data_in_deposition</span> <span class="o">=</span> <span class="n">data_in</span><span class="p">[</span><span class="n">data_in</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>

            <span class="k">if</span> <span class="nb">bool</span><span class="p">(</span><span class="n">skip_details</span><span class="p">):</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">specs</span> <span class="o">=</span> <span class="n">table_details</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;location==&#39;</span><span class="si">{</span><span class="n">loc</span><span class="si">}</span><span class="s2">&#39; &amp; dt==&#39;</span><span class="si">{</span><span class="n">dt</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>
                <span class="n">full_loc</span> <span class="o">=</span> <span class="n">specs</span><span class="o">.</span><span class="n">loc_full</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">date_from</span> <span class="o">=</span> <span class="n">specs</span><span class="o">.</span><span class="n">date_pre</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">date_to</span> <span class="o">=</span> <span class="n">specs</span><span class="o">.</span><span class="n">date_post</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">n_days</span> <span class="o">=</span> <span class="n">specs</span><span class="o">.</span><span class="n">n_days</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="n">beach_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_in</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span> <span class="o">*</span> <span class="n">transect_spacing</span>

            <span class="n">n_obs_valid</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">data_in</span><span class="o">.</span><span class="n">count</span><span class="p">()</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="p">)</span>  <span class="c1"># sand only, within beachface, LoD filtered (default)</span>

            <span class="n">abs_in</span> <span class="o">=</span> <span class="n">data_in</span><span class="p">[</span><span class="n">data_in</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>  <span class="c1"># total profiles rising</span>
            <span class="n">abs_out</span> <span class="o">=</span> <span class="n">data_in</span><span class="p">[</span><span class="n">data_in</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>  <span class="c1"># total profiles lowering</span>
            <span class="n">abs_net_change</span> <span class="o">=</span> <span class="n">data_in</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>  <span class="c1"># net altimetric change</span>

            <span class="n">mec_m</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">abs_net_change</span> <span class="o">/</span> <span class="n">beach_length</span>
            <span class="p">)</span>  <span class="c1"># meters of elevation change per meter of beach</span>

            <span class="n">norm_in</span> <span class="o">=</span> <span class="n">abs_in</span> <span class="o">/</span> <span class="n">n_obs_valid</span>  <span class="c1"># meters of profile rising per valid point</span>
            <span class="n">norm_out</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">abs_out</span> <span class="o">/</span> <span class="n">n_obs_valid</span>
            <span class="p">)</span>  <span class="c1"># meters of profile lowering per valid point</span>
            <span class="n">norm_net_change</span> <span class="o">=</span> <span class="n">abs_net_change</span> <span class="o">/</span> <span class="n">n_obs_valid</span>  <span class="c1"># MEC</span>

            <span class="n">tot_vol_depo</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">data_in_deposition</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">interpol_integrate</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">**</span><span class="p">{</span><span class="s1">&#39;dx&#39;</span><span class="p">:</span><span class="n">dx</span><span class="p">})</span> <span class="o">*</span> <span class="n">transect_spacing</span>
            <span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="n">tot_vol_ero</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">data_in_erosion</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">interpol_integrate</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">**</span><span class="p">{</span><span class="s1">&#39;dx&#39;</span><span class="p">:</span><span class="n">dx</span><span class="p">})</span> <span class="o">*</span> <span class="n">transect_spacing</span>
            <span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="n">net_vol_change</span> <span class="o">=</span> <span class="n">tot_vol_depo</span> <span class="o">+</span> <span class="n">tot_vol_ero</span>
            <span class="n">location_m3_m</span> <span class="o">=</span> <span class="n">net_vol_change</span> <span class="o">/</span> <span class="n">beach_length</span>

            <span class="k">if</span> <span class="nb">bool</span><span class="p">(</span><span class="n">skip_details</span><span class="p">)</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
                <span class="n">df_dict</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s2">&quot;location&quot;</span><span class="p">:</span> <span class="n">loc</span><span class="p">,</span>
                    <span class="s2">&quot;location_full&quot;</span><span class="p">:</span> <span class="n">full_loc</span><span class="p">,</span>
                    <span class="s2">&quot;dt&quot;</span><span class="p">:</span> <span class="n">dt</span><span class="p">,</span>
                    <span class="s2">&quot;date_from&quot;</span><span class="p">:</span> <span class="n">date_from</span><span class="p">,</span>
                    <span class="s2">&quot;date_to&quot;</span><span class="p">:</span> <span class="n">date_to</span><span class="p">,</span>
                    <span class="s2">&quot;n_days&quot;</span><span class="p">:</span> <span class="n">n_days</span><span class="p">,</span>
                    <span class="s2">&quot;abs_in&quot;</span><span class="p">:</span> <span class="n">abs_in</span><span class="p">,</span>
                    <span class="s2">&quot;abs_out&quot;</span><span class="p">:</span> <span class="n">abs_out</span><span class="p">,</span>
                    <span class="s2">&quot;abs_net_change&quot;</span><span class="p">:</span> <span class="n">abs_net_change</span><span class="p">,</span>
                    <span class="s2">&quot;mec_m&quot;</span><span class="p">:</span> <span class="n">mec_m</span><span class="p">,</span>
                    <span class="s2">&quot;norm_in&quot;</span><span class="p">:</span> <span class="n">norm_in</span><span class="p">,</span>
                    <span class="s2">&quot;norm_out&quot;</span><span class="p">:</span> <span class="n">norm_out</span><span class="p">,</span>
                    <span class="s2">&quot;norm_net_change&quot;</span><span class="p">:</span> <span class="n">norm_net_change</span><span class="p">,</span>
                    <span class="s2">&quot;tot_vol_depo&quot;</span><span class="p">:</span> <span class="n">tot_vol_depo</span><span class="p">,</span>
                    <span class="s2">&quot;tot_vol_ero&quot;</span><span class="p">:</span> <span class="n">tot_vol_ero</span><span class="p">,</span>
                    <span class="s2">&quot;net_vol_change&quot;</span><span class="p">:</span> <span class="n">tot_vol_depo</span> <span class="o">-</span> <span class="nb">abs</span><span class="p">(</span><span class="n">tot_vol_ero</span><span class="p">),</span>
                    <span class="s2">&quot;location_m3_m&quot;</span><span class="p">:</span> <span class="n">location_m3_m</span><span class="p">,</span>
                    <span class="s2">&quot;n_obs_valid&quot;</span><span class="p">:</span> <span class="n">n_obs_valid</span><span class="p">,</span>
                <span class="p">}</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">df_dict</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s2">&quot;location&quot;</span><span class="p">:</span> <span class="n">loc</span><span class="p">,</span>
                    <span class="s2">&quot;dt&quot;</span><span class="p">:</span> <span class="n">dt</span><span class="p">,</span>
                    <span class="s2">&quot;abs_in&quot;</span><span class="p">:</span> <span class="n">abs_in</span><span class="p">,</span>
                    <span class="s2">&quot;abs_out&quot;</span><span class="p">:</span> <span class="n">abs_out</span><span class="p">,</span>
                    <span class="s2">&quot;abs_net_change&quot;</span><span class="p">:</span> <span class="n">abs_net_change</span><span class="p">,</span>
                    <span class="s2">&quot;mec_m&quot;</span><span class="p">:</span> <span class="n">mec_m</span><span class="p">,</span>
                    <span class="s2">&quot;norm_in&quot;</span><span class="p">:</span> <span class="n">norm_in</span><span class="p">,</span>
                    <span class="s2">&quot;norm_out&quot;</span><span class="p">:</span> <span class="n">norm_out</span><span class="p">,</span>
                    <span class="s2">&quot;norm_net_change&quot;</span><span class="p">:</span> <span class="n">norm_net_change</span><span class="p">,</span>
                    <span class="s2">&quot;tot_vol_depo&quot;</span><span class="p">:</span> <span class="n">tot_vol_depo</span><span class="p">,</span>
                    <span class="s2">&quot;tot_vol_ero&quot;</span><span class="p">:</span> <span class="n">tot_vol_ero</span><span class="p">,</span>
                    <span class="s2">&quot;net_vol_change&quot;</span><span class="p">:</span> <span class="n">tot_vol_depo</span> <span class="o">-</span> <span class="nb">abs</span><span class="p">(</span><span class="n">tot_vol_ero</span><span class="p">),</span>
                    <span class="s2">&quot;location_m3_m&quot;</span><span class="p">:</span> <span class="n">location_m3_m</span><span class="p">,</span>
                    <span class="s2">&quot;n_obs_valid&quot;</span><span class="p">:</span> <span class="n">n_obs_valid</span><span class="p">,</span>
                <span class="p">}</span>

            <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">df_dict</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

            <span class="n">tr_df_full</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">df</span><span class="p">,</span> <span class="n">tr_df_full</span><span class="p">],</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">tr_df_full</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 class="doc doc-heading" id="sandpyper.common.get_terrain_info">
<code class="highlight language-python"><span class="n">get_terrain_info</span><span class="p">(</span><span class="n">x_coord</span><span class="p">,</span> <span class="n">y_coord</span><span class="p">,</span> <span class="n">rdarray</span><span class="p">)</span></code>


<a class="headerlink" href="#sandpyper.common.get_terrain_info" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Returns the value of the rdarray rasters.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>x_coord</code></td>
        <td><code>float</code></td>
        <td><p>Projected X coordinates of pixel to extract value.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>y_coord</code></td>
        <td><code>float</code></td>
        <td><p>Projected Y coordinates of pixel to extract value.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>rdarray</code></td>
        <td><code>rdarray</code></td>
        <td><p>rdarray dataset.</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>px (int, float)</code></td>
      <td><p>rdarray pixel value.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>sandpyper\common.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">get_terrain_info</span><span class="p">(</span><span class="n">x_coord</span><span class="p">,</span> <span class="n">y_coord</span><span class="p">,</span> <span class="n">rdarray</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the value of the rdarray rasters.</span>

<span class="sd">    Args:</span>
<span class="sd">        x_coord (float): Projected X coordinates of pixel to extract value.</span>
<span class="sd">        y_coord (float): Projected Y coordinates of pixel to extract value.</span>
<span class="sd">        rdarray (rdarray): rdarray dataset.</span>

<span class="sd">    Returns:</span>
<span class="sd">        px (int, float): rdarray pixel value.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">geotransform</span> <span class="o">=</span> <span class="n">rdarray</span><span class="o">.</span><span class="n">geotransform</span>

    <span class="n">xOrigin</span> <span class="o">=</span> <span class="n">geotransform</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># top-left X</span>
    <span class="n">yOrigin</span> <span class="o">=</span> <span class="n">geotransform</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>  <span class="c1"># top-left y</span>
    <span class="n">pixelWidth</span> <span class="o">=</span> <span class="n">geotransform</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># horizontal pixel resolution</span>
    <span class="n">pixelHeight</span> <span class="o">=</span> <span class="n">geotransform</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>  <span class="c1"># vertical pixel resolution</span>
    <span class="n">px</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">x_coord</span> <span class="o">-</span> <span class="n">xOrigin</span><span class="p">)</span> <span class="o">/</span> <span class="n">pixelWidth</span><span class="p">)</span>  <span class="c1"># transform geographic to image coords</span>
    <span class="n">py</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">y_coord</span> <span class="o">-</span> <span class="n">yOrigin</span><span class="p">)</span> <span class="o">/</span> <span class="n">pixelHeight</span><span class="p">)</span>  <span class="c1"># transform geographic to image coords</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">rdarray</span><span class="p">[</span><span class="n">py</span><span class="p">,</span> <span class="n">px</span><span class="p">]</span>
    <span class="k">except</span> <span class="ne">BaseException</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 class="doc doc-heading" id="sandpyper.common.get_transects_vol_table">
<code class="highlight language-python"><span class="n">get_transects_vol_table</span><span class="p">(</span><span class="n">sand_pts</span><span class="p">,</span> <span class="n">lod</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="n">full_specs_table</span><span class="p">,</span> <span class="n">transect_spacing</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">outliers</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sigma_n</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span></code>


<a class="headerlink" href="#sandpyper.common.get_transects_vol_table" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Function to compute transect-level altimetric change statistics from the multitemporal table.
By default, only sand points beyond LoD are accounted for. Optionally, LoD filter can be turned off.
The table contains info on:
- monitoring period: location code, full name, period code, transect ID, dates, number of days and valid points
- absolute altimetric change: total profile rising, lowering and net change
- normalised altimetric change: meters of rising, lowering and net elevation change per valid survey point (MEC)</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>sand_pts</code></td>
        <td><code>pd.DataFrame</code></td>
        <td><p>Multitemporal dh table.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>lod</code></td>
        <td><code>str, float, False</code></td>
        <td><p>If valid path to an LoD table, use the table. If a value is provided, use the value across all surveys. If False, do not apply LoD filter. All elevation change (dh) values within LoD will be set to zero.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>dx</code></td>
        <td><code>int,float</code></td>
        <td><p>The along-transect point spacing.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>full_specs_table</code></td>
        <td><code>str, pd.DataFRame, bool</code></td>
        <td><p>Full path to the table with extended monitoring info or the table itself. If False, monitoring period information are limited.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>outliers</code></td>
        <td><code></code></td>
        <td><p>when True, use the specified number of standard deviation to exclude outliers. If False, retain all the points.</p></td>
        <td><code>False</code></td>
      </tr>
      <tr>
        <td><code>sigma_n</code></td>
        <td><code>int</code></td>
        <td><p>number of standard deviation to use to exclude outliers (default=3).</p></td>
        <td><code>3</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>volumetrics_transects (pd.DataFrame)</code></td>
      <td><p>A dataframe storing altimetric beach change info at the transect level, and other information for every period and location.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>sandpyper\common.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">get_transects_vol_table</span><span class="p">(</span>
    <span class="n">sand_pts</span><span class="p">,</span>
    <span class="n">lod</span><span class="p">,</span>
    <span class="n">dx</span><span class="p">,</span>
    <span class="n">full_specs_table</span><span class="p">,</span>
    <span class="n">transect_spacing</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span>  <span class="c1"># INTEGRATED</span>
    <span class="n">outliers</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">sigma_n</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function to compute transect-level altimetric change statistics from the multitemporal table.</span>
<span class="sd">    By default, only sand points beyond LoD are accounted for. Optionally, LoD filter can be turned off.</span>
<span class="sd">    The table contains info on:</span>
<span class="sd">    - monitoring period: location code, full name, period code, transect ID, dates, number of days and valid points</span>
<span class="sd">    - absolute altimetric change: total profile rising, lowering and net change</span>
<span class="sd">    - normalised altimetric change: meters of rising, lowering and net elevation change per valid survey point (MEC)</span>

<span class="sd">    Args:</span>
<span class="sd">        sand_pts (pd.DataFrame): Multitemporal dh table.</span>
<span class="sd">        lod (str, float, False): If valid path to an LoD table, use the table. If a value is provided, use the value across all surveys. If False, do not apply LoD filter. All elevation change (dh) values within LoD will be set to zero.</span>
<span class="sd">        dx (int,float): The along-transect point spacing.</span>
<span class="sd">        full_specs_table (str, pd.DataFRame, bool): Full path to the table with extended monitoring info or the table itself. If False, monitoring period information are limited.</span>
<span class="sd">        outliers: when True, use the specified number of standard deviation to exclude outliers. If False, retain all the points.</span>
<span class="sd">        sigma_n (int): number of standard deviation to use to exclude outliers (default=3).</span>

<span class="sd">    Returns:</span>
<span class="sd">        volumetrics_transects (pd.DataFrame): A dataframe storing altimetric beach change info at the transect level, and other information for every period and location.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">transects_df_full</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>

    <span class="n">locs</span> <span class="o">=</span> <span class="n">sand_pts</span><span class="o">.</span><span class="n">location</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">full_specs_table</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">bool</span><span class="p">(</span><span class="n">full_specs_table</span><span class="p">)</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">skip_details</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Please provide the path to the specs table.&quot;</span><span class="p">)</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">full_specs_table</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">full_specs_table</span><span class="p">):</span>
            <span class="n">table_details</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">full_specs_table</span><span class="p">)</span>
            <span class="n">skip_details</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Not a valid path to the .csv file for the specs table.&quot;</span><span class="p">)</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">full_specs_table</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
        <span class="n">table_details</span> <span class="o">=</span> <span class="n">full_specs_table</span>
        <span class="n">skip_details</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Not a valid path to the .csv file for the specs table.&quot;</span><span class="p">)</span>


    <span class="k">for</span> <span class="n">loc</span> <span class="ow">in</span> <span class="n">locs</span><span class="p">:</span>

        <span class="n">test_loc</span> <span class="o">=</span> <span class="n">sand_pts</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;location == &#39;</span><span class="si">{</span><span class="n">loc</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">dt</span> <span class="ow">in</span> <span class="n">test_loc</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">unique</span><span class="p">():</span>
            <span class="n">test_dt</span> <span class="o">=</span> <span class="n">test_loc</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot; dt ==&#39;</span><span class="si">{</span><span class="n">dt</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>
            <span class="n">data_in</span> <span class="o">=</span> <span class="n">prep_heatmap</span><span class="p">(</span><span class="n">test_dt</span><span class="p">,</span> <span class="n">lod</span><span class="p">,</span> <span class="n">outliers</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sigma_n</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>

            <span class="n">tr_ids</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">data_in</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">skip_details</span> <span class="o">!=</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">specs</span> <span class="o">=</span> <span class="n">table_details</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;location==&#39;</span><span class="si">{</span><span class="n">loc</span><span class="si">}</span><span class="s2">&#39; &amp; dt==&#39;</span><span class="si">{</span><span class="n">dt</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>
                <span class="n">full_loc</span> <span class="o">=</span> <span class="n">specs</span><span class="o">.</span><span class="n">loc_full</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">date_from</span> <span class="o">=</span> <span class="n">specs</span><span class="o">.</span><span class="n">date_pre</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">date_to</span> <span class="o">=</span> <span class="n">specs</span><span class="o">.</span><span class="n">date_post</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">n_days</span> <span class="o">=</span> <span class="n">specs</span><span class="o">.</span><span class="n">n_days</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">pass</span>

            <span class="n">trs_volumes</span> <span class="o">=</span> <span class="n">data_in</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">interpol_integrate</span><span class="p">,</span> <span class="o">**</span><span class="p">{</span><span class="s1">&#39;dx&#39;</span><span class="p">:</span><span class="n">dx</span><span class="p">},</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">trs_volumes</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;tot_vol_change&quot;</span>
            <span class="n">beach_lengths</span> <span class="o">=</span> <span class="n">data_in</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">get_beachface_length</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

            <span class="n">tr_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">trs_volumes</span><span class="p">)</span>
            <span class="c1"># normalise the volume change computed in the transect by its cross-shore</span>
            <span class="c1"># length</span>
            <span class="n">tr_df</span><span class="p">[</span><span class="s2">&quot;m3_m&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">trs_volumes</span><span class="o">.</span><span class="n">values</span> <span class="o">*</span> <span class="n">transect_spacing</span>
            <span class="p">)</span> <span class="o">/</span> <span class="n">beach_lengths</span><span class="o">.</span><span class="n">values</span>
            <span class="n">tr_df</span> <span class="o">=</span> <span class="n">tr_df</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
            <span class="n">tr_df</span><span class="o">.</span><span class="n">rename</span><span class="p">({</span><span class="s2">&quot;int_tr&quot;</span><span class="p">:</span> <span class="s2">&quot;tr_id&quot;</span><span class="p">},</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="n">tr_df</span><span class="p">[</span><span class="s2">&quot;n_obs_valid&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_in</span><span class="o">.</span><span class="n">count</span><span class="p">()</span><span class="o">.</span><span class="n">values</span>
            <span class="n">tr_df</span><span class="p">[</span><span class="s2">&quot;abs_in&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_in</span><span class="p">[</span><span class="n">data_in</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">.</span><span class="n">values</span>
            <span class="n">tr_df</span><span class="p">[</span><span class="s2">&quot;abs_out&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_in</span><span class="p">[</span><span class="n">data_in</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">.</span><span class="n">values</span>
            <span class="n">tr_df</span><span class="p">[</span><span class="s2">&quot;abs_net_change&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_in</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">.</span><span class="n">values</span>

            <span class="n">tr_df</span><span class="p">[</span><span class="s2">&quot;mec_m&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tr_df</span><span class="o">.</span><span class="n">abs_net_change</span><span class="o">.</span><span class="n">values</span> <span class="o">/</span> <span class="n">beach_lengths</span><span class="o">.</span><span class="n">values</span>

            <span class="n">tr_df</span><span class="p">[</span><span class="s2">&quot;norm_in&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tr_df</span><span class="o">.</span><span class="n">abs_in</span><span class="o">.</span><span class="n">values</span> <span class="o">/</span> <span class="n">tr_df</span><span class="o">.</span><span class="n">n_obs_valid</span><span class="o">.</span><span class="n">values</span>
            <span class="n">tr_df</span><span class="p">[</span><span class="s2">&quot;norm_out&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tr_df</span><span class="o">.</span><span class="n">abs_out</span><span class="o">.</span><span class="n">values</span> <span class="o">/</span> <span class="n">tr_df</span><span class="o">.</span><span class="n">n_obs_valid</span><span class="o">.</span><span class="n">values</span>
            <span class="n">tr_df</span><span class="p">[</span><span class="s2">&quot;norm_net_change&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">tr_df</span><span class="o">.</span><span class="n">abs_net_change</span><span class="o">.</span><span class="n">values</span> <span class="o">/</span> <span class="n">tr_df</span><span class="o">.</span><span class="n">n_obs_valid</span><span class="o">.</span><span class="n">values</span>
            <span class="p">)</span>

            <span class="n">tr_df</span><span class="p">[</span><span class="s2">&quot;dt&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dt</span>
            <span class="n">tr_df</span><span class="p">[</span><span class="s2">&quot;location&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">loc</span>

            <span class="k">if</span> <span class="n">skip_details</span> <span class="o">!=</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">tr_df</span><span class="p">[</span><span class="s2">&quot;location_full&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">full_loc</span>
                <span class="n">tr_df</span><span class="p">[</span><span class="s2">&quot;date_from&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">date_from</span>
                <span class="n">tr_df</span><span class="p">[</span><span class="s2">&quot;date_to&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">date_to</span>
                <span class="n">tr_df</span><span class="p">[</span><span class="s2">&quot;n_days&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">n_days</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">pass</span>

            <span class="n">transects_df_full</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">tr_df</span><span class="p">,</span> <span class="n">transects_df_full</span><span class="p">],</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">transects_df_full</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 class="doc doc-heading" id="sandpyper.common.getAngle">
<code class="highlight language-python"><span class="n">getAngle</span><span class="p">(</span><span class="n">pt1</span><span class="p">,</span> <span class="n">pt2</span><span class="p">)</span></code>


<a class="headerlink" href="#sandpyper.common.getAngle" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Helper function to return the angle of two points (pt1 and pt2) coordinates in degrees.
Source: http://wikicode.wikidot.com/get-angle-of-line-between-two-points</p>

        <details class="quote">
          <summary>Source code in <code>sandpyper\common.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">getAngle</span><span class="p">(</span><span class="n">pt1</span><span class="p">,</span> <span class="n">pt2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Helper function to return the angle of two points (pt1 and pt2) coordinates in degrees.</span>
<span class="sd">    Source: http://wikicode.wikidot.com/get-angle-of-line-between-two-points&quot;&quot;&quot;</span>

    <span class="n">x_diff</span> <span class="o">=</span> <span class="n">pt2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">pt1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">y_diff</span> <span class="o">=</span> <span class="n">pt2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">pt1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">atan2</span><span class="p">(</span><span class="n">y_diff</span><span class="p">,</span> <span class="n">x_diff</span><span class="p">))</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 class="doc doc-heading" id="sandpyper.common.getCrs_from_raster_path">
<code class="highlight language-python"><span class="n">getCrs_from_raster_path</span><span class="p">(</span><span class="n">ras_path</span><span class="p">)</span></code>


<a class="headerlink" href="#sandpyper.common.getCrs_from_raster_path" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Returns the EPSG code of the input raster (geotiff).</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>ras_path</code></td>
        <td><code>str</code></td>
        <td><p>Path of the raster.</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>epsg_code (int)</code></td>
      <td><p>EPSG code of the input raster.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>sandpyper\common.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">getCrs_from_raster_path</span><span class="p">(</span><span class="n">ras_path</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns the EPSG code of the input raster (geotiff).</span>

<span class="sd">    Args:</span>
<span class="sd">        ras_path (str): Path of the raster.</span>

<span class="sd">    Returns:</span>
<span class="sd">        epsg_code (int): EPSG code of the input raster.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">with</span> <span class="n">ras</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ras_path</span><span class="p">))</span> <span class="k">as</span> <span class="n">raster</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">raster</span><span class="o">.</span><span class="n">crs</span><span class="o">.</span><span class="n">to_epsg</span><span class="p">()</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 class="doc doc-heading" id="sandpyper.common.getCrs_from_transect">
<code class="highlight language-python"><span class="n">getCrs_from_transect</span><span class="p">(</span><span class="n">trs_path</span><span class="p">)</span></code>


<a class="headerlink" href="#sandpyper.common.getCrs_from_transect" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Returns the EPSG code of the input transect file (geopackage).</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>trs_path</code></td>
        <td><code>str</code></td>
        <td><p>Path of the transect file.</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>epsg_code (int)</code></td>
      <td><p>EPSG code of the input transect file.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>sandpyper\common.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">getCrs_from_transect</span><span class="p">(</span><span class="n">trs_path</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns the EPSG code of the input transect file (geopackage).</span>

<span class="sd">    Args:</span>
<span class="sd">        trs_path (str): Path of the transect file.</span>

<span class="sd">    Returns:</span>
<span class="sd">        epsg_code (int): EPSG code of the input transect file.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="n">trs_path</span><span class="p">)</span><span class="o">.</span><span class="n">crs</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 class="doc doc-heading" id="sandpyper.common.getDate">
<code class="highlight language-python"><span class="n">getDate</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span></code>


<a class="headerlink" href="#sandpyper.common.getDate" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Returns the date in raw form (i.e 20180912) from already formatted filenames.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>filename</code></td>
        <td><code>str</code></td>
        <td><p>filename (i.e. apo_20180912_dsm_ahd.tiff).</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>str </code></td>
      <td><p>raw date.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>sandpyper\common.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">getDate</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the date in raw form (i.e 20180912) from already formatted filenames.</span>

<span class="sd">    Args:</span>
<span class="sd">        filename (str): filename (i.e. apo_20180912_dsm_ahd.tiff).</span>

<span class="sd">    Returns:</span>
<span class="sd">        str : raw date.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># get the date out of a file input</span>

    <span class="n">num_ditis</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\\</span><span class="s2">d+&quot;</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>

    <span class="c1"># now we need to convert each number into integer. int(string) converts string into integer</span>
    <span class="c1"># we will map int() function onto all elements of numbers list</span>
    <span class="n">num_ditis</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">num_ditis</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">date_</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">num_ditis</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">date_</span><span class="p">))</span> <span class="o">==</span> <span class="mi">8</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">date_</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unable to find correct date from input filename. Found: </span><span class="si">{</span><span class="n">date_</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">BaseException</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No numbers in the input filename.&quot;</span><span class="p">))</span>

    <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">num_ditis</span><span class="p">)</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 class="doc doc-heading" id="sandpyper.common.getListOfDate">
<code class="highlight language-python"><span class="n">getListOfDate</span><span class="p">(</span><span class="n">list_dsm</span><span class="p">)</span></code>


<a class="headerlink" href="#sandpyper.common.getListOfDate" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Returns the a list of raw dates (i.e 20180912) from a list of formatted filenames.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>list_dsm</code></td>
        <td><code>list</code></td>
        <td><p>list of filenames of DSM or rothophotos datasets.</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>list </code></td>
      <td><p>raw dates.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>sandpyper\common.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">getListOfDate</span><span class="p">(</span><span class="n">list_dsm</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the a list of raw dates (i.e 20180912) from a list of formatted filenames.</span>

<span class="sd">    Args:</span>
<span class="sd">        list_dsm (list): list of filenames of DSM or rothophotos datasets.</span>

<span class="sd">    Returns:</span>
<span class="sd">        list : raw dates.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dates</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">list_dsm</span><span class="p">:</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="n">getDate</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">dates</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dates</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 class="doc doc-heading" id="sandpyper.common.getListOfFiles">
<code class="highlight language-python"><span class="n">getListOfFiles</span><span class="p">(</span><span class="n">dirName</span><span class="p">)</span></code>


<a class="headerlink" href="#sandpyper.common.getListOfFiles" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Function to create a list of files from a folder path, including sub folders.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>dirName</code></td>
        <td><code>str</code></td>
        <td><p>Path of the parent directory.</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>allFiles </code></td>
      <td><p>list of full paths of all files found.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>sandpyper\common.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">getListOfFiles</span><span class="p">(</span><span class="n">dirName</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function to create a list of files from a folder path, including sub folders.</span>

<span class="sd">    Args:</span>
<span class="sd">        dirName (str): Path of the parent directory.</span>

<span class="sd">    Returns:</span>
<span class="sd">        allFiles : list of full paths of all files found.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># create a list of file and sub directories names in the given directory</span>
    <span class="n">listOfFile</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">dirName</span><span class="p">)</span>
    <span class="n">allFiles</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>  <span class="c1"># Iterate over all the entries</span>
    <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">listOfFile</span><span class="p">:</span>

        <span class="n">fullPath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dirName</span><span class="p">,</span> <span class="n">entry</span><span class="p">)</span>  <span class="c1"># Create full path</span>

        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span>
            <span class="n">fullPath</span>
        <span class="p">):</span>  <span class="c1"># If entry is a directory then get the list of files in this directory</span>
            <span class="n">allFiles</span> <span class="o">=</span> <span class="n">allFiles</span> <span class="o">+</span> <span class="n">getListOfFiles</span><span class="p">(</span><span class="n">fullPath</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">allFiles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fullPath</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">allFiles</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 class="doc doc-heading" id="sandpyper.common.getLoc">
<code class="highlight language-python"><span class="n">getLoc</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">list_loc_codes</span><span class="p">)</span></code>


<a class="headerlink" href="#sandpyper.common.getLoc" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Function that returns the location code from properly formatted (see documentation) filenames.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>filename</code></td>
        <td><code>str</code></td>
        <td><p>filename (i.e. apo_20180912_dsm_ahd.tiff).</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>list_loc_codes</code></td>
        <td><code>list</code></td>
        <td><p>list of strings containing location codes.</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>str </code></td>
      <td><p>location codes.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>sandpyper\common.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">getLoc</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">list_loc_codes</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function that returns the location code from properly formatted (see documentation) filenames.</span>

<span class="sd">    Args:</span>
<span class="sd">        filename (str): filename (i.e. apo_20180912_dsm_ahd.tiff).</span>
<span class="sd">        list_loc_codes (list): list of strings containing location codes.</span>

<span class="sd">    Returns:</span>
<span class="sd">        str : location codes.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="nb">next</span><span class="p">((</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">list_loc_codes</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">filename</span><span class="p">),</span> <span class="kc">False</span><span class="p">)</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 class="doc doc-heading" id="sandpyper.common.getPoint1">
<code class="highlight language-python"><span class="n">getPoint1</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="n">bearing</span><span class="p">,</span> <span class="n">dist</span><span class="p">)</span></code>


<a class="headerlink" href="#sandpyper.common.getPoint1" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Helper function to return the point coordinates at a determined distance (dist) and bearing from a starting point (pt).</p>

        <details class="quote">
          <summary>Source code in <code>sandpyper\common.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">getPoint1</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="n">bearing</span><span class="p">,</span> <span class="n">dist</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Helper function to return the point coordinates at a determined distance (dist) and bearing from a starting point (pt).&quot;&quot;&quot;</span>

    <span class="n">angle</span> <span class="o">=</span> <span class="n">bearing</span> <span class="o">+</span> <span class="mi">90</span>
    <span class="n">bearing</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">dist</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">bearing</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">dist</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">bearing</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Point</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
</code></pre></div>
        </details>
    </div>

  </div>




  <div class="doc doc-object doc-function">



<h2 class="doc doc-heading" id="sandpyper.common.grid_from_pts">
<code class="highlight language-python"><span class="n">grid_from_pts</span><span class="p">(</span><span class="n">pts_gdf</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">crs</span><span class="p">,</span> <span class="n">offsets</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span></code>


<a class="headerlink" href="#sandpyper.common.grid_from_pts" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Create a georeferenced grid of polygones from points along a line (shoreline).
Used to extract tiles (images patches) from rasters.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>pts_gdf</code></td>
        <td><code>gpd.GeoDataFrame</code></td>
        <td><p>The geodataframe storing points along a shoreline.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>height</code></td>
        <td><code>int,float</code></td>
        <td><p>The height of each single tile of the grid, given in the CRS unit (use projected CRS).</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>crs</code></td>
        <td><code>str</code></td>
        <td><p>Coordinate Reference System in the dictionary format (example: {'init' :'epsg:4326'})</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>offsets</code></td>
        <td><code>tuple</code></td>
        <td><p>Offsets in meters (needs projected CRS) from the bounds of the pts_gdf, in the form of (xmin, ymin, xmax, ymax). Default to (0,0,0,0).</p></td>
        <td><code>(0, 0, 0, 0)</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>Grid (gpd.GeoDataFrame)</code></td>
      <td><p>A GeoDataFrame storing polygon grids, with IDs and geometry columns.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>sandpyper\common.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">grid_from_pts</span><span class="p">(</span><span class="n">pts_gdf</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">crs</span><span class="p">,</span> <span class="n">offsets</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a georeferenced grid of polygones from points along a line (shoreline).</span>
<span class="sd">    Used to extract tiles (images patches) from rasters.</span>
<span class="sd">    Args:</span>
<span class="sd">        pts_gdf (gpd.GeoDataFrame): The geodataframe storing points along a shoreline.</span>
<span class="sd">        width (int, float) The width of each single tile of the grid, given in the CRS unit (use projected CRS).</span>
<span class="sd">        height (int,float): The height of each single tile of the grid, given in the CRS unit (use projected CRS).</span>
<span class="sd">        crs (str): Coordinate Reference System in the dictionary format (example: {&#39;init&#39; :&#39;epsg:4326&#39;})</span>
<span class="sd">        offsets (tuple): Offsets in meters (needs projected CRS) from the bounds of the pts_gdf, in the form of (xmin, ymin, xmax, ymax). Default to (0,0,0,0).</span>
<span class="sd">    Returns:</span>
<span class="sd">        Grid (gpd.GeoDataFrame): A GeoDataFrame storing polygon grids, with IDs and geometry columns.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">xmin</span><span class="p">,</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">ymax</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">add</span><span class="p">,</span> <span class="n">pts_gdf</span><span class="o">.</span><span class="n">total_bounds</span><span class="p">,</span> <span class="n">offsets</span><span class="p">))</span>

    <span class="n">rows</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="n">ymax</span> <span class="o">-</span> <span class="n">ymin</span><span class="p">)</span> <span class="o">/</span> <span class="n">height</span><span class="p">))</span>
    <span class="n">cols</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="n">xmax</span> <span class="o">-</span> <span class="n">xmin</span><span class="p">)</span> <span class="o">/</span> <span class="n">width</span><span class="p">))</span>

    <span class="n">XleftOrigin</span> <span class="o">=</span> <span class="n">xmin</span>
    <span class="n">XrightOrigin</span> <span class="o">=</span> <span class="n">xmin</span> <span class="o">+</span> <span class="n">width</span>
    <span class="n">YtopOrigin</span> <span class="o">=</span> <span class="n">ymax</span>
    <span class="n">YbottomOrigin</span> <span class="o">=</span> <span class="n">ymax</span> <span class="o">-</span> <span class="n">height</span>
    <span class="n">polygons</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cols</span><span class="p">):</span>
        <span class="n">Ytop</span> <span class="o">=</span> <span class="n">YtopOrigin</span>
        <span class="n">Ybottom</span> <span class="o">=</span> <span class="n">YbottomOrigin</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">rows</span><span class="p">):</span>
            <span class="n">polygons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">Polygon</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="p">(</span><span class="n">XleftOrigin</span><span class="p">,</span> <span class="n">Ytop</span><span class="p">),</span>
                        <span class="p">(</span><span class="n">XrightOrigin</span><span class="p">,</span> <span class="n">Ytop</span><span class="p">),</span>
                        <span class="p">(</span><span class="n">XrightOrigin</span><span class="p">,</span> <span class="n">Ybottom</span><span class="p">),</span>
                        <span class="p">(</span><span class="n">XleftOrigin</span><span class="p">,</span> <span class="n">Ybottom</span><span class="p">),</span>
                    <span class="p">]</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="n">Ytop</span> <span class="o">=</span> <span class="n">Ytop</span> <span class="o">-</span> <span class="n">height</span>
            <span class="n">Ybottom</span> <span class="o">=</span> <span class="n">Ybottom</span> <span class="o">-</span> <span class="n">height</span>
        <span class="n">XleftOrigin</span> <span class="o">=</span> <span class="n">XleftOrigin</span> <span class="o">+</span> <span class="n">width</span>
        <span class="n">XrightOrigin</span> <span class="o">=</span> <span class="n">XrightOrigin</span> <span class="o">+</span> <span class="n">width</span>

    <span class="n">grid</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span>
        <span class="p">{</span><span class="s2">&quot;grid_id&quot;</span><span class="p">:</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">polygons</span><span class="p">)),</span> <span class="s2">&quot;geometry&quot;</span><span class="p">:</span> <span class="n">polygons</span><span class="p">},</span> <span class="n">crs</span><span class="o">=</span><span class="n">crs</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">grid</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 class="doc doc-heading" id="sandpyper.common.grid_from_shore">
<code class="highlight language-python"><span class="n">grid_from_shore</span><span class="p">(</span><span class="n">shore</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">location_code</span><span class="p">,</span> <span class="n">adj_order</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">crs</span><span class="o">=</span><span class="s1">&#39;shore&#39;</span><span class="p">,</span> <span class="n">shore_res</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">offsets</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">plot_it</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></code>


<a class="headerlink" href="#sandpyper.common.grid_from_shore" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Create a georeference grid of equal polygones (tiles) along a line (shoreline) and select those tiles that contain or are adjacent to the shoreline.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>shore</code></td>
        <td><code>geodataframe</code></td>
        <td><p>The geodataframe storing the input line from where the grid will be created.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>width,</code></td>
        <td><code>height (int,float</code></td>
        <td><p>The width and height of each single tile of the grid, given in the CRS unit (use projected CRS).</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>location_code</code></td>
        <td><code>str</code></td>
        <td><p>The location code associated with the grid.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>adj_order</code></td>
        <td><code>False, int</code></td>
        <td><p>Contiguity order to subset grid cells adjacent to shoreline. If False, only cells
directly touching the shoreline will be extracted (Default=1). Note: The Pysal Queen method is used to compute neighbors.
For more info: https://pysal.org/libpysal/generated/libpysal.weights.Queen.html#libpysal.weights.Queen</p></td>
        <td><code>1</code></td>
      </tr>
      <tr>
        <td><code>crs</code></td>
        <td><code>dict or &#39;shore&#39;</code></td>
        <td><p>If 'shore', use the same CRS of the input line. If dict, keys should be the location code and values the values crs in the dictionary format ('wbl' : {'init' :'epsg:32754'}).</p></td>
        <td><code>&#39;shore&#39;</code></td>
      </tr>
      <tr>
        <td><code>shore_res</code></td>
        <td><code>int,float</code></td>
        <td><p>the alongshore spacing of points plotted along the line in the CRS unit (default=10). It doesn't need to be a small value, it is used to get the extent of the bounding box that encapsulate all the shoreline, before split this into a grid.</p></td>
        <td><code>10</code></td>
      </tr>
      <tr>
        <td><code>offsets</code></td>
        <td><code>tuple</code></td>
        <td><p>Offsets in meters (needs projected CRS) from the bounds of the pts_gdf,
in the form of (xmin, ymin, xmax, ymax). Default to (0,0,0,0).</p></td>
        <td><code>(0, 0, 0, 0)</code></td>
      </tr>
      <tr>
        <td><code>plot_it</code></td>
        <td><code>bool</code></td>
        <td><p>plot the shoreline, full grid and the tiles selected containing the lien (in red). Default to True.</p></td>
        <td><code>True</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>gpd.GeoDataFrame</code></td>
      <td><p>Grid of tiles in the specified proximity of the shoreline.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>sandpyper\common.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">grid_from_shore</span><span class="p">(</span>
    <span class="n">shore</span><span class="p">,</span>
    <span class="n">width</span><span class="p">,</span>
    <span class="n">height</span><span class="p">,</span>
    <span class="n">location_code</span><span class="p">,</span>
    <span class="n">adj_order</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">crs</span><span class="o">=</span><span class="s2">&quot;shore&quot;</span><span class="p">,</span>
    <span class="n">shore_res</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
    <span class="n">offsets</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
    <span class="n">plot_it</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a georeference grid of equal polygones (tiles) along a line (shoreline) and select those tiles that contain or are adjacent to the shoreline.</span>

<span class="sd">    Args:</span>
<span class="sd">        shore (geodataframe): The geodataframe storing the input line from where the grid will be created.</span>
<span class="sd">        width, height (int,float): The width and height of each single tile of the grid, given in the CRS unit (use projected CRS).</span>
<span class="sd">        location_code (str): The location code associated with the grid.</span>
<span class="sd">        adj_order (False, int): Contiguity order to subset grid cells adjacent to shoreline. If False, only cells</span>
<span class="sd">            directly touching the shoreline will be extracted (Default=1). Note: The Pysal Queen method is used to compute neighbors.</span>
<span class="sd">            For more info: https://pysal.org/libpysal/generated/libpysal.weights.Queen.html#libpysal.weights.Queen</span>
<span class="sd">        crs (dict or &#39;shore&#39;): If &#39;shore&#39;, use the same CRS of the input line. If dict, keys should be the location code and values the values crs in the dictionary format (&#39;wbl&#39; : {&#39;init&#39; :&#39;epsg:32754&#39;}).</span>
<span class="sd">        shore_res (int,float): the alongshore spacing of points plotted along the line in the CRS unit (default=10). It doesn&#39;t need to be a small value, it is used to get the extent of the bounding box that encapsulate all the shoreline, before split this into a grid.</span>
<span class="sd">        offsets (tuple): Offsets in meters (needs projected CRS) from the bounds of the pts_gdf,</span>
<span class="sd">            in the form of (xmin, ymin, xmax, ymax). Default to (0,0,0,0).</span>
<span class="sd">        plot_it (bool): plot the shoreline, full grid and the tiles selected containing the lien (in red). Default to True.</span>

<span class="sd">    Returns:</span>
<span class="sd">        gpd.GeoDataFrame: Grid of tiles in the specified proximity of the shoreline.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">xs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">ys</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">points</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">distance</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span>
        <span class="mi">0</span><span class="p">,</span> <span class="n">shore</span><span class="o">.</span><span class="n">length</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">shore_res</span>
    <span class="p">):</span>  <span class="c1"># shore_res: meters alongshroe to get points from shore</span>
        <span class="n">pt</span> <span class="o">=</span> <span class="n">shore</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">distance</span><span class="p">)</span>
        <span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pt</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">xs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pt</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
        <span class="n">ys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pt</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>

    <span class="n">pts</span> <span class="o">=</span> <span class="p">[[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">)]</span>
    <span class="n">pts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pts</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">crs</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="n">crs_in</span> <span class="o">=</span> <span class="n">crs</span><span class="p">[</span><span class="n">location_code</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">crs</span> <span class="o">==</span> <span class="s2">&quot;shore&quot;</span><span class="p">:</span>
        <span class="n">crs_in</span> <span class="o">=</span> <span class="n">shore</span><span class="o">.</span><span class="n">crs</span>

    <span class="n">points_gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span>
        <span class="p">{</span><span class="s2">&quot;local_id&quot;</span><span class="p">:</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)),</span> <span class="s2">&quot;geometry&quot;</span><span class="p">:</span> <span class="n">points</span><span class="p">},</span>
        <span class="n">geometry</span><span class="o">=</span><span class="s2">&quot;geometry&quot;</span><span class="p">,</span>
        <span class="n">crs</span><span class="o">=</span><span class="n">crs_in</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">grid</span> <span class="o">=</span> <span class="n">grid_from_pts</span><span class="p">(</span><span class="n">points_gdf</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">crs</span><span class="o">=</span><span class="n">crs_in</span><span class="p">,</span> <span class="n">offsets</span><span class="o">=</span><span class="n">offsets</span><span class="p">)</span>

    <span class="c1"># select grid cells that contains shoreline points</span>
    <span class="n">shore_grids</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[</span>
        <span class="n">grid</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">points_gdf</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">intersects</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">())</span>
    <span class="p">]</span>

    <span class="k">if</span> <span class="n">adj_order</span> <span class="o">!=</span> <span class="kc">False</span><span class="p">:</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">Queen</span><span class="o">.</span><span class="n">from_dataframe</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="s2">&quot;geometry&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">adj_order</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Higher order (</span><span class="si">{</span><span class="n">adj_order</span><span class="si">}</span><span class="s2">) selected.&quot;</span><span class="p">)</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">higher_order</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">adj_order</span><span class="p">)</span>

            <span class="n">df_adjc</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="n">to_adjlist</span><span class="p">()</span>

            <span class="c1"># get the unique neighbors of all focal cells</span>
            <span class="n">qee_polys_ids</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span>
                <span class="n">df_adjc</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;focal in </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">shore_grids</span><span class="o">.</span><span class="n">grid_id</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">neighbor</span>
            <span class="p">)</span>

            <span class="c1"># subset grid based on qee_polys_ids</span>
            <span class="n">shore_grids</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;grid_id in </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">qee_polys_ids</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">pass</span>

    <span class="k">if</span> <span class="nb">bool</span><span class="p">(</span><span class="n">plot_it</span><span class="p">):</span>
        <span class="n">f</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>

        <span class="n">grid</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="s2">&quot;white&quot;</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>
        <span class="n">shore</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;b&quot;</span><span class="p">)</span>
        <span class="n">shore_grids</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">boundary</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
            <span class="n">color</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span>
        <span class="p">)</span>

    <span class="n">add_grid_loc_coords</span><span class="p">(</span><span class="n">shore_grids</span><span class="p">,</span> <span class="n">location</span><span class="o">=</span><span class="n">location_code</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">shore_grids</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 class="doc doc-heading" id="sandpyper.common.images_to_dirs">
<code class="highlight language-python"><span class="n">images_to_dirs</span><span class="p">(</span><span class="n">images_folder</span><span class="p">,</span> <span class="n">target_folder</span><span class="p">,</span> <span class="n">op</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>


<a class="headerlink" href="#sandpyper.common.images_to_dirs" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Create one folder per image named as the image. Optionally, move image into it.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>images_folder</code></td>
        <td><code>str</code></td>
        <td><p>path to the directory where the images are stored.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>target_folder</code></td>
        <td><code>str</code></td>
        <td><p>target path where create subfolders named as the images.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>op</code></td>
        <td><code>None, &#34;copy&#34;, &#34;move&#34;</code></td>
        <td><p>Move or copy the images into the newly created folders. None, creates empty subfolders.</p></td>
        <td><code>None</code></td>
      </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>sandpyper\common.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">images_to_dirs</span><span class="p">(</span><span class="n">images_folder</span><span class="p">,</span> <span class="n">target_folder</span><span class="p">,</span> <span class="n">op</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Create one folder per image named as the image. Optionally, move image into it.</span>

<span class="sd">    Args:</span>
<span class="sd">        images_folder (str): path to the directory where the images are stored.</span>
<span class="sd">        target_folder (str): target path where create subfolders named as the images.</span>
<span class="sd">        op (None, &quot;copy&quot;, &quot;move&quot;): Move or copy the images into the newly created folders. None, creates empty subfolders.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">images</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">images_folder</span><span class="p">)</span>
    <span class="n">original_images_paths</span> <span class="o">=</span> <span class="p">[</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">images_folder</span><span class="p">,</span> <span class="n">image</span><span class="p">)</span> <span class="k">for</span> <span class="n">image</span> <span class="ow">in</span> <span class="n">images</span><span class="p">]</span>
    <span class="n">ids</span> <span class="o">=</span> <span class="p">[</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">image</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">image</span> <span class="ow">in</span> <span class="n">images</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">op</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">target_images_paths</span> <span class="o">=</span> <span class="p">[</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">target_folder</span><span class="p">,</span> <span class="n">id_in</span><span class="p">)</span> <span class="k">for</span> <span class="n">id_in</span> <span class="ow">in</span> <span class="n">ids</span><span class="p">]</span>
    <span class="c1"># create ID-folders in target_parent_folder, named as image names</span>

    <span class="n">starting_wd</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span>  <span class="c1"># store starting working directory</span>

    <span class="n">os</span><span class="o">.</span><span class="n">chdir</span><span class="p">(</span><span class="n">target_folder</span><span class="p">)</span>  <span class="c1"># change working dir</span>

    <span class="k">if</span> <span class="n">op</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">id_i</span> <span class="ow">in</span> <span class="n">ids</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">target_folder</span><span class="p">,</span> <span class="n">id_i</span><span class="p">)):</span>
                <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">id_i</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">id_i</span><span class="si">}</span><span class="s2"> exists already. Skipping this one.&quot;</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">op</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>

        <span class="k">for</span> <span class="n">id_i</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">destination</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
            <span class="n">ids</span><span class="p">,</span> <span class="n">original_images_paths</span><span class="p">,</span> <span class="n">target_images_paths</span>
        <span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">target_folder</span><span class="p">,</span> <span class="n">id_i</span><span class="p">)):</span>
                <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">id_i</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">op</span> <span class="o">==</span> <span class="s2">&quot;move&quot;</span><span class="p">:</span>
                    <span class="n">move</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">destination</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">op</span> <span class="o">==</span> <span class="s2">&quot;copy&quot;</span><span class="p">:</span>
                    <span class="n">copy</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">destination</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;op parameter not set. &#39;move&#39; to move images into newly created folders, &#39;copy&#39; to copy them or None to only create folders.&quot;</span>
                    <span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">id_i</span><span class="si">}</span><span class="s2"> exists already. </span><span class="si">{</span><span class="n">op</span><span class="si">}</span><span class="s2"> only.&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">op</span> <span class="o">==</span> <span class="s2">&quot;move&quot;</span><span class="p">:</span>
                    <span class="n">move</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">destination</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">op</span> <span class="o">==</span> <span class="s2">&quot;copy&quot;</span><span class="p">:</span>
                    <span class="n">copy</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">destination</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;op parameter not set. &#39;move&#39; to move images into newly created folders, &#39;copy&#39; to copy them or None to only create folders.&quot;</span>
        <span class="p">)</span>

    <span class="n">os</span><span class="o">.</span><span class="n">chdir</span><span class="p">(</span><span class="n">starting_wd</span><span class="p">)</span>  <span class="c1"># returning to starting working dir</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Successfully created </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">ids</span><span class="p">)</span><span class="si">}</span><span class="s2"> ID-folders in </span><span class="si">{</span><span class="n">target_folder</span><span class="si">}</span><span class="s2"> .&quot;</span><span class="p">)</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 class="doc doc-heading" id="sandpyper.common.interpol_integrate">
<code class="highlight language-python"><span class="n">interpol_integrate</span><span class="p">(</span><span class="n">series</span><span class="p">,</span> <span class="n">dx</span><span class="p">)</span></code>


<a class="headerlink" href="#sandpyper.common.interpol_integrate" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Linearly interpolate NaN values (non-sand) within the first and last valid points (from the swash to the landward end of each transect),
and intergrate the area below this interoplated profile, to obtain transect specific estimates of volumetric change.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>series</code></td>
        <td><code>pd.Series</code></td>
        <td><p>Series of elevation change with distance as indices.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>dx</code></td>
        <td><code>int,float</code></td>
        <td><p>The along-transect point spacing.</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>integrated_area (float)</code></td>
      <td><p>Volumetric change in cubic meters.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>sandpyper\common.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">interpol_integrate</span><span class="p">(</span><span class="n">series</span><span class="p">,</span> <span class="n">dx</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Linearly interpolate NaN values (non-sand) within the first and last valid points (from the swash to the landward end of each transect),</span>
<span class="sd">    and intergrate the area below this interoplated profile, to obtain transect specific estimates of volumetric change.</span>
<span class="sd">    Args:</span>
<span class="sd">        series (pd.Series): Series of elevation change with distance as indices.</span>
<span class="sd">        dx (int,float): The along-transect point spacing.</span>
<span class="sd">    Returns:</span>
<span class="sd">        integrated_area (float): Volumetric change in cubic meters.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">min_dist</span><span class="p">,</span> <span class="n">max_dist</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">series</span><span class="o">.</span><span class="n">first_valid_index</span><span class="p">(),</span>
        <span class="n">series</span><span class="o">.</span><span class="n">last_valid_index</span><span class="p">(),</span>
    <span class="p">)</span>  <span class="c1"># get distances of first and last sand points</span>

    <span class="n">interpol</span> <span class="o">=</span> <span class="n">series</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">min_dist</span><span class="p">:</span><span class="n">max_dist</span><span class="p">]</span><span class="o">.</span><span class="n">interpolate</span><span class="p">()</span>  <span class="c1"># interpolate linearly</span>

    <span class="n">area_simps</span> <span class="o">=</span> <span class="n">simps</span><span class="p">(</span><span class="n">interpol</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">dx</span><span class="o">=</span><span class="n">dx</span><span class="p">)</span>  <span class="c1"># intergrate using Simpson&#39;s method</span>

    <span class="k">return</span> <span class="n">area_simps</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 class="doc doc-heading" id="sandpyper.common.kmeans_sa">
<code class="highlight language-python"><span class="n">kmeans_sa</span><span class="p">(</span><span class="n">merged_df</span><span class="p">,</span> <span class="n">ks</span><span class="p">,</span> <span class="n">feature_set</span><span class="p">,</span> <span class="n">thresh_k</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span></code>


<a class="headerlink" href="#sandpyper.common.kmeans_sa" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Function to use KMeans on all surveys with the optimal k obtained from the Silhouette Analysis.
It uses KMeans as a clusterer.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>merged_df</code></td>
        <td><code>Pandas dataframe</code></td>
        <td><p>The clean and merged dataframe containing the features. Must contain the columns point_id, location and survey_date, as well as the</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>ks</code></td>
        <td><code>int, dict</code></td>
        <td><p>number of clusters (k) or dictionary containing the optimal k for each survey. See get_opt_k function.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>feature_set</code></td>
        <td><code>list</code></td>
        <td><p>List of names of features in the dataframe to use for clustering.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>thresh_k</code></td>
        <td><code>int</code></td>
        <td><p>Minimim k to be used. If survey-specific optimal k is below this value, then k equals the average k of all above threshold values.</p></td>
        <td><code>5</code></td>
      </tr>
      <tr>
        <td><code>random_state</code></td>
        <td><code>int</code></td>
        <td><p>Random seed used to make the randomisation deterministic.</p></td>
        <td><code>10</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>data_classified (pd.DataFrame)</code></td>
      <td><p>A dataframe containing the label_k column, with point_id, location, survey_date and the features used to cluster the data.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>sandpyper\common.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">kmeans_sa</span><span class="p">(</span><span class="n">merged_df</span><span class="p">,</span> <span class="n">ks</span><span class="p">,</span> <span class="n">feature_set</span><span class="p">,</span> <span class="n">thresh_k</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function to use KMeans on all surveys with the optimal k obtained from the Silhouette Analysis.</span>
<span class="sd">    It uses KMeans as a clusterer.</span>

<span class="sd">    Args:</span>
<span class="sd">        merged_df (Pandas dataframe): The clean and merged dataframe containing the features. Must contain the columns point_id, location and survey_date, as well as the</span>
<span class="sd">        ks (int, dict): number of clusters (k) or dictionary containing the optimal k for each survey. See get_opt_k function.</span>
<span class="sd">        feature_set (list): List of names of features in the dataframe to use for clustering.</span>
<span class="sd">        thresh_k (int): Minimim k to be used. If survey-specific optimal k is below this value, then k equals the average k of all above threshold values.</span>
<span class="sd">        random_state (int): Random seed used to make the randomisation deterministic.</span>

<span class="sd">    Returns:</span>
<span class="sd">        data_classified (pd.DataFrame): A dataframe containing the label_k column, with point_id, location, survey_date and the features used to cluster the data.</span>
<span class="sd">    &quot;&quot;&quot;</span>


    <span class="n">merged_df</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">list_locs</span> <span class="o">=</span> <span class="n">merged_df</span><span class="o">.</span><span class="n">location</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>

    <span class="n">scaler</span> <span class="o">=</span> <span class="n">MinMaxScaler</span><span class="p">()</span>
    <span class="n">data_classified</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>

    <span class="c1"># Set a threshold k, in case a k is lower than 5, use the mean optimal k</span>
    <span class="c1"># of the other surveys above threshold</span>

    <span class="c1"># # Compute the mean optimal k of above threshold ks</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ks</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="n">arr_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ks</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">thresh_k</span><span class="p">])</span>
        <span class="n">mean_threshold_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">arr_k</span><span class="p">),</span> <span class="mi">0</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="k">for</span> <span class="n">location</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">list_locs</span><span class="p">):</span>

        <span class="n">list_dates</span> <span class="o">=</span> <span class="n">merged_df</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;location==&#39;</span><span class="si">{</span><span class="n">location</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">raw_date</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">survey_date_in</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">list_dates</span><span class="p">):</span>

            <span class="n">data_in</span> <span class="o">=</span> <span class="n">merged_df</span><span class="o">.</span><span class="n">query</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;location==&#39;</span><span class="si">{</span><span class="n">location</span><span class="si">}</span><span class="s2">&#39;&amp; raw_date == </span><span class="si">{</span><span class="n">survey_date_in</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="n">data_clean</span> <span class="o">=</span> <span class="n">data_in</span><span class="p">[</span><span class="n">feature_set</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">to_numeric</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ks</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="n">k</span> <span class="o">=</span> <span class="n">ks</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">location</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">survey_date_in</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">k</span><span class="o">=</span><span class="n">ks</span>

            <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">thresh_k</span><span class="p">:</span>
                <span class="n">k</span> <span class="o">=</span> <span class="n">mean_threshold_k</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">pass</span>

            <span class="n">minmax_scaled_df</span> <span class="o">=</span> <span class="n">scaler</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">data_clean</span><span class="p">))</span>

            <span class="n">clusterer</span> <span class="o">=</span> <span class="n">KMeans</span><span class="p">(</span>
                <span class="n">n_clusters</span><span class="o">=</span><span class="n">k</span><span class="p">,</span>
                <span class="n">init</span><span class="o">=</span><span class="s2">&quot;k-means++&quot;</span><span class="p">,</span>
                <span class="n">algorithm</span><span class="o">=</span><span class="s2">&quot;elkan&quot;</span><span class="p">,</span>
                <span class="n">tol</span><span class="o">=</span><span class="mf">0.0001</span><span class="p">,</span>
                <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="n">data_in</span><span class="p">[</span><span class="s2">&quot;label_k&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">clusterer</span><span class="o">.</span><span class="n">fit_predict</span><span class="p">(</span><span class="n">minmax_scaled_df</span><span class="p">)</span>

            <span class="n">data_classified</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span>
                <span class="p">[</span><span class="n">data_in</span><span class="p">,</span> <span class="n">data_classified</span><span class="p">],</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>

    <span class="k">return</span> <span class="n">data_classified</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 class="doc doc-heading" id="sandpyper.common.LISA_site_level">
<code class="highlight language-python"><span class="n">LISA_site_level</span><span class="p">(</span><span class="n">dh_df</span><span class="p">,</span> <span class="n">crs_dict_string</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">distance_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">decay</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">k_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">geometry_column</span><span class="o">=</span><span class="s1">&#39;geometry&#39;</span><span class="p">)</span></code>


<a class="headerlink" href="#sandpyper.common.LISA_site_level" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Performs Hot-Spot analysis using Local Moran's I as LISA for all the survey.
    Please refer to PySAL package documentation for more info.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>dh_df</code></td>
        <td><code>pd.DataFrame, str</code></td>
        <td><p>Pandas dataframe or local path of the timeseries files, as returned by the multitemporal extraction.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>crs_dict_string</code></td>
        <td><code>dict</code></td>
        <td><p>Dictionary storing location codes as key and crs information as EPSG code (int).</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>geometry_column</code></td>
        <td><code>str</code></td>
        <td><p>field storing the geometry column. If in string form (as loaded from a csv), it will be converted to Point objects. Default='coordinates'.</p></td>
        <td><code>&#39;geometry&#39;</code></td>
      </tr>
      <tr>
        <td><code>mode</code></td>
        <td><code>str</code></td>
        <td><p>If 'distance'(Default), compute spatial weight matrix using a distance-band kernel, specified in distance_value parameter.
                            If 'knn', spatial weight matrix uses a specified (k_value parameter) of k number closest points to compute weights.
                            if 'idw', Inverse Distance Weigthing is used with the specified decay power (decay parameter) to compute weight.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>distance_value</code></td>
        <td><code>int</code></td>
        <td><p>values in meters (crs must be projected) used as distance band for neigthours definition in distance weight matrix computation.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>decay</code></td>
        <td><code>int</code></td>
        <td><p>power of decay to use with IDW.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>k_value</code></td>
        <td><code>int</code></td>
        <td><p>number of closest points for neigthours definition in distance weight matrix computation.</p></td>
        <td><code>None</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>lisa_df (pd.DataFrame)</code></td>
      <td><p>Dataframe with the fdr threshold, local moran-s Is, p and z values and the quadrant in which each observation falls in a Moran's scatter plot.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>sandpyper\common.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">LISA_site_level</span><span class="p">(</span>
    <span class="n">dh_df</span><span class="p">,</span>
    <span class="n">crs_dict_string</span><span class="p">,</span>
    <span class="n">mode</span><span class="p">,</span>
    <span class="n">distance_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">decay</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">k_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">geometry_column</span><span class="o">=</span><span class="s1">&#39;geometry&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Performs Hot-Spot analysis using Local Moran&#39;s I as LISA for all the survey.</span>
<span class="sd">        Please refer to PySAL package documentation for more info.</span>

<span class="sd">    Args:</span>
<span class="sd">        dh_df (pd.DataFrame, str): Pandas dataframe or local path of the timeseries files, as returned by the multitemporal extraction.</span>
<span class="sd">        crs_dict_string (dict): Dictionary storing location codes as key and crs information as EPSG code (int).</span>
<span class="sd">        geometry_column (str): field storing the geometry column. If in string form (as loaded from a csv), it will be converted to Point objects. Default=&#39;coordinates&#39;.</span>
<span class="sd">        mode (str): If &#39;distance&#39;(Default), compute spatial weight matrix using a distance-band kernel, specified in distance_value parameter.</span>
<span class="sd">                                        If &#39;knn&#39;, spatial weight matrix uses a specified (k_value parameter) of k number closest points to compute weights.</span>
<span class="sd">                                        if &#39;idw&#39;, Inverse Distance Weigthing is used with the specified decay power (decay parameter) to compute weight.</span>

<span class="sd">        distance_value (int): values in meters (crs must be projected) used as distance band for neigthours definition in distance weight matrix computation.</span>
<span class="sd">        decay (int): power of decay to use with IDW.</span>
<span class="sd">        k_value (int): number of closest points for neigthours definition in distance weight matrix computation.</span>


<span class="sd">    Returns:</span>
<span class="sd">        lisa_df (pd.DataFrame): Dataframe with the fdr threshold, local moran-s Is, p and z values and the quadrant in which each observation falls in a Moran&#39;s scatter plot.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dh_df</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">dh_df</span><span class="p">):</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">dh_df</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NameError</span> <span class="p">(</span><span class="s2">&quot;The string provided in dh_df is not a valid path.&quot;</span><span class="p">)</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dh_df</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
        <span class="n">df</span><span class="o">=</span><span class="n">dh_df</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NameError</span> <span class="p">(</span><span class="s2">&quot;dh_df parameter must be either a valid path pointing to a multitemporal dataframe or the dataframe itself as a Pandas Dataframe.&quot;</span><span class="p">)</span>

    <span class="n">lisa_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>

    <span class="n">locs</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">location</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>  <span class="c1"># obtain list of locations</span>

    <span class="c1"># check whether a geometry type column is present</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">((</span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">geometry_column</span><span class="p">]),</span> <span class="n">Point</span><span class="p">):</span>
        <span class="n">df</span><span class="p">[</span><span class="n">geometry_column</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">geometry_column</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">wkt</span><span class="o">.</span><span class="n">loads</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="k">for</span> <span class="n">loc</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">locs</span><span class="p">):</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Working on </span><span class="si">{</span><span class="n">loc</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">df_in</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;location==&#39;</span><span class="si">{</span><span class="n">loc</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>  <span class="c1"># subset a location</span>

        <span class="c1"># create a GeoDataFrame with the right CRS</span>
        <span class="n">gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span><span class="n">df_in</span><span class="p">,</span> <span class="n">geometry</span><span class="o">=</span><span class="n">geometry_column</span><span class="p">,</span> <span class="n">crs</span><span class="o">=</span><span class="n">crs_dict_string</span><span class="p">[</span><span class="n">loc</span><span class="p">]</span>  <span class="p">)</span>

        <span class="n">dts</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>  <span class="c1"># obtain list of periods</span>

        <span class="k">for</span> <span class="n">dt</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">dts</span><span class="p">):</span>

            <span class="n">gdf_input</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;dt==&#39;</span><span class="si">{</span><span class="n">dt</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>  <span class="c1"># subset a periods</span>
            <span class="n">gdf_input</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;any&quot;</span><span class="p">,</span> <span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;dh&quot;</span><span class="p">],</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="c1"># drop rows where dh is null, due to sand-only condition</span>

            <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;distance&quot;</span><span class="p">:</span>
                <span class="n">dist</span> <span class="o">=</span> <span class="n">distance_value</span>
                <span class="n">dist_mode</span> <span class="o">=</span> <span class="s2">&quot;distance_band&quot;</span>
                <span class="n">decay</span> <span class="o">=</span> <span class="mi">0</span>

                <span class="n">dist_w</span> <span class="o">=</span> <span class="n">weights</span><span class="o">.</span><span class="n">DistanceBand</span><span class="o">.</span><span class="n">from_dataframe</span><span class="p">(</span>
                    <span class="n">df</span><span class="o">=</span><span class="n">gdf_input</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="n">dist</span><span class="p">,</span> <span class="n">binary</span><span class="o">=</span><span class="kc">True</span>
                <span class="p">)</span>
                <span class="c1"># create a binary spatial weight matrix with no IDW and specified</span>
                <span class="c1"># distance</span>
            <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;idw&quot;</span><span class="p">:</span>
                <span class="n">dist</span> <span class="o">=</span> <span class="n">distance_value</span>
                <span class="n">dist_mode</span> <span class="o">=</span> <span class="s2">&quot;idw&quot;</span>
                <span class="n">decay</span> <span class="o">=</span> <span class="n">decay</span>

                <span class="n">dist_w</span> <span class="o">=</span> <span class="n">weights</span><span class="o">.</span><span class="n">DistanceBand</span><span class="o">.</span><span class="n">from_dataframe</span><span class="p">(</span>
                    <span class="n">df</span><span class="o">=</span><span class="n">gdf_input</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="n">dist</span><span class="p">,</span> <span class="n">binary</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">decay</span>
                <span class="p">)</span>
                <span class="c1"># create a binary spatial weight matrix with no IDW and specified</span>
                <span class="c1"># distance</span>

            <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;knn&quot;</span><span class="p">:</span>

                <span class="n">dist_mode</span> <span class="o">=</span> <span class="s2">&quot;k&quot;</span>
                <span class="n">decay</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">dist</span> <span class="o">=</span> <span class="n">k_value</span>

                <span class="n">dist_w</span> <span class="o">=</span> <span class="n">weights</span><span class="o">.</span><span class="n">distance</span><span class="o">.</span><span class="n">KNN</span><span class="o">.</span><span class="n">from_dataframe</span><span class="p">(</span><span class="n">df</span><span class="o">=</span><span class="n">gdf_input</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">k_value</span><span class="p">))</span>

            <span class="n">lisa_</span> <span class="o">=</span> <span class="n">moran</span><span class="o">.</span><span class="n">Moran_Local</span><span class="p">(</span><span class="n">gdf_input</span><span class="o">.</span><span class="n">dh</span><span class="p">,</span> <span class="n">dist_w</span><span class="p">,</span> <span class="n">permutations</span><span class="o">=</span><span class="mi">999</span><span class="p">)</span>

            <span class="n">fdr_lisa</span> <span class="o">=</span> <span class="n">fdr</span><span class="p">(</span><span class="n">lisa_</span><span class="o">.</span><span class="n">p_sim</span><span class="p">)</span>  <span class="c1"># as k</span>
            <span class="c1"># the False Discovery Rate threshold to use for significant cluster</span>
            <span class="n">gdf_input</span><span class="p">[</span><span class="s2">&quot;lisa_fdr&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fdr_lisa</span>
            <span class="c1"># the quadrant of the Moran&#39;s scatter plot (Anselin 1995) in Pysal scheme</span>
            <span class="n">gdf_input</span><span class="p">[</span><span class="s2">&quot;lisa_q&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">lisa_</span><span class="o">.</span><span class="n">q</span>
            <span class="n">gdf_input</span><span class="p">[</span><span class="s2">&quot;lisa_I&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">lisa_</span><span class="o">.</span><span class="n">Is</span>  <span class="c1"># the local Moran&#39;s Is</span>
            <span class="c1"># the number of valid observations used</span>
            <span class="n">gdf_input</span><span class="p">[</span><span class="s2">&quot;lisa_n_val_obs&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">lisa_</span><span class="o">.</span><span class="n">n</span>
            <span class="n">gdf_input</span><span class="p">[</span><span class="s2">&quot;lisa_opt_dist&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dist</span>  <span class="c1"># the distance used</span>
            <span class="n">gdf_input</span><span class="p">[</span><span class="s2">&quot;lisa_dist_mode&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dist_mode</span>  <span class="c1"># mode, k od distance</span>
            <span class="n">gdf_input</span><span class="p">[</span><span class="s2">&quot;lisa_p_sim&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">lisa_</span><span class="o">.</span><span class="n">p_sim</span>  <span class="c1"># permutations (999) based p-value</span>
            <span class="n">gdf_input</span><span class="p">[</span><span class="s2">&quot;lisa_z_sim&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">lisa_</span><span class="o">.</span><span class="n">z_sim</span>  <span class="c1"># permutations (999) based z-value</span>
            <span class="n">gdf_input</span><span class="p">[</span><span class="s2">&quot;lisa_z&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">lisa_</span><span class="o">.</span><span class="n">z</span>
            <span class="c1"># z-value of the original data I distribution (no permutation)</span>
            <span class="n">gdf_input</span><span class="p">[</span><span class="s2">&quot;decay&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">decay</span>

            <span class="n">lisa_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">lisa_df</span><span class="p">,</span> <span class="n">gdf_input</span><span class="p">],</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">lisa_df</span>
</code></pre></div>
        </details>
    </div>

  </div>




  <div class="doc doc-object doc-function">



<h2 class="doc doc-heading" id="sandpyper.common.plot_alongshore_change">
<code class="highlight language-python"><span class="n">plot_alongshore_change</span><span class="p">(</span><span class="n">sand_pts</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">lod</span><span class="p">,</span> <span class="n">full_specs_table</span><span class="p">,</span> <span class="n">return_data</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">location_subset</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;wbl&#39;</span><span class="p">],</span> <span class="n">dt_subset</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;dt_0&#39;</span><span class="p">],</span> <span class="n">ax2_y_lims</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">8</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="n">save</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">save_path</span><span class="o">=</span><span class="s1">&#39;C:</span><span class="se">\\</span><span class="s1">your</span><span class="se">\\</span><span class="s1">preferred</span><span class="se">\\</span><span class="s1">folder</span><span class="se">\\</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span> <span class="n">img_type</span><span class="o">=</span><span class="s1">&#39;.png&#39;</span><span class="p">,</span> <span class="n">from_land</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">from_origin</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">add_orient</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fig_size</span><span class="o">=</span><span class="p">(</span><span class="mf">7.3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">font_scale</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">plots_spacing</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">bottom</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">y_heat_bottom_limit</span><span class="o">=</span><span class="mi">80</span><span class="p">,</span> <span class="n">transect_spacing</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">along_transect_sampling_step</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">heat_yticklabels_freq</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">heat_xticklabels_freq</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">outliers</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sigma_n</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span></code>


<a class="headerlink" href="#sandpyper.common.plot_alongshore_change" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Display and optionally save alongshore altimetric and volumetric beach changes plots.
A subset of locations and periods can be plotted.
If LoD parameter is True (default), then white cells in the altimetric heatmap are values within LoD. Grey cells is no data or no sand points.
Optionally, LoD filter can be turned off.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>sand_pts</code></td>
        <td><code>Pandas dataframe</code></td>
        <td><p>multitemporal table.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>mode</code></td>
        <td><code>str</code></td>
        <td><p>if 'subset', only a subset of locations and dts are plotted. If 'all', all periods and locations are plotted. .</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>lod</code></td>
        <td><code>path, value, False</code></td>
        <td><p>if valid path to an LoD table, use the table. If a value is provided, use the value across all surveys. If False, do not apply LoD filter. All elevation change (dh) values within LoD will be set to zero.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>full_specs_table</code></td>
        <td><code>False, path</code></td>
        <td><p>Full path to the table with extended monitoring info. If False, monitoring period information are limited.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>location_subset</code></td>
        <td><code>list</code></td>
        <td><p>list of strings containing the location codes (e.g. wbl) to be plotted.</p></td>
        <td><code>[&#39;wbl&#39;]</code></td>
      </tr>
      <tr>
        <td><code>dt_subset</code></td>
        <td><code>list</code></td>
        <td><p>list of strings containing the period codes (e.g. dt_0) to be plotted.</p></td>
        <td><code>[&#39;dt_0&#39;]</code></td>
      </tr>
      <tr>
        <td><code>ax2_y_lims</code></td>
        <td><code>tuple</code></td>
        <td><p>limits of y-axis of alonghsore volumetric change plot. Default is (-8,5).</p></td>
        <td><code>(-8, 5)</code></td>
      </tr>
      <tr>
        <td><code>save</code></td>
        <td><code>bool</code></td>
        <td><p>If True, saves the plots in the specified save_path. False is default.</p></td>
        <td><code>False</code></td>
      </tr>
      <tr>
        <td><code>save_path</code></td>
        <td><code>path</code></td>
        <td><p>Full path to a folder (e.g. C:\preferred\folder) where to save plots.</p></td>
        <td><code>&#39;C:\\your\\preferred\\folder\\&#39;</code></td>
      </tr>
      <tr>
        <td><code>dpi</code></td>
        <td><code>int</code></td>
        <td><p>Resolution in Dot Per Inch (DPI) to save the images.</p></td>
        <td><code>300</code></td>
      </tr>
      <tr>
        <td><code>img_type</code></td>
        <td><code>str</code></td>
        <td><p>'.png','.pdf', '.ps', '.svg'. Format of the saved figures.</p></td>
        <td><code>&#39;.png&#39;</code></td>
      </tr>
      <tr>
        <td><code>from_land</code></td>
        <td><code>bool</code></td>
        <td><p>If True (default), cross-shore distances are transformed into landward distances, where 0 is the end of beachface.</p></td>
        <td><code>True</code></td>
      </tr>
      <tr>
        <td><code>from_origin</code></td>
        <td><code>bool</code></td>
        <td><p>If True (default), transect IDS are transformed in alongshore distance from origin (tr_id=0). It requires regularly spaced transects.</p></td>
        <td><code>True</code></td>
      </tr>
      <tr>
        <td><code>add_orient</code></td>
        <td><code>bool</code></td>
        <td><p>if True, an additional lineplot is added to the volumetric plot containing orientation info. It needs pre-computed orientations (tr_orient parameter) (TO UPDAte). False is default.</p></td>
        <td><code>False</code></td>
      </tr>
      <tr>
        <td><code>fig_size</code></td>
        <td><code>tuple</code></td>
        <td><p>Tuple of float to specify images size. Default is (7.3,3).</p></td>
        <td><code>(7.3, 3)</code></td>
      </tr>
      <tr>
        <td><code>font_scale</code></td>
        <td><code>float</code></td>
        <td><p>Scale of text. Default=1.</p></td>
        <td><code>1</code></td>
      </tr>
      <tr>
        <td><code>plots_spacing</code></td>
        <td><code>float</code></td>
        <td><p>Vertical spacing of the heatmap and alongshore change plots. Default = 0.</p></td>
        <td><code>0</code></td>
      </tr>
      <tr>
        <td><code>bottom</code></td>
        <td><code>bool</code></td>
        <td><p>If True (default), rows are extended seaward too, up to y_heat_bottom_limit. If False, only distances from 0 to the first valid values will be added.</p></td>
        <td><code>False</code></td>
      </tr>
      <tr>
        <td><code>y_heat_bottom_limit</code></td>
        <td><code>int</code></td>
        <td><p>Lower boundary distance (seaward) to extend all transects to.</p></td>
        <td><code>80</code></td>
      </tr>
      <tr>
        <td><code>transect_spacing</code></td>
        <td><code>float</code></td>
        <td><p>Alongshore spacing of transects (m).</p></td>
        <td><code>20</code></td>
      </tr>
      <tr>
        <td><code>outliers</code></td>
        <td><code>bool</code></td>
        <td><p>when True, use the specified number of standard deviation to exclude outliers. If False, retain all the points.</p></td>
        <td><code>False</code></td>
      </tr>
      <tr>
        <td><code>sigma_n</code></td>
        <td><code>int</code></td>
        <td><p>number of standard deviation to use to exclude outliers (default=3).</p></td>
        <td><code>3</code></td>
      </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>sandpyper\common.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">plot_alongshore_change</span><span class="p">(</span>
    <span class="n">sand_pts</span><span class="p">,</span>
    <span class="n">mode</span><span class="p">,</span>
    <span class="n">lod</span><span class="p">,</span>
    <span class="n">full_specs_table</span><span class="p">,</span>
    <span class="n">return_data</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">location_subset</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;wbl&quot;</span><span class="p">],</span>
    <span class="n">dt_subset</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;dt_0&quot;</span><span class="p">],</span>
    <span class="n">ax2_y_lims</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">8</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span>
    <span class="n">save</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">save_path</span><span class="o">=</span><span class="s2">&quot;C:</span><span class="se">\\</span><span class="s2">your</span><span class="se">\\</span><span class="s2">preferred</span><span class="se">\\</span><span class="s2">folder</span><span class="se">\\</span><span class="s2">&quot;</span><span class="p">,</span>
    <span class="n">dpi</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span>
    <span class="n">img_type</span><span class="o">=</span><span class="s2">&quot;.png&quot;</span><span class="p">,</span>
    <span class="n">from_land</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">from_origin</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">add_orient</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">fig_size</span><span class="o">=</span><span class="p">(</span><span class="mf">7.3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
    <span class="n">font_scale</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">plots_spacing</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">bottom</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">y_heat_bottom_limit</span><span class="o">=</span><span class="mi">80</span><span class="p">,</span>
    <span class="n">transect_spacing</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span>
    <span class="n">along_transect_sampling_step</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">heat_yticklabels_freq</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
    <span class="n">heat_xticklabels_freq</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
    <span class="n">outliers</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">sigma_n</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Display and optionally save alongshore altimetric and volumetric beach changes plots.</span>
<span class="sd">    A subset of locations and periods can be plotted.</span>
<span class="sd">    If LoD parameter is True (default), then white cells in the altimetric heatmap are values within LoD. Grey cells is no data or no sand points.</span>
<span class="sd">    Optionally, LoD filter can be turned off.</span>

<span class="sd">    Args:</span>
<span class="sd">        sand_pts (Pandas dataframe): multitemporal table.</span>
<span class="sd">        mode (str): if &#39;subset&#39;, only a subset of locations and dts are plotted. If &#39;all&#39;, all periods and locations are plotted. .</span>
<span class="sd">        lod (path, value, False): if valid path to an LoD table, use the table. If a value is provided, use the value across all surveys. If False, do not apply LoD filter. All elevation change (dh) values within LoD will be set to zero.</span>
<span class="sd">        full_specs_table (False, path): Full path to the table with extended monitoring info. If False, monitoring period information are limited.</span>
<span class="sd">        location_subset (list): list of strings containing the location codes (e.g. wbl) to be plotted.</span>
<span class="sd">        dt_subset (list): list of strings containing the period codes (e.g. dt_0) to be plotted.</span>
<span class="sd">        ax2_y_lims (tuple): limits of y-axis of alonghsore volumetric change plot. Default is (-8,5).</span>
<span class="sd">        save (bool): If True, saves the plots in the specified save_path. False is default.</span>
<span class="sd">        save_path (path): Full path to a folder (e.g. C:\\preferred\\folder\\) where to save plots.</span>
<span class="sd">        dpi (int): Resolution in Dot Per Inch (DPI) to save the images.</span>
<span class="sd">        img_type (str): &#39;.png&#39;,&#39;.pdf&#39;, &#39;.ps&#39;, &#39;.svg&#39;. Format of the saved figures.</span>
<span class="sd">        from_land (bool): If True (default), cross-shore distances are transformed into landward distances, where 0 is the end of beachface.</span>
<span class="sd">        from_origin (bool): If True (default), transect IDS are transformed in alongshore distance from origin (tr_id=0). It requires regularly spaced transects.</span>
<span class="sd">        add_orient (bool): if True, an additional lineplot is added to the volumetric plot containing orientation info. It needs pre-computed orientations (tr_orient parameter) (TO UPDAte). False is default.</span>
<span class="sd">        fig_size (tuple): Tuple of float to specify images size. Default is (7.3,3).</span>
<span class="sd">        font_scale (float): Scale of text. Default=1.</span>
<span class="sd">        plots_spacing (float): Vertical spacing of the heatmap and alongshore change plots. Default = 0.</span>
<span class="sd">        bottom (bool): If True (default), rows are extended seaward too, up to y_heat_bottom_limit. If False, only distances from 0 to the first valid values will be added.</span>
<span class="sd">        y_heat_bottom_limit (int): Lower boundary distance (seaward) to extend all transects to.</span>
<span class="sd">        transect_spacing (float): Alongshore spacing of transects (m).</span>
<span class="sd">        outliers (bool): when True, use the specified number of standard deviation to exclude outliers. If False, retain all the points.</span>
<span class="sd">        sigma_n (int): number of standard deviation to use to exclude outliers (default=3).</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">sb</span><span class="o">.</span><span class="n">set_context</span><span class="p">(</span><span class="s2">&quot;paper&quot;</span><span class="p">,</span> <span class="n">font_scale</span><span class="o">=</span><span class="n">font_scale</span><span class="p">,</span> <span class="n">rc</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;lines.linewidth&quot;</span><span class="p">:</span> <span class="mf">0.8</span><span class="p">})</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">full_specs_table</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">bool</span><span class="p">(</span><span class="n">full_specs_table</span><span class="p">)</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">skip_details</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;Not a DataFrame, nor a valid path to the .csv file for the specs table.&quot;</span>
            <span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">full_specs_table</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">full_specs_table</span><span class="p">):</span>
            <span class="n">table_details</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">full_specs_table</span><span class="p">)</span>
            <span class="n">skip_details</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;The path provided in full_spec_table is not a valid path to the .csv file.&quot;</span>
            <span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">full_specs_table</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
        <span class="n">table_details</span> <span class="o">=</span> <span class="n">full_specs_table</span>
        <span class="n">skip_details</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s2">&quot;Not a DataFrame, nor a valid path to the .csv file for the specs table.&quot;</span>
        <span class="p">)</span>

    <span class="n">land_limits</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
        <span class="n">sand_pts</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s2">&quot;location&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">distance</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>

    <span class="n">locations_to_analyse</span> <span class="o">=</span> <span class="n">sand_pts</span><span class="o">.</span><span class="n">location</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>

    <span class="k">if</span> <span class="nb">bool</span><span class="p">(</span><span class="n">from_origin</span><span class="p">):</span>
        <span class="n">xlabel</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">xlabel</span> <span class="o">=</span> <span class="s2">&quot;Transect ID&quot;</span>

    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;subset&quot;</span><span class="p">:</span>
        <span class="n">locations_to_analyse</span> <span class="o">=</span> <span class="n">location_subset</span>
        <span class="n">dt_to_analyse</span> <span class="o">=</span> <span class="n">dt_subset</span>

    <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span><span class="p">:</span>
        <span class="n">locations_to_analyse</span> <span class="o">=</span> <span class="n">sand_pts</span><span class="o">.</span><span class="n">location</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
        <span class="n">dt_to_analyse</span> <span class="o">=</span> <span class="n">sand_pts</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;location == &#39;</span><span class="si">{</span><span class="n">loc</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">loc</span> <span class="ow">in</span> <span class="n">locations_to_analyse</span><span class="p">:</span>
        <span class="n">temp_loc</span> <span class="o">=</span> <span class="n">sand_pts</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;location == &#39;</span><span class="si">{</span><span class="n">loc</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">dt</span> <span class="ow">in</span> <span class="n">dt_to_analyse</span><span class="p">:</span>

            <span class="c1"># subset the data</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">sand_pts</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;location == &#39;</span><span class="si">{</span><span class="n">loc</span><span class="si">}</span><span class="s2">&#39; and dt ==&#39;</span><span class="si">{</span><span class="n">dt</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>

            <span class="c1"># prepare axes and figure</span>
            <span class="n">f</span><span class="p">,</span> <span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">ax2</span><span class="p">)</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span>
                <span class="n">nrows</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                <span class="n">figsize</span><span class="o">=</span><span class="n">fig_size</span><span class="p">,</span>
                <span class="n">sharex</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">gridspec_kw</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;hspace&quot;</span><span class="p">:</span> <span class="n">plots_spacing</span><span class="p">},</span>
            <span class="p">)</span>

            <span class="c1"># _____________data_preparation______________</span>

            <span class="c1"># compute beach length based on number of transects</span>
            <span class="n">beach_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">temp</span><span class="o">.</span><span class="n">tr_id</span><span class="o">.</span><span class="n">unique</span><span class="p">())</span> <span class="o">*</span> <span class="n">transect_spacing</span>

            <span class="c1"># prepare the data to be suitable for the heatmap</span>
            <span class="n">data_in</span> <span class="o">=</span> <span class="n">prep_heatmap</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">lod</span><span class="o">=</span><span class="n">lod</span><span class="p">,</span> <span class="n">outliers</span><span class="o">=</span><span class="n">outliers</span><span class="p">,</span> <span class="n">sigma_n</span><span class="o">=</span><span class="n">sigma_n</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">bool</span><span class="p">(</span><span class="n">skip_details</span><span class="p">):</span>
                <span class="n">full_loc</span> <span class="o">=</span> <span class="n">loc</span>
                <span class="n">lod_i</span> <span class="o">=</span> <span class="mf">0.05</span>
            <span class="k">else</span><span class="p">:</span>

                <span class="n">specs</span> <span class="o">=</span> <span class="n">table_details</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;location==&#39;</span><span class="si">{</span><span class="n">loc</span><span class="si">}</span><span class="s2">&#39; &amp; dt==&#39;</span><span class="si">{</span><span class="n">dt</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>
                <span class="n">full_loc</span> <span class="o">=</span> <span class="n">specs</span><span class="o">.</span><span class="n">loc_full</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">date_from</span> <span class="o">=</span> <span class="n">specs</span><span class="o">.</span><span class="n">date_pre</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">date_to</span> <span class="o">=</span> <span class="n">specs</span><span class="o">.</span><span class="n">date_post</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">n_days</span> <span class="o">=</span> <span class="n">specs</span><span class="o">.</span><span class="n">n_days</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lod</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
                <span class="n">lod_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">lod</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;location == &#39;</span><span class="si">{</span><span class="n">loc</span><span class="si">}</span><span class="s2">&#39; &amp; dt == &#39;</span><span class="si">{</span><span class="n">dt</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">lod</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lod</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">)):</span>
                <span class="n">lod_i</span> <span class="o">=</span> <span class="n">lod</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">lod_i</span> <span class="o">=</span> <span class="mf">0.05</span>

            <span class="c1"># FIGURE_______________________________________________________________________</span>

            <span class="c1">#</span>
            <span class="n">axins</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">inset_axes</span><span class="p">(</span><span class="n">bounds</span><span class="o">=</span><span class="p">[</span><span class="mf">1.02</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.04</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>

            <span class="k">if</span> <span class="nb">bool</span><span class="p">(</span><span class="n">from_land</span><span class="p">):</span>

                <span class="n">land_lim</span> <span class="o">=</span> <span class="n">land_limits</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;location==&#39;</span><span class="si">{</span><span class="n">loc</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">distance</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">data_in</span><span class="p">[</span><span class="s2">&quot;m_from_land&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">land_lim</span> <span class="o">-</span> <span class="n">data_in</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">data_in</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s2">&quot;m_from_land&quot;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">pass</span>

            <span class="k">if</span> <span class="nb">bool</span><span class="p">(</span><span class="n">from_origin</span><span class="p">):</span>
                <span class="n">data_in</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">data_in</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">*</span> <span class="n">transect_spacing</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">pass</span>

            <span class="n">data_in_filled</span> <span class="o">=</span> <span class="n">fill_gaps</span><span class="p">(</span><span class="n">data_in</span><span class="p">,</span> <span class="n">y_heat_bottom_limit</span><span class="p">,</span> <span class="n">bottom</span><span class="o">=</span><span class="n">bottom</span><span class="p">,</span> <span class="n">spacing</span><span class="o">=</span><span class="n">along_transect_sampling_step</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Working on </span><span class="si">{</span><span class="n">loc</span><span class="si">}</span><span class="s2"> at </span><span class="si">{</span><span class="n">dt</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="c1"># _______AX__________________________________________________________________</span>

            <span class="n">sb</span><span class="o">.</span><span class="n">heatmap</span><span class="p">(</span>
                <span class="n">data</span><span class="o">=</span><span class="n">data_in_filled</span><span class="p">,</span>
                <span class="n">xticklabels</span><span class="o">=</span><span class="n">heat_xticklabels_freq</span><span class="p">,</span>
                <span class="n">facecolor</span><span class="o">=</span><span class="s2">&quot;w&quot;</span><span class="p">,</span>
                <span class="n">robust</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">center</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span>
                <span class="n">cbar_kws</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;label&quot;</span><span class="p">:</span> <span class="s2">&quot;h m AHD&quot;</span><span class="p">},</span>
                <span class="n">cbar</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">cbar_ax</span><span class="o">=</span><span class="n">axins</span><span class="p">,</span>
                <span class="n">cmap</span><span class="o">=</span><span class="s2">&quot;seismic_r&quot;</span><span class="p">,</span>
                <span class="n">vmin</span><span class="o">=-</span><span class="mf">0.8</span><span class="p">,</span>
                <span class="n">vmax</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="c1"># _________________________________BACKGROUND COLOR AND TRANSPARENCY_____</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">patch</span><span class="o">.</span><span class="n">set_facecolor</span><span class="p">(</span><span class="s2">&quot;grey&quot;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">patch</span><span class="o">.</span><span class="n">set_alpha</span><span class="p">(</span><span class="mf">0.4</span><span class="p">)</span>

            <span class="c1"># _________________________________AXIS LABELS_____</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Cross. distance (m)&quot;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&quot;</span><span class="p">)</span>

            <span class="c1"># __________________________________SPINES,TICKS_AND_GRIDS_________________________________</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">get_xaxis</span><span class="p">()</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s2">&quot;bottom&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s2">&quot;left&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s2">&quot;right&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s2">&quot;top&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

            <span class="n">ax</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="n">b</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s2">&quot;minor&quot;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s2">&quot;-&quot;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="n">b</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s2">&quot;major&quot;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s2">&quot;-&quot;</span><span class="p">)</span>

            <span class="n">tmp_list_along_dists</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">y_heat_bottom_limit</span> <span class="o">+</span> <span class="mi">5</span><span class="p">,</span> <span class="n">heat_yticklabels_freq</span><span class="p">)</span>
            <span class="n">y_formatter_list_values</span> <span class="o">=</span> <span class="n">tmp_list_along_dists</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;str&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="n">y_formatter_list_values</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
            <span class="n">y_formatter_list_locators</span> <span class="o">=</span> <span class="p">[</span><span class="n">value</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">along_transect_sampling_step</span><span class="p">)</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">tmp_list_along_dists</span><span class="p">]</span>

            <span class="n">y_formatter</span> <span class="o">=</span> <span class="n">FixedFormatter</span><span class="p">(</span><span class="n">y_formatter_list_values</span><span class="p">)</span>
            <span class="n">y_locator</span> <span class="o">=</span> <span class="n">FixedLocator</span><span class="p">(</span><span class="n">y_formatter_list_locators</span><span class="p">)</span>

            <span class="n">ax</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">set_major_formatter</span><span class="p">(</span><span class="n">y_formatter</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">set_major_locator</span><span class="p">(</span><span class="n">y_locator</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">set_minor_locator</span><span class="p">(</span><span class="n">AutoMinorLocator</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="n">which</span><span class="o">=</span><span class="s2">&quot;minor&quot;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="s2">&quot;y&quot;</span><span class="p">)</span>

            <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">y_heat_bottom_limit</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">along_transect_sampling_step</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s2">&quot;both&quot;</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

            <span class="c1"># __AX2___________________________________________________________________</span>

            <span class="n">red_patch</span> <span class="o">=</span> <span class="n">mpatches</span><span class="o">.</span><span class="n">Patch</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="s2">&quot;orange&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Erosion&quot;</span><span class="p">)</span>
            <span class="n">blue_patch</span> <span class="o">=</span> <span class="n">mpatches</span><span class="o">.</span><span class="n">Patch</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="s2">&quot;skyblue&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Deposition&quot;</span><span class="p">)</span>

            <span class="n">trs_volumes</span> <span class="o">=</span> <span class="n">data_in</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">interpol_integrate</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">**</span><span class="p">{</span><span class="s1">&#39;dx&#39;</span><span class="p">:</span><span class="n">along_transect_sampling_step</span><span class="p">})</span>
            <span class="n">beach_lengths</span> <span class="o">=</span> <span class="n">data_in</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">get_beachface_length</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

            <span class="n">m3_m</span> <span class="o">=</span> <span class="p">(</span><span class="n">trs_volumes</span> <span class="o">*</span> <span class="n">transect_spacing</span><span class="p">)</span> <span class="o">/</span> <span class="n">beach_lengths</span>

            <span class="n">trs_volumes</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span><span class="o">.</span><span class="n">rename</span><span class="p">({</span><span class="s2">&quot;int_tr&quot;</span><span class="p">:</span> <span class="s2">&quot;tr_id&quot;</span><span class="p">},</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">trs_volumes</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;dh&quot;</span>
            <span class="n">tr_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">trs_volumes</span><span class="p">)</span>

            <span class="n">tr_df</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">tr_df</span><span class="p">[</span><span class="s2">&quot;net_volume_change_m3&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tr_df</span><span class="o">.</span><span class="n">dh</span>
            <span class="n">tr_df</span><span class="p">[</span><span class="s2">&quot;net_balance_m3_m&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">m3_m</span><span class="o">.</span><span class="n">values</span>

            <span class="n">tr_df</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s2">&quot;int_tr&quot;</span><span class="p">)</span>
            <span class="n">tr_df</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="n">sb</span><span class="o">.</span><span class="n">lineplot</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">tr_df</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="s2">&quot;index&quot;</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="s2">&quot;net_balance_m3_m&quot;</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax2</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">)</span>
            <span class="n">ax2</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">ax2_y_lims</span><span class="p">)</span>
            <span class="n">ax2</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">set_minor_locator</span><span class="p">(</span><span class="n">AutoMinorLocator</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>

            <span class="c1"># FILLS________________________________________</span>

            <span class="n">line_x</span><span class="p">,</span> <span class="n">line_y</span> <span class="o">=</span> <span class="n">ax2</span><span class="o">.</span><span class="n">lines</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_data</span><span class="p">()</span>

            <span class="n">ax2</span><span class="o">.</span><span class="n">fill_between</span><span class="p">(</span>
                <span class="n">line_x</span><span class="p">,</span>
                <span class="n">line_y</span><span class="p">,</span>
                <span class="n">where</span><span class="o">=</span><span class="p">(</span><span class="n">line_y</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">),</span>
                <span class="n">interpolate</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">color</span><span class="o">=</span><span class="s2">&quot;skyblue&quot;</span><span class="p">,</span>
                <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="n">ax2</span><span class="o">.</span><span class="n">fill_between</span><span class="p">(</span>
                <span class="n">line_x</span><span class="p">,</span>
                <span class="n">line_y</span><span class="p">,</span>
                <span class="n">where</span><span class="o">=</span><span class="p">(</span><span class="n">line_y</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">),</span>
                <span class="n">interpolate</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">color</span><span class="o">=</span><span class="s2">&quot;orange&quot;</span><span class="p">,</span>
                <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="n">ax2</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="n">b</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s2">&quot;minor&quot;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s2">&quot;-&quot;</span><span class="p">)</span>
            <span class="n">ax2</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="n">b</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s2">&quot;major&quot;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s2">&quot;-&quot;</span><span class="p">)</span>

            <span class="n">ax2</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Along. distance (m)&quot;</span><span class="p">)</span>
            <span class="n">ax2</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Net v (m/m)&quot;</span><span class="p">)</span>
            <span class="n">ax2</span><span class="o">.</span><span class="n">axhline</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s2">&quot;--&quot;</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">ax2</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&quot;</span><span class="p">)</span>

            <span class="n">ax2</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s2">&quot;top&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">ax2</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s2">&quot;right&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">ax2</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s2">&quot;left&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">ax2</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s2">&quot;bottom&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">ax2</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="n">which</span><span class="o">=</span><span class="s2">&quot;minor&quot;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="s2">&quot;y&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">bool</span><span class="p">(</span><span class="n">skip_details</span><span class="p">)</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
                <span class="n">date_from_str</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">date_from</span><span class="p">))</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> %b &#39;%y&quot;</span><span class="p">)</span>
                <span class="n">date_to_str</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">date_to</span><span class="p">))</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> %b &#39;%y&quot;</span><span class="p">)</span>

                <span class="n">f</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Beachface change in </span><span class="si">{</span><span class="n">full_loc</span><span class="si">}</span><span class="s2"> from </span><span class="si">{</span><span class="n">date_from_str</span><span class="si">}</span><span class="s2"> to </span><span class="si">{</span><span class="n">date_to_str</span><span class="si">}</span><span class="s2"> (LoD = </span><span class="si">{</span><span class="n">lod_i</span><span class="si">}</span><span class="s2"> m)&quot;</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>

                <span class="n">f</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Beachface change in </span><span class="si">{</span><span class="n">loc</span><span class="si">}</span><span class="s2"> for </span><span class="si">{</span><span class="n">dt</span><span class="si">}</span><span class="s2"> (LoD = </span><span class="si">{</span><span class="n">lod_i</span><span class="si">}</span><span class="s2"> m)&quot;</span><span class="p">)</span>

            <span class="n">axs</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">get_axes</span><span class="p">()</span>

            <span class="n">f</span><span class="o">.</span><span class="n">align_ylabels</span><span class="p">(</span><span class="n">axs</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

            <span class="n">ax</span><span class="o">.</span><span class="n">set_zorder</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">ax2</span><span class="o">.</span><span class="n">set_zorder</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">bool</span><span class="p">(</span><span class="n">save</span><span class="p">):</span>
                <span class="n">savetxt</span> <span class="o">=</span> <span class="n">save_path</span> <span class="o">+</span> <span class="n">loc</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">dt</span> <span class="o">+</span> <span class="s2">&quot;_AlongChange&quot;</span> <span class="o">+</span> <span class="n">img_type</span>
                <span class="n">f</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">savetxt</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="n">dpi</span><span class="p">,</span> <span class="n">bbox_inches</span><span class="o">=</span><span class="s2">&quot;tight&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">pass</span>

            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">return_data</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">data_in_filled</span>
</code></pre></div>
        </details>
    </div>

  </div>





  <div class="doc doc-object doc-function">



<h2 class="doc doc-heading" id="sandpyper.common.plot_sensitivity_rbcds_transects">
<code class="highlight language-python"><span class="n">plot_sensitivity_rbcds_transects</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">location</span><span class="p">,</span> <span class="n">x_ticks</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="n">tresh_xlims</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="n">trans_ylims</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">sign_ylims</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span></code>


<a class="headerlink" href="#sandpyper.common.plot_sensitivity_rbcds_transects" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Plot both the number of valid transects retained (red) and the total sign changes (blue) as a function of the threshold used. This function creates a plot per min_points situation. The solid black line is the 95th percentile of the total valid transect retained while the dashed one is the 85th.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>df</code></td>
        <td><code>pd.DataFrame</code></td>
        <td><p>Sensitivity dataframe resulting from using the function sensitivity_tr_rbcd().</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>location</code></td>
        <td><code>str</code></td>
        <td><p>Location code of the locatin to plot.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>x_ticks</code></td>
        <td><code>list</code></td>
        <td><p>List of x-axis ticks (thresholds).</p></td>
        <td><code>[0, 2, 4, 6, 8]</code></td>
      </tr>
      <tr>
        <td><code>figsize</code></td>
        <td><code>tuple</code></td>
        <td><p>Width and height (in inches) of the figure.</p></td>
        <td><code>(7, 4)</code></td>
      </tr>
      <tr>
        <td><code>tresh_xlims</code></td>
        <td><code>tuple</code></td>
        <td><p>Min x and max x of the thresholds x-axis.</p></td>
        <td><code>(0, 8)</code></td>
      </tr>
      <tr>
        <td><code>trans_ylims</code></td>
        <td><code>tuple</code></td>
        <td><p>Min y and max y of the transect main y-axis.</p></td>
        <td><code>(0, 3)</code></td>
      </tr>
      <tr>
        <td><code>sign_ylims</code></td>
        <td><code>tuple</code></td>
        <td><p>.</p></td>
        <td><code>(0, 10)</code></td>
      </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>sandpyper\common.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">plot_sensitivity_rbcds_transects</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">location</span><span class="p">,</span> <span class="n">x_ticks</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">8</span><span class="p">],</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span>
                                     <span class="n">tresh_xlims</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">8</span><span class="p">),</span> <span class="n">trans_ylims</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="n">sign_ylims</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">10</span><span class="p">)):</span>
    <span class="sd">&quot;&quot;&quot;Plot both the number of valid transects retained (red) and the total sign changes (blue) as a function of the threshold used. This function creates a plot per min_points situation. The solid black line is the 95th percentile of the total valid transect retained while the dashed one is the 85th.</span>

<span class="sd">    Args:</span>
<span class="sd">        df (pd.DataFrame): Sensitivity dataframe resulting from using the function sensitivity_tr_rbcd().</span>
<span class="sd">        location (str): Location code of the locatin to plot.</span>
<span class="sd">        x_ticks (list): List of x-axis ticks (thresholds).</span>
<span class="sd">        figsize (tuple): Width and height (in inches) of the figure.</span>
<span class="sd">        tresh_xlims (tuple): Min x and max x of the thresholds x-axis.</span>
<span class="sd">        trans_ylims (tuple): Min y and max y of the transect main y-axis.</span>
<span class="sd">        sign_ylims (tuple): .</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;font.sans-serif&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Arial&#39;</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;font.family&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;sans-serif&#39;</span>
    <span class="n">sb</span><span class="o">.</span><span class="n">set_context</span><span class="p">(</span><span class="s2">&quot;paper&quot;</span><span class="p">,</span> <span class="n">font_scale</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">q_up_val</span><span class="o">=</span><span class="mf">0.95</span>
    <span class="n">q_low_val</span><span class="o">=</span><span class="mf">0.85</span>


    <span class="n">data_in</span><span class="o">=</span><span class="n">df</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;location == &#39;</span><span class="si">{</span><span class="n">location</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>

    <span class="n">list_minpts</span><span class="o">=</span><span class="n">data_in</span><span class="o">.</span><span class="n">min_pts</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
    <span class="n">trs_res_ar</span><span class="o">=</span><span class="n">data_in</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s2">&quot;tr_id&quot;</span><span class="p">,</span><span class="s2">&quot;min_pts&quot;</span><span class="p">])[</span><span class="s1">&#39;residual&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
    <span class="n">tot_trs</span><span class="o">=</span><span class="n">data_in</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s2">&quot;thresh&quot;</span><span class="p">,</span><span class="s2">&quot;min_pts&quot;</span><span class="p">])[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">count</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
    <span class="n">tot_trs</span><span class="p">[</span><span class="s1">&#39;trs_10&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">tot_trs</span><span class="o">.</span><span class="n">geometry</span> <span class="o">/</span> <span class="mi">10</span>
    <span class="n">zero_crossings</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">({</span><span class="s1">&#39;tr_id&#39;</span><span class="p">:</span><span class="n">trs_res_ar</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="s1">&#39;tr_id&#39;</span><span class="p">],</span>
                                            <span class="s1">&#39;sign_change_thresh&#39;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">trs_res_ar</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">])))[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span>
                                           <span class="s1">&#39;min_pts&#39;</span><span class="p">:</span><span class="n">trs_res_ar</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="s1">&#39;min_pts&#39;</span><span class="p">]})</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">trs_res_ar</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">trs_res_ar</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">])))[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">tot_jumps</span><span class="o">=</span><span class="n">zero_crossings</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s2">&quot;sign_change_thresh&quot;</span><span class="p">,</span><span class="s2">&quot;min_pts&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">count</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span> <span class="c1"># how many jumps per thresh and minpts</span>

    <span class="n">joined</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">tot_trs</span><span class="p">,</span><span class="n">tot_jumps</span><span class="p">,</span> <span class="n">left_on</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;thresh&#39;</span><span class="p">,</span><span class="s1">&#39;min_pts&#39;</span><span class="p">],</span> <span class="n">right_on</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;sign_change_thresh&#39;</span><span class="p">,</span><span class="s1">&#39;min_pts&#39;</span><span class="p">],</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">)</span>
    <span class="n">joined</span><span class="o">.</span><span class="n">rename</span><span class="p">({</span><span class="s1">&#39;geometry&#39;</span><span class="p">:</span><span class="s1">&#39;tot_trs&#39;</span><span class="p">,</span>
                  <span class="s1">&#39;tr_id&#39;</span><span class="p">:</span><span class="s1">&#39;tot_jumps&#39;</span><span class="p">},</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>


    <span class="k">for</span> <span class="n">minpts</span> <span class="ow">in</span> <span class="n">list_minpts</span><span class="p">:</span>

        <span class="n">f</span><span class="p">,</span><span class="n">ax</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">)</span>
        <span class="n">ax2</span><span class="o">=</span><span class="n">ax</span><span class="o">.</span><span class="n">twinx</span><span class="p">()</span>

        <span class="n">datain</span><span class="o">=</span><span class="n">joined</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;min_pts==</span><span class="si">{</span><span class="n">minpts</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


        <span class="n">sb</span><span class="o">.</span><span class="n">lineplot</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="s2">&quot;thresh&quot;</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="s2">&quot;tot_jumps&quot;</span><span class="p">,</span><span class="n">ci</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                        <span class="n">data</span><span class="o">=</span><span class="n">datain</span><span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">,</span>
                       <span class="n">alpha</span><span class="o">=</span><span class="mf">.4</span><span class="p">,</span><span class="n">linewidth</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                    <span class="n">ax</span><span class="o">=</span><span class="n">ax2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;sign changes&quot;</span><span class="p">)</span>

        <span class="n">sb</span><span class="o">.</span><span class="n">lineplot</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">datain</span><span class="p">,</span><span class="n">x</span><span class="o">=</span><span class="s1">&#39;thresh&#39;</span><span class="p">,</span><span class="n">y</span><span class="o">=</span><span class="s1">&#39;trs_10&#39;</span><span class="p">,</span>
                    <span class="n">alpha</span><span class="o">=</span><span class="mf">.4</span><span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span><span class="n">linewidth</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                    <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span><span class="n">label</span><span class="o">=</span><span class="s2">&quot;transects * 10&quot;</span><span class="p">)</span>


        <span class="n">kde_x</span><span class="p">,</span> <span class="n">kde_y</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">lines</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_data</span><span class="p">()</span>
        <span class="n">kde_x2</span><span class="p">,</span> <span class="n">kde_y2</span> <span class="o">=</span> <span class="n">ax2</span><span class="o">.</span><span class="n">lines</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_data</span><span class="p">()</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">fill_between</span><span class="p">(</span><span class="n">kde_x</span><span class="p">,</span> <span class="n">kde_y</span><span class="p">,</span><span class="n">interpolate</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span><span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">fill_between</span><span class="p">(</span><span class="n">kde_x2</span><span class="p">,</span> <span class="n">kde_y2</span><span class="p">,</span><span class="n">interpolate</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">axhline</span><span class="p">((</span><span class="n">datain</span><span class="o">.</span><span class="n">tot_trs</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">*</span><span class="n">q_up_val</span><span class="p">)</span><span class="o">/</span><span class="mi">10</span><span class="p">,</span><span class="n">c</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span><span class="n">ls</span><span class="o">=</span><span class="s1">&#39;-&#39;</span><span class="p">,</span><span class="n">label</span><span class="o">=</span><span class="s1">&#39;95%&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">axhline</span><span class="p">((</span><span class="n">datain</span><span class="o">.</span><span class="n">tot_trs</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">*</span><span class="n">q_low_val</span><span class="p">)</span><span class="o">/</span><span class="mi">10</span><span class="p">,</span><span class="n">c</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span><span class="n">lw</span><span class="o">=</span><span class="mf">2.5</span><span class="p">,</span><span class="n">ls</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">,</span><span class="n">label</span><span class="o">=</span><span class="s1">&#39;85%&#39;</span><span class="p">)</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;n. transects x 10&#39;</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;t&#39;</span><span class="p">)</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;sign changes&#39;</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">)</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">sign_ylims</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">trans_ylims</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">tresh_xlims</span><span class="p">)</span>


        <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">get_legend</span><span class="p">()</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">get_legend</span><span class="p">()</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>


        <span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">(</span><span class="n">x_ticks</span><span class="p">)</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;pt: </span><span class="si">{</span><span class="n">minpts</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 class="doc doc-heading" id="sandpyper.common.plot_single_loc">
<code class="highlight language-python"><span class="n">plot_single_loc</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">loc_subset</span><span class="p">,</span> <span class="n">figsize</span><span class="p">,</span> <span class="n">colors_dict</span><span class="p">,</span> <span class="n">linewidth</span><span class="p">,</span> <span class="n">out_date_format</span><span class="p">,</span> <span class="n">xlabel</span><span class="p">,</span> <span class="n">ylabel</span><span class="p">,</span> <span class="n">suptitle</span><span class="p">)</span></code>


<a class="headerlink" href="#sandpyper.common.plot_single_loc" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Display Mean Elevation Change (mec, in m) and cumulative mec (since start of the monitoring), for a single location.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>df</code></td>
        <td><code>Pandas dataframe</code></td>
        <td><p>location-level-volumetrics table obtained from get_state_vol_table function.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>loc_subset</code></td>
        <td><code>list</code></td>
        <td><p>a list of location codes, in case multiple locations need to be plotted (not optimal).</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>figsize</code></td>
        <td><code>tuple</code></td>
        <td><p>Tuple of float to specify images size.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>colors_dict</code></td>
        <td><code>dict</code></td>
        <td><p>Dictionary with keys=location code and values=color (in matplotlib specification).</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>linewidth</code></td>
        <td><code>float, int</code></td>
        <td><p>linewidths of the plot lines.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>out_date_format</code></td>
        <td><code>str</code></td>
        <td><p>format of the dates plotted in the x axis (datetime format).</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>xlabel</code></td>
        <td><code>str</code></td>
        <td><p>labels for x axis.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>ylabel</code></td>
        <td><code>str</code></td>
        <td><p>labels for y axis.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>suptitle</code></td>
        <td><code></code></td>
        <td><p>title of the plot.</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>sandpyper\common.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">plot_single_loc</span><span class="p">(</span>
    <span class="n">df</span><span class="p">,</span>
    <span class="n">loc_subset</span><span class="p">,</span>
    <span class="n">figsize</span><span class="p">,</span>
    <span class="n">colors_dict</span><span class="p">,</span>
    <span class="n">linewidth</span><span class="p">,</span>
    <span class="n">out_date_format</span><span class="p">,</span>
    <span class="n">xlabel</span><span class="p">,</span>
    <span class="n">ylabel</span><span class="p">,</span>
    <span class="n">suptitle</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Display Mean Elevation Change (mec, in m) and cumulative mec (since start of the monitoring), for a single location.</span>

<span class="sd">    Args:</span>
<span class="sd">        df (Pandas dataframe): location-level-volumetrics table obtained from get_state_vol_table function.</span>
<span class="sd">        loc_subset (list): a list of location codes, in case multiple locations need to be plotted (not optimal).</span>
<span class="sd">        figsize (tuple): Tuple of float to specify images size.</span>
<span class="sd">        colors_dict (dict): Dictionary with keys=location code and values=color (in matplotlib specification).</span>
<span class="sd">        linewidth (float, int): linewidths of the plot lines.</span>
<span class="sd">        out_date_format (str): format of the dates plotted in the x axis (datetime format).</span>
<span class="sd">        xlabel (str): labels for x axis.</span>
<span class="sd">        ylabel (str): labels for y axis.</span>
<span class="sd">        suptitle: title of the plot.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">f</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">colors_dict</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Color dictionary provided.&quot;</span><span class="p">)</span>
        <span class="n">color_mode</span> <span class="o">=</span> <span class="s2">&quot;dictionary&quot;</span>

    <span class="k">elif</span> <span class="n">colors_dict</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>

        <span class="n">num_colors</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">loc_subset</span><span class="p">)</span>
        <span class="n">cmapa</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="s2">&quot;tab20c&quot;</span><span class="p">)</span>
        <span class="n">cs</span> <span class="o">=</span> <span class="p">[</span><span class="n">cmapa</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">num_colors</span><span class="p">)]</span>
        <span class="n">color_mode</span> <span class="o">=</span> <span class="s2">&quot;auto&quot;</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Error in specifying color dictionary.&quot;</span><span class="p">)</span>

    <span class="n">dataset_in</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;location in </span><span class="si">{</span><span class="n">loc_subset</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">dataset_in</span><span class="p">[</span><span class="s2">&quot;date_from_dt&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">dataset_in</span><span class="o">.</span><span class="n">date_from</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;%Y%m</span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">dayfirst</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">dataset_in</span><span class="p">[</span><span class="s2">&quot;date_to_dt&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">dataset_in</span><span class="o">.</span><span class="n">date_to</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;%Y%m</span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">dayfirst</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">location</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dataset_in</span><span class="o">.</span><span class="n">location</span><span class="o">.</span><span class="n">unique</span><span class="p">()):</span>

        <span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset_in</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;location==&#39;</span><span class="si">{</span><span class="n">location</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>


        <span class="k">if</span> <span class="n">color_mode</span> <span class="o">==</span> <span class="s2">&quot;dictionary&quot;</span><span class="p">:</span>
            <span class="n">color_i</span> <span class="o">=</span> <span class="n">colors_dict</span><span class="p">[</span><span class="n">location</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">color_mode</span> <span class="o">==</span> <span class="s2">&quot;auto&quot;</span><span class="p">:</span>
            <span class="n">color_i</span> <span class="o">=</span> <span class="n">cs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="c1"># Calculate the cumulative net volumetric change and mean elevation change from start of monitoring</span>
        <span class="n">dataset</span><span class="p">[</span><span class="s2">&quot;cum&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">net_vol_change</span><span class="o">.</span><span class="n">cumsum</span><span class="p">()</span>
        <span class="n">dataset</span><span class="p">[</span><span class="s2">&quot;cum_mec&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">norm_net_change</span><span class="o">.</span><span class="n">cumsum</span><span class="p">()</span>


        <span class="n">ax</span> <span class="o">=</span> <span class="n">sb</span><span class="o">.</span><span class="n">lineplot</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">dataset</span><span class="p">,</span>
            <span class="n">x</span><span class="o">=</span><span class="s2">&quot;date_to_dt&quot;</span><span class="p">,</span>
            <span class="n">color</span><span class="o">=</span><span class="n">color_i</span><span class="p">,</span>
            <span class="n">y</span><span class="o">=</span><span class="s2">&quot;net_vol_change&quot;</span><span class="p">,</span>
            <span class="n">label</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">location</span><span class="si">}</span><span class="s2">: period&quot;</span><span class="p">,</span>
            <span class="n">lw</span><span class="o">=</span><span class="n">linewidth</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">sb</span><span class="o">.</span><span class="n">lineplot</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">dataset</span><span class="p">,</span>
            <span class="n">x</span><span class="o">=</span><span class="s2">&quot;date_to_dt&quot;</span><span class="p">,</span>
            <span class="n">color</span><span class="o">=</span><span class="n">color_i</span><span class="p">,</span>
            <span class="n">y</span><span class="o">=</span><span class="s2">&quot;cum&quot;</span><span class="p">,</span>
            <span class="n">label</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">location</span><span class="si">}</span><span class="s2">: cumulative&quot;</span><span class="p">,</span>
            <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;--&quot;</span><span class="p">,</span>
            <span class="n">lw</span><span class="o">=</span><span class="n">linewidth</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">ax</span> <span class="o">=</span> <span class="n">sb</span><span class="o">.</span><span class="n">scatterplot</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">dataset</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color_i</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="s2">&quot;date_to_dt&quot;</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="s2">&quot;net_vol_change&quot;</span>
        <span class="p">)</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">sb</span><span class="o">.</span><span class="n">scatterplot</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">dataset</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color_i</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="s2">&quot;date_to_dt&quot;</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="s2">&quot;cum&quot;</span><span class="p">)</span>

        <span class="n">x_start</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">dataset</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">date_from_dt</span><span class="p">,</span> <span class="n">dataset</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">date_to_dt</span><span class="p">])</span>
        <span class="n">y_start</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">dataset</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">cum</span><span class="p">])</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_start</span><span class="p">,</span> <span class="n">y_start</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">color_i</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">dataset</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">date_from_dt</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">color_i</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;*&quot;</span><span class="p">)</span>

    <span class="c1"># the zero horizontal line</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">axhline</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>

    <span class="n">ax</span><span class="o">.</span><span class="n">set</span><span class="p">(</span>
        <span class="n">xticks</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dataset_in</span><span class="o">.</span><span class="n">date_from_dt</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">dataset_in</span><span class="o">.</span><span class="n">date_to_dt</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">set_major_formatter</span><span class="p">(</span><span class="n">dates</span><span class="o">.</span><span class="n">DateFormatter</span><span class="p">(</span><span class="n">out_date_format</span><span class="p">))</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">(</span><span class="n">rotation</span><span class="o">=</span><span class="mi">90</span><span class="p">)</span>

    <span class="c1"># the plot x and y axis labels</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="n">xlabel</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="n">ylabel</span><span class="p">)</span>

    <span class="c1"># the title of the plot</span>
    <span class="n">f</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="n">suptitle</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">ax</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 class="doc doc-heading" id="sandpyper.common.prep_heatmap">
<code class="highlight language-python"><span class="n">prep_heatmap</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">lod</span><span class="p">,</span> <span class="n">outliers</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sigma_n</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span></code>


<a class="headerlink" href="#sandpyper.common.prep_heatmap" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Function to create a pivoted and filtered dataframe from multitemporal table of specific period-location combination (i.e. loc= pfa, dt= dt_3).
Elevation differences within LoD (uncertain) can be set to zero and outliers can be eliminated.
Each column is a transect and each row is a distance value along transect. Values are elevation differences.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This function is to be used on location-period specific slices of the multitemporal table.</p>
</div>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>df</code></td>
        <td><code>Pandas dataframe</code></td>
        <td><p>Location-period specific subset (filtered for a location and a timeperiod) of multitemporal table.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>lod</code></td>
        <td><code>path, value, False</code></td>
        <td><p>if valid path to an Limit of Detection table, use the table. If a value is provided, use the value across all surveys. If False, do not apply LoD filter. All elevation changes within +- LoD will be set to zero.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>outliers</code></td>
        <td><code></code></td>
        <td><p>when True, use the specified number of standard deviation to exclude outliers. If False, retain all the points.</p></td>
        <td><code>False</code></td>
      </tr>
      <tr>
        <td><code>sigma_n</code></td>
        <td><code>int</code></td>
        <td><p>number of standard deviation to use to exclude outliers (default=3).</p></td>
        <td><code>3</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>piv_df (pd.DataFrame)</code></td>
      <td><p>Pivoted and clean Pandas Dataframe, ready to be used to plot heatmaps and compute volumetrics.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>sandpyper\common.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">prep_heatmap</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">lod</span><span class="p">,</span> <span class="n">outliers</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sigma_n</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function to create a pivoted and filtered dataframe from multitemporal table of specific period-location combination (i.e. loc= pfa, dt= dt_3).</span>
<span class="sd">    Elevation differences within LoD (uncertain) can be set to zero and outliers can be eliminated.</span>
<span class="sd">    Each column is a transect and each row is a distance value along transect. Values are elevation differences.</span>

<span class="sd">    Warning:</span>
<span class="sd">        This function is to be used on location-period specific slices of the multitemporal table.</span>

<span class="sd">    Args:</span>
<span class="sd">        df (Pandas dataframe): Location-period specific subset (filtered for a location and a timeperiod) of multitemporal table.</span>
<span class="sd">        lod (path, value, False): if valid path to an Limit of Detection table, use the table. If a value is provided, use the value across all surveys. If False, do not apply LoD filter. All elevation changes within +- LoD will be set to zero.</span>
<span class="sd">        outliers: when True, use the specified number of standard deviation to exclude outliers. If False, retain all the points.</span>
<span class="sd">        sigma_n (int): number of standard deviation to use to exclude outliers (default=3).</span>

<span class="sd">    Returns:</span>
<span class="sd">        piv_df (pd.DataFrame): Pivoted and clean Pandas Dataframe, ready to be used to plot heatmaps and compute volumetrics.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># pivoting and sorting</span>

    <span class="c1"># add an int version of tr_id to sort better</span>
    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;int_tr&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">tr_id</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">a</span><span class="p">)),</span> <span class="n">convert_dtype</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">df</span><span class="o">.</span><span class="n">rename</span><span class="p">({</span><span class="s2">&quot;distance&quot;</span><span class="p">:</span> <span class="s2">&quot;dist&quot;</span><span class="p">},</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">df</span><span class="o">.</span><span class="n">dist</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">df</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;int_tr&quot;</span><span class="p">,</span> <span class="s2">&quot;dt&quot;</span><span class="p">,</span> <span class="s2">&quot;dist&quot;</span><span class="p">],</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># sort</span>
    <span class="n">df_piv</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">pivot</span><span class="p">(</span><span class="s2">&quot;dist&quot;</span><span class="p">,</span> <span class="s2">&quot;int_tr&quot;</span><span class="p">,</span> <span class="s2">&quot;dh&quot;</span><span class="p">)</span>
    <span class="n">df_piv</span> <span class="o">=</span> <span class="n">df_piv</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>

    <span class="n">df_piv</span><span class="o">.</span><span class="n">sort_index</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># sort columns, tr_id</span>
    <span class="n">df_piv</span><span class="o">.</span><span class="n">sort_index</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ascending</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># sort rows, distance</span>

    <span class="k">if</span> <span class="nb">bool</span><span class="p">(</span><span class="n">outliers</span><span class="p">):</span>
        <span class="c1"># eliminating outliers</span>

        <span class="c1"># find threshold for sigma outlier detection</span>
        <span class="n">thresh</span> <span class="o">=</span> <span class="n">sigma_n</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="n">df_piv</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>

        <span class="n">df_piv</span> <span class="o">=</span> <span class="n">df_piv</span><span class="p">[</span><span class="n">df_piv</span> <span class="o">&lt;</span> <span class="n">thresh</span><span class="p">]</span>  <span class="c1"># select only the values below the threshold</span>
        <span class="c1"># select only the negative values below the threshold</span>
        <span class="n">df_piv</span> <span class="o">=</span> <span class="n">df_piv</span><span class="p">[</span><span class="o">-</span><span class="n">df_piv</span> <span class="o">&lt;</span> <span class="n">thresh</span><span class="p">]</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lod</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">lod</span><span class="p">):</span>  <span class="c1"># if a valid path, ope the table and use it</span>

            <span class="c1"># applying LoDs</span>

            <span class="n">lod_table</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">lod</span><span class="p">)</span>  <span class="c1"># read in the lod table</span>
            <span class="n">loc</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">location</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">dt</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">lod_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">lod_table</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;location == &#39;</span><span class="si">{</span><span class="n">loc</span><span class="si">}</span><span class="s2">&#39; &amp; dt == &#39;</span><span class="si">{</span><span class="n">dt</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">lod</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">2</span><span class="p">)</span>
            <span class="c1"># create condition (within LoD) to mask the dataframe</span>
            <span class="n">cond</span> <span class="o">=</span> <span class="p">(</span><span class="n">df_piv</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="n">lod_i</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">df_piv</span> <span class="o">&lt;=</span> <span class="n">lod_i</span><span class="p">)</span>
            <span class="c1"># replace the values that satisfied the condition (within LoD) with zeroes</span>
            <span class="n">df_piv2</span> <span class="o">=</span> <span class="n">df_piv</span><span class="o">.</span><span class="n">mask</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">df_piv2</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="n">df_piv2</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">),</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">df_piv2</span><span class="o">.</span><span class="n">sort_index</span><span class="p">(</span><span class="n">ascending</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span>
                <span class="s2">&quot;Not a valid file or path.Please provide a valid path to the LoD table&quot;</span>
            <span class="p">)</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span>
        <span class="n">lod</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
    <span class="p">):</span>  <span class="c1"># if a numeric, use this value across all surveys</span>

        <span class="n">lod_i</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">lod</span><span class="p">)</span>
        <span class="n">cond</span> <span class="o">=</span> <span class="p">(</span><span class="n">df_piv</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="n">lod_i</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">df_piv</span> <span class="o">&lt;=</span> <span class="n">lod_i</span><span class="p">)</span>
        <span class="n">df_piv2</span> <span class="o">=</span> <span class="n">df_piv</span><span class="o">.</span><span class="n">mask</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">df_piv2</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="n">df_piv2</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">),</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">df_piv2</span><span class="o">.</span><span class="n">sort_index</span><span class="p">(</span><span class="n">ascending</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lod</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
        <span class="n">lod_table</span><span class="o">=</span><span class="n">lod</span>
        <span class="n">loc</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">location</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">lod_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">lod_table</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;location == &#39;</span><span class="si">{</span><span class="n">loc</span><span class="si">}</span><span class="s2">&#39; &amp; dt == &#39;</span><span class="si">{</span><span class="n">dt</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">lod</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">2</span><span class="p">)</span>
        <span class="c1"># create condition (within LoD) to mask the dataframe</span>
        <span class="n">cond</span> <span class="o">=</span> <span class="p">(</span><span class="n">df_piv</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="n">lod_i</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">df_piv</span> <span class="o">&lt;=</span> <span class="n">lod_i</span><span class="p">)</span>
        <span class="c1"># replace the values that satisfied the condition (within LoD) with zeroes</span>
        <span class="n">df_piv2</span> <span class="o">=</span> <span class="n">df_piv</span><span class="o">.</span><span class="n">mask</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">df_piv2</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="n">df_piv2</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">),</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>


        <span class="k">return</span> <span class="n">df_piv2</span><span class="o">.</span><span class="n">sort_index</span><span class="p">(</span><span class="n">ascending</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>  <span class="c1"># otherwise,don&#39;t use it</span>

        <span class="n">df_piv2</span> <span class="o">=</span> <span class="n">df_piv</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">df_piv2</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="n">df_piv2</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">),</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">df_piv2</span><span class="o">.</span><span class="n">sort_index</span><span class="p">(</span><span class="n">ascending</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</code></pre></div>
        </details>
    </div>

  </div>




  <div class="doc doc-object doc-function">



<h2 class="doc doc-heading" id="sandpyper.common.round_special">
<code class="highlight language-python"><span class="n">round_special</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">thr</span><span class="p">)</span></code>


<a class="headerlink" href="#sandpyper.common.round_special" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>It rounds the number (num) to its closest fraction of threshold (thr). Useful to space ticks in plots.</p>

        <details class="quote">
          <summary>Source code in <code>sandpyper\common.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">round_special</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">thr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;It rounds the number (num) to its closest fraction of threshold (thr). Useful to space ticks in plots.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">round</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="o">/</span> <span class="n">thr</span><span class="p">)</span> <span class="o">*</span> <span class="n">thr</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 class="doc doc-heading" id="sandpyper.common.s2_to_rgb">
<code class="highlight language-python"><span class="n">s2_to_rgb</span><span class="p">(</span><span class="n">imin</span><span class="p">,</span> <span class="n">scaler_range</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">),</span> <span class="n">re_size</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>


<a class="headerlink" href="#sandpyper.common.s2_to_rgb" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Transform image pixels into specified range. Used to obtain 8-bit RGB images.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>imin</code></td>
        <td><code>np.array</code></td>
        <td><p>image array to be transformed.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>scaler_range</code></td>
        <td><code>tuple</code></td>
        <td><p>(min,max) tuple with minimum and maximum brightness values. Defaults is 0-255.</p></td>
        <td><code>(0, 255)</code></td>
      </tr>
      <tr>
        <td><code>re_size</code></td>
        <td><code>False, tuple</code></td>
        <td><p>if a tuple of size 2 is provided, reshape the transformed array with the provided shape. Default to False.</p></td>
        <td><code>False</code></td>
      </tr>
      <tr>
        <td><code>dtype</code></td>
        <td><code>False, dtype</code></td>
        <td><p>optional data type for the transformed array. False, keep the original dtype.</p></td>
        <td><code>False</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>img_array_rgb (np.array)</code></td>
      <td><p>Transformed array.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>sandpyper\common.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">s2_to_rgb</span><span class="p">(</span><span class="n">imin</span><span class="p">,</span> <span class="n">scaler_range</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">),</span> <span class="n">re_size</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Transform image pixels into specified range. Used to obtain 8-bit RGB images.</span>

<span class="sd">    Args:</span>
<span class="sd">        imin (np.array): image array to be transformed.</span>
<span class="sd">        scaler_range (tuple): (min,max) tuple with minimum and maximum brightness values. Defaults is 0-255.</span>
<span class="sd">        re_size (False, tuple): if a tuple of size 2 is provided, reshape the transformed array with the provided shape. Default to False.</span>
<span class="sd">        dtype (False, dtype): optional data type for the transformed array. False, keep the original dtype.</span>
<span class="sd">    Returns:</span>
<span class="sd">        img_array_rgb (np.array): Transformed array.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">scaler</span> <span class="o">=</span> <span class="n">MinMaxScaler</span><span class="p">(</span><span class="n">scaler_range</span><span class="p">)</span>

    <span class="n">imo</span> <span class="o">=</span> <span class="n">ras</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">imin</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">dtype</span> <span class="o">!=</span> <span class="kc">False</span><span class="p">:</span>
        <span class="n">im</span> <span class="o">=</span> <span class="n">imo</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">out_dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">im</span> <span class="o">=</span> <span class="n">imo</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">re_size</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">)):</span>
        <span class="n">im</span> <span class="o">=</span> <span class="n">resize</span><span class="p">(</span>
            <span class="n">im</span><span class="p">,</span>
            <span class="p">(</span><span class="n">re_size</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">re_size</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">re_size</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span>
            <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;constant&quot;</span><span class="p">,</span>
            <span class="n">preserve_range</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>  <span class="c1"># resize image</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="k">if</span> <span class="n">imo</span><span class="o">.</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">im_rgb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">im</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">im</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">im</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">rgb_array_1</span> <span class="o">=</span> <span class="n">b</span> <span class="o">=</span> <span class="n">im_rgb</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">scaled_1</span> <span class="o">=</span> <span class="n">scaler</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">rgb_array_1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">img_array_rgb</span> <span class="o">=</span> <span class="n">scaled_1</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">im_rgb</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">img_array_rgb</span> <span class="o">=</span> <span class="n">im</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">re_size</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">)):</span>
        <span class="n">img_array_rgb</span> <span class="o">=</span> <span class="n">resize</span><span class="p">(</span>
            <span class="n">im</span><span class="p">,</span>
            <span class="p">(</span><span class="n">re_size</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">re_size</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">re_size</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span>
            <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;constant&quot;</span><span class="p">,</span>
            <span class="n">preserve_range</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>  <span class="c1"># resize image</span>

    <span class="k">return</span> <span class="n">img_array_rgb</span>
</code></pre></div>
        </details>
    </div>

  </div>




  <div class="doc doc-object doc-function">



<h2 class="doc doc-heading" id="sandpyper.common.sensitivity_tr_rbcd">
<code class="highlight language-python"><span class="n">sensitivity_tr_rbcd</span><span class="p">(</span><span class="n">ProfileDynamics</span><span class="p">,</span> <span class="n">test_thresholds</span><span class="o">=</span><span class="s1">&#39;max&#39;</span><span class="p">,</span> <span class="n">test_min_pts</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span></code>


<a class="headerlink" href="#sandpyper.common.sensitivity_tr_rbcd" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Performs a sensitivity analysis of the transect-level r-BCDs values in respect to both the min_points and thresh parameters.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>ProfileDynamics</code></td>
        <td><code>object</code></td>
        <td><p>The ProfileDynamics object to perform sensitivity analysis on.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>test_thresholds</code></td>
        <td><code>str, list</code></td>
        <td><p>If a list is provided, the list must contain the starting thresh value, the last one and the interval between the two, just like numpy.arange function expects, like [0,10,2]. If 'max', then tests on all the available timeperiods.</p></td>
        <td><code>&#39;max&#39;</code></td>
      </tr>
      <tr>
        <td><code>test_min_pts</code></td>
        <td><code>list</code></td>
        <td><p>A list containing the starting min_pts value, the last one and the interval between the two, just like numpy.arange function expects, like [0,100,10].</p></td>
        <td><code>[0, 10, 2]</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>ss_tr_big (pd.DataFrame)</code></td>
      <td><p>A dataframe storing the transect r-BCD values of all combinations of thresh and min_points.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>sandpyper\common.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">sensitivity_tr_rbcd</span><span class="p">(</span><span class="n">ProfileDynamics</span><span class="p">,</span>
                       <span class="n">test_thresholds</span><span class="o">=</span><span class="s1">&#39;max&#39;</span><span class="p">,</span>
                       <span class="n">test_min_pts</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">2</span><span class="p">]):</span>
    <span class="sd">&quot;&quot;&quot;Performs a sensitivity analysis of the transect-level r-BCDs values in respect to both the min_points and thresh parameters.</span>

<span class="sd">    Args:</span>
<span class="sd">        ProfileDynamics (object): The ProfileDynamics object to perform sensitivity analysis on.</span>
<span class="sd">        test_thresholds (str, list): If a list is provided, the list must contain the starting thresh value, the last one and the interval between the two, just like numpy.arange function expects, like [0,10,2]. If &#39;max&#39;, then tests on all the available timeperiods.</span>
<span class="sd">        test_min_pts (list): A list containing the starting min_pts value, the last one and the interval between the two, just like numpy.arange function expects, like [0,100,10].</span>

<span class="sd">    Returns:</span>
<span class="sd">        ss_tr_big (pd.DataFrame): A dataframe storing the transect r-BCD values of all combinations of thresh and min_points.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">ProfileDynamics</span><span class="o">.</span><span class="n">df_labelled</span>
    <span class="n">ss_tr_big</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">loc</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">location</span><span class="o">.</span><span class="n">unique</span><span class="p">():</span>
        <span class="n">data_in</span><span class="o">=</span><span class="n">df</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;location==&#39;</span><span class="si">{</span><span class="n">loc</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Working on </span><span class="si">{</span><span class="n">loc</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">test_thresholds</span><span class="o">==</span><span class="s1">&#39;max&#39;</span><span class="p">:</span>
            <span class="n">range_thresh</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">data_in</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">range_thresh</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="o">*</span><span class="n">test_thresholds</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">test_min_pts</span><span class="o">==</span><span class="kc">None</span><span class="p">:</span>
            <span class="n">range_min_pts</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">range_min_pts</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="o">*</span><span class="n">test_min_pts</span><span class="p">)</span>

        <span class="n">combs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">range_min_pts</span><span class="p">,</span><span class="n">range_thresh</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;A total of </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">combs</span><span class="p">)</span><span class="si">}</span><span class="s2"> combinations of thresholds and min_pts will be computed.&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">combs</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Working on threshold </span><span class="si">{</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2"> and min points </span><span class="si">{</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
            <span class="n">tmp_loc_specs_dict</span><span class="o">=</span><span class="p">{</span><span class="n">loc</span><span class="p">:{</span><span class="s1">&#39;thresh&#39;</span><span class="p">:</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                            <span class="s1">&#39;min_points&#39;</span><span class="p">:</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]}}</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">ss_transects_idx</span> <span class="o">=</span> <span class="n">get_rbcd_transect</span><span class="p">(</span><span class="n">df_labelled</span><span class="o">=</span><span class="n">data_in</span><span class="p">,</span>
                      <span class="n">loc_specs</span><span class="o">=</span><span class="n">tmp_loc_specs_dict</span><span class="p">,</span> <span class="n">reliable_action</span><span class="o">=</span><span class="s1">&#39;drop&#39;</span><span class="p">,</span>
                      <span class="n">dirNameTrans</span><span class="o">=</span><span class="n">ProfileDynamics</span><span class="o">.</span><span class="n">ProfileSet</span><span class="o">.</span><span class="n">dirNameTrans</span><span class="p">,</span>
                      <span class="n">labels_order</span><span class="o">=</span><span class="n">ProfileDynamics</span><span class="o">.</span><span class="n">tags_order</span><span class="p">,</span>
                      <span class="n">loc_codes</span><span class="o">=</span><span class="n">ProfileDynamics</span><span class="o">.</span><span class="n">ProfileSet</span><span class="o">.</span><span class="n">loc_codes</span><span class="p">,</span>
                      <span class="n">crs_dict_string</span><span class="o">=</span><span class="n">ProfileDynamics</span><span class="o">.</span><span class="n">ProfileSet</span><span class="o">.</span><span class="n">crs_dict_string</span><span class="p">)</span>

                <span class="n">ss_transects_idx</span><span class="p">[</span><span class="s1">&#39;thresh&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">ss_transects_idx</span><span class="p">[</span><span class="s1">&#39;min_pts&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

                <span class="n">ss_tr_big</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">ss_tr_big</span><span class="p">,</span><span class="n">ss_transects_idx</span><span class="p">],</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;errore&quot;</span><span class="p">)</span>

                <span class="k">pass</span>

    <span class="k">return</span> <span class="n">ss_tr_big</span>
</code></pre></div>
        </details>
    </div>

  </div>




  <div class="doc doc-object doc-function">



<h2 class="doc doc-heading" id="sandpyper.common.shoreline_from_prediction">
<code class="highlight language-python"><span class="n">shoreline_from_prediction</span><span class="p">(</span><span class="n">prediction</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">geotransform</span><span class="p">,</span> <span class="n">min_vertices</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="mi">64</span><span class="p">))</span></code>


<a class="headerlink" href="#sandpyper.common.shoreline_from_prediction" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Obtain a georeferenced shoreline in a GeoDataFrame from a binary predicted water mask.
Credits: adapted from Dr. Robbie Bishop-Taylor functions in Digital Earth Australia scripts, available at:
https://github.com/GeoscienceAustralia/dea-notebooks/blob/develop/Scripts/dea_coastaltools.py</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>prediction</code></td>
        <td><code>array</code></td>
        <td><p>array to be thresholded.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>z</code></td>
        <td><code>int, float</code></td>
        <td><p>threshold value to separate land and water from the prediction array.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>geotransform</code></td>
        <td><code>tuple</code></td>
        <td><p>uple with Shapely transform parameters.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>min_vertices</code></td>
        <td><code>int</code></td>
        <td><p>Minimum number of vertices a segment has to have to be retained as a shoreline. Default to 2.</p></td>
        <td><code>2</code></td>
      </tr>
      <tr>
        <td><code>shape</code></td>
        <td><code>data type object</code></td>
        <td><p>Shape of the array. Default to (64,64).</p></td>
        <td><code>(64, 64)</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code></code></td>
      <td><p>Geodataframe with georeferenced shoreline.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>sandpyper\common.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">shoreline_from_prediction</span><span class="p">(</span>
    <span class="n">prediction</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">geotransform</span><span class="p">,</span> <span class="n">min_vertices</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Obtain a georeferenced shoreline in a GeoDataFrame from a binary predicted water mask.</span>
<span class="sd">    Credits: adapted from Dr. Robbie Bishop-Taylor functions in Digital Earth Australia scripts, available at:</span>
<span class="sd">    https://github.com/GeoscienceAustralia/dea-notebooks/blob/develop/Scripts/dea_coastaltools.py</span>

<span class="sd">    Args:</span>
<span class="sd">        prediction (array): array to be thresholded.</span>
<span class="sd">        z (int, float): threshold value to separate land and water from the prediction array.</span>
<span class="sd">        geotransform (tuple): uple with Shapely transform parameters.</span>
<span class="sd">        min_vertices (int): Minimum number of vertices a segment has to have to be retained as a shoreline. Default to 2.</span>
<span class="sd">        shape (data type object): Shape of the array. Default to (64,64).</span>
<span class="sd">    Returns:</span>
<span class="sd">        Geodataframe with georeferenced shoreline.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># get shoreline</span>
    <span class="n">shore_arr</span> <span class="o">=</span> <span class="n">contours_to_multiline</span><span class="p">(</span>
        <span class="n">prediction</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">),</span> <span class="n">z</span><span class="p">,</span> <span class="n">min_vertices</span><span class="o">=</span><span class="n">min_vertices</span>
    <span class="p">)</span>

    <span class="c1"># create geoseries and geodataframe</span>
    <span class="n">shore_arr_geoseries</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoSeries</span><span class="p">(</span><span class="n">shore_arr</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;geometry&quot;</span><span class="p">)</span>
    <span class="n">contours_gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span><span class="n">shore_arr_geoseries</span><span class="p">,</span> <span class="n">geometry</span><span class="o">=</span><span class="s2">&quot;geometry&quot;</span><span class="p">)</span>

    <span class="c1"># georeference line using tile geotransform</span>
    <span class="n">contours_gdf</span><span class="p">[</span><span class="s2">&quot;geometry&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">contours_gdf</span><span class="o">.</span><span class="n">affine_transform</span><span class="p">(</span><span class="n">shapely_affine</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">contours_gdf</span>
</code></pre></div>
        </details>
    </div>

  </div>




  <div class="doc doc-object doc-function">



<h2 class="doc doc-heading" id="sandpyper.common.split_transects">
<code class="highlight language-python"><span class="n">split_transects</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">)</span></code>


<a class="headerlink" href="#sandpyper.common.split_transects" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Helper function to split a transect geometry along its centroid, retaining only their left (default) or right side.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>geom</code></td>
        <td><code>geometry</code></td>
        <td><p>geometry (shapely LineString) of the transect to split.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>side</code></td>
        <td><code>str</code></td>
        <td><p>side to keep ('left' or 'right').</p></td>
        <td><code>&#39;left&#39;</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>geometry</code></td>
      <td><p>New geometry split.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>sandpyper\common.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">split_transects</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Helper function to split a transect geometry along its centroid, retaining only their left (default) or right side.</span>

<span class="sd">    args:</span>
<span class="sd">        geom (geometry): geometry (shapely LineString) of the transect to split.</span>
<span class="sd">        side (str): side to keep (&#39;left&#39; or &#39;right&#39;).</span>

<span class="sd">    returns:</span>
<span class="sd">        geometry: New geometry split.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">side_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;left&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;right&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span>
    <span class="n">snapped</span> <span class="o">=</span> <span class="n">snap</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">geom</span><span class="o">.</span><span class="n">centroid</span><span class="p">,</span> <span class="mf">0.001</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">split</span><span class="p">(</span><span class="n">snapped</span><span class="p">,</span> <span class="n">geom</span><span class="o">.</span><span class="n">centroid</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">[</span><span class="n">side_dict</span><span class="p">[</span><span class="n">side</span><span class="p">]]</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 class="doc doc-heading" id="sandpyper.common.test_format">
<code class="highlight language-python"><span class="n">test_format</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">loc_search_dict</span><span class="p">)</span></code>


<a class="headerlink" href="#sandpyper.common.test_format" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>It returns True if the filename matches the required format (regx) or False if it doesn't.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>filename</code></td>
        <td><code>str</code></td>
        <td><p>filename to test, of the type "Seaspray_22_Oct_2020_GeoTIFF_DSM_GDA94_MGA_zone_55.tiff".</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>loc_search_dict</code></td>
        <td><code>dict</code></td>
        <td><p>a dictionary where keys are the location codes and values are lists containing the expected full location string (["Warrnambool", "warrnambool","warrny"]).</p></td>
        <td><em>required</em></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>bool (bool)</code></td>
      <td><p>True if the filename matches the required format (regx) or False if it doesn't.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>sandpyper\common.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">test_format</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">loc_search_dict</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    It returns True if the filename matches the required format (regx) or False if it doesn&#39;t.</span>

<span class="sd">    Args:</span>
<span class="sd">        filename (str): filename to test, of the type &quot;Seaspray_22_Oct_2020_GeoTIFF_DSM_GDA94_MGA_zone_55.tiff&quot;.</span>
<span class="sd">        loc_search_dict (dict): a dictionary where keys are the location codes and values are lists containing the expected full location string ([&quot;Warrnambool&quot;, &quot;warrnambool&quot;,&quot;warrny&quot;]).</span>
<span class="sd">    Returns:</span>
<span class="sd">        bool (bool): True if the filename matches the required format (regx) or False if it doesn&#39;t.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">re_list_loc</span> <span class="o">=</span> <span class="s2">&quot;|&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">loc_search_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="n">regx</span> <span class="o">=</span> <span class="sa">rf</span><span class="s2">&quot;\d</span><span class="se">{{</span><span class="s2">8</span><span class="se">}}</span><span class="s2">_(</span><span class="si">{</span><span class="n">re_list_loc</span><span class="si">}</span><span class="s2">)_(ortho|dsm)\.(tiff|tif)&quot;</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">regx</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span><span class="o">.</span><span class="n">group</span><span class="p">()</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 class="doc doc-heading" id="sandpyper.common.tidal_correction">
<code class="highlight language-python"><span class="n">tidal_correction</span><span class="p">(</span><span class="n">shoreline</span><span class="p">,</span> <span class="n">cs_shores</span><span class="p">,</span> <span class="n">gdf</span><span class="p">,</span> <span class="n">baseline_folder</span><span class="p">,</span> <span class="n">crs_dict_string</span><span class="p">,</span> <span class="n">limit_correction</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">alongshore_resolution</span><span class="p">,</span> <span class="n">slope_value</span><span class="o">=</span><span class="s1">&#39;median&#39;</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s1">&#39;both&#39;</span><span class="p">,</span> <span class="n">tick_length</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">subset_loc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">limit_vertex</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">baseline_threshold</span><span class="o">=</span><span class="s1">&#39;infer&#39;</span><span class="p">,</span> <span class="n">replace_slope_outliers</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">save_trs_details</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">trs_details_folder</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">gdf_date_field</span><span class="o">=</span><span class="s1">&#39;raw_date&#39;</span><span class="p">,</span> <span class="n">distance_field</span><span class="o">=</span><span class="s1">&#39;distance&#39;</span><span class="p">,</span> <span class="n">date_field</span><span class="o">=</span><span class="s1">&#39;raw_date&#39;</span><span class="p">,</span> <span class="n">toe_field</span><span class="o">=</span><span class="s1">&#39;toe&#39;</span><span class="p">)</span></code>


<a class="headerlink" href="#sandpyper.common.tidal_correction" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Simple tidal correction for input shorelines. It can automatically extract subaerial beachfaces and more.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>shoreline</code></td>
        <td><code>gpd.GeoDataFrame</code></td>
        <td><p>The geodataframe storing points along a shoreline.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>cs_shores</code></td>
        <td><code>gpd.GeoDataFrame</code></td>
        <td><p>The width and height of each single tile of the grid, given in the CRS unit (use projected CRS).</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>gdf</code></td>
        <td><code>gpd.GeoDataFrame</code></td>
        <td><p>Coordinate Reference System in the dictionary format (example: {'init' :'epsg:4326'})</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>baseline_folder</code></td>
        <td><code>str</code></td>
        <td><p>Path to the folder storing the baseline Geopackages (.gpkgs).</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>crs_dict_string</code></td>
        <td><code>dict</code></td>
        <td><p>Dictionary storing location codes as key and crs information as EPSG code (int).</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>limit_correction</code></td>
        <td><code>bool</code></td>
        <td><p>If True, only use beachface slopes to compute the statistic for tidal correction. When False, retain the full transects to compute the slope statistics to correct shorelines. When a slope value is provided, it automatically sets to False. Defaults to True.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>mode</code></td>
        <td><code>str</code></td>
        <td><p>If 'sat', use satellite shorelines as seaward edge to classify beachfaces. If 'gt', use groundthruth shorelines instead.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>alongshore_resolution</code></td>
        <td><code>str, float</code></td>
        <td><p>The alongshore spacing between transects, in the unit of measure of the location CRS. If 'infer', use the gdf file to detect the spacing with 10cm precision. If the transects spacing is less than 10cm, set the spacing manually. Note: It also smoothes the original line if this value is greater of the original line vertex spacing.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>slope_value</code></td>
        <td><code>int,float,&#39;mean&#39;,&#39;median&#39;,&#39;min&#39;,&#39;max&#39;</code></td>
        <td><p>If a numeric value is provided (assumed to be in degrees), use it to correct the shorelines. If one of 'mean','median','min','max', use this statistics instead. It also computes range, standard deviation and variance for analytical purposes, despite should not be used to correct shorelines.</p></td>
        <td><code>&#39;median&#39;</code></td>
      </tr>
      <tr>
        <td><code>side</code></td>
        <td><code>str, &#39;left&#39;, &#39;right&#39;, &#39;both&#39;</code></td>
        <td><p>Whether if retain only the left, right or both sides of the transects once created. Defaults to 'both'.</p></td>
        <td><code>&#39;both&#39;</code></td>
      </tr>
      <tr>
        <td><code>tick_length</code></td>
        <td><code>int, float</code></td>
        <td><p>Across-shore length of each transect in the unit of measure of the location CRS.</p></td>
        <td><code>200</code></td>
      </tr>
      <tr>
        <td><code>limit_vertex</code></td>
        <td><code>int</code></td>
        <td><p>Sets the minimum number of consecutive transect ids to create one segment of the corrected shoreline. Defaults to 1.</p></td>
        <td><code>1</code></td>
      </tr>
      <tr>
        <td><code>baseline_threshold</code></td>
        <td><code>&#34;infer&#34;, float, None</code></td>
        <td><p>If a number is provided, it sets the minimum distance the original un-corrected and the tidal-corrected shorelines must be in order to consider the correction valid. If the distance between the original the tidal-corrected shorelines at one point is less than this value, then the original shoreline is retained. If it is above, then the tidal-corrected value is retained. This is done to avoid to correct areas where an artificial shoreline   occurs (seawalls or harbours). If "infer", then the Otsu method is used to find this threshold value. This option works where artificial shorelines are present. If None, do not use this option. Default to "infer".</p></td>
        <td><code>&#39;infer&#39;</code></td>
      </tr>
      <tr>
        <td><code>replace_slope_outliers</code></td>
        <td><code>bool</code></td>
        <td><p>If True (default), replace the values of the defined slope statistics (slope_value parameter) with its survey-level median.</p></td>
        <td><code>True</code></td>
      </tr>
      <tr>
        <td><code>save_trs_details</code></td>
        <td><code>bool</code></td>
        <td><p>True to save a .CSV file with transect-specific information. It defaults to False.</p></td>
        <td><code>False</code></td>
      </tr>
      <tr>
        <td><code>trs_details_folder</code></td>
        <td><code>str</code></td>
        <td><p>Folder where to save the transect details. Defaults to None.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>gdf_date_field</code></td>
        <td><code>str</code></td>
        <td><p>Date field of the slope geodataframe used to correct the shoreline.Defaults to "raw_date".</p></td>
        <td><code>&#39;raw_date&#39;</code></td>
      </tr>
      <tr>
        <td><code>distance_field</code></td>
        <td><code>str</code></td>
        <td><p>Field storing the distance values. Default to "distance".</p></td>
        <td><code>&#39;distance&#39;</code></td>
      </tr>
      <tr>
        <td><code>date_field</code></td>
        <td><code>str</code></td>
        <td><p>Field storing the survey date values. Default to "raw_date".</p></td>
        <td><code>&#39;raw_date&#39;</code></td>
      </tr>
      <tr>
        <td><code>toe_field</code></td>
        <td><code>str</code></td>
        <td><p>Field storing the toe distances values. Default to "toe".</p></td>
        <td><code>&#39;toe&#39;</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>corr_shorelines (gpd.GeoDataFrame)</code></td>
      <td><p>GeoDataFrame containing both the original shorelines and the corrected ones, stored in two different geometry fields.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>sandpyper\common.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">tidal_correction</span><span class="p">(</span>
    <span class="n">shoreline</span><span class="p">,</span>
    <span class="n">cs_shores</span><span class="p">,</span>
    <span class="n">gdf</span><span class="p">,</span>
    <span class="n">baseline_folder</span><span class="p">,</span>
    <span class="n">crs_dict_string</span><span class="p">,</span>
    <span class="n">limit_correction</span><span class="p">,</span>
    <span class="n">mode</span><span class="p">,</span>
    <span class="n">alongshore_resolution</span><span class="p">,</span>
    <span class="n">slope_value</span><span class="o">=</span><span class="s2">&quot;median&quot;</span><span class="p">,</span>
    <span class="n">side</span><span class="o">=</span><span class="s2">&quot;both&quot;</span><span class="p">,</span>
    <span class="n">tick_length</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span>
    <span class="n">subset_loc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">limit_vertex</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">baseline_threshold</span><span class="o">=</span><span class="s2">&quot;infer&quot;</span><span class="p">,</span>
    <span class="n">replace_slope_outliers</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">save_trs_details</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">trs_details_folder</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">gdf_date_field</span><span class="o">=</span><span class="s2">&quot;raw_date&quot;</span><span class="p">,</span>
    <span class="n">distance_field</span><span class="o">=</span><span class="s2">&quot;distance&quot;</span><span class="p">,</span>
    <span class="n">date_field</span><span class="o">=</span><span class="s2">&quot;raw_date&quot;</span><span class="p">,</span>  <span class="c1"># of transect geodataframe</span>
    <span class="n">toe_field</span><span class="o">=</span><span class="s2">&quot;toe&quot;</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Simple tidal correction for input shorelines. It can automatically extract subaerial beachfaces and more.</span>

<span class="sd">    Args:</span>
<span class="sd">        shoreline (gpd.GeoDataFrame): The geodataframe storing points along a shoreline.</span>
<span class="sd">        cs_shores (gpd.GeoDataFrame): The width and height of each single tile of the grid, given in the CRS unit (use projected CRS).</span>
<span class="sd">        gdf (gpd.GeoDataFrame): Coordinate Reference System in the dictionary format (example: {&#39;init&#39; :&#39;epsg:4326&#39;})</span>
<span class="sd">        baseline_folder (str): Path to the folder storing the baseline Geopackages (.gpkgs).</span>
<span class="sd">        crs_dict_string (dict): Dictionary storing location codes as key and crs information as EPSG code (int).</span>
<span class="sd">        limit_correction (bool): If True, only use beachface slopes to compute the statistic for tidal correction. When False, retain the full transects to compute the slope statistics to correct shorelines. When a slope value is provided, it automatically sets to False. Defaults to True.</span>
<span class="sd">        mode (str): If &#39;sat&#39;, use satellite shorelines as seaward edge to classify beachfaces. If &#39;gt&#39;, use groundthruth shorelines instead.</span>
<span class="sd">        alongshore_resolution (str, float): The alongshore spacing between transects, in the unit of measure of the location CRS. If &#39;infer&#39;, use the gdf file to detect the spacing with 10cm precision. If the transects spacing is less than 10cm, set the spacing manually. Note: It also smoothes the original line if this value is greater of the original line vertex spacing.</span>
<span class="sd">        slope_value (int,float,&#39;mean&#39;,&#39;median&#39;,&#39;min&#39;,&#39;max&#39;): If a numeric value is provided (assumed to be in degrees), use it to correct the shorelines. If one of &#39;mean&#39;,&#39;median&#39;,&#39;min&#39;,&#39;max&#39;, use this statistics instead. It also computes range, standard deviation and variance for analytical purposes, despite should not be used to correct shorelines.</span>
<span class="sd">        side (str, &#39;left&#39;, &#39;right&#39;, &#39;both&#39;): Whether if retain only the left, right or both sides of the transects once created. Defaults to &#39;both&#39;.</span>
<span class="sd">        tick_length (int, float): Across-shore length of each transect in the unit of measure of the location CRS.</span>
<span class="sd">        subset_loc (list). List of string of location codes to limit the correction. Default to None.</span>
<span class="sd">        limit_vertex (int): Sets the minimum number of consecutive transect ids to create one segment of the corrected shoreline. Defaults to 1.</span>
<span class="sd">        baseline_threshold (&quot;infer&quot;, float, None): If a number is provided, it sets the minimum distance the original un-corrected and the tidal-corrected shorelines must be in order to consider the correction valid. If the distance between the original the tidal-corrected shorelines at one point is less than this value, then the original shoreline is retained. If it is above, then the tidal-corrected value is retained. This is done to avoid to correct areas where an artificial shoreline   occurs (seawalls or harbours). If &quot;infer&quot;, then the Otsu method is used to find this threshold value. This option works where artificial shorelines are present. If None, do not use this option. Default to &quot;infer&quot;.</span>
<span class="sd">        replace_slope_outliers (bool): If True (default), replace the values of the defined slope statistics (slope_value parameter) with its survey-level median.</span>
<span class="sd">        save_trs_details (bool): True to save a .CSV file with transect-specific information. It defaults to False.</span>
<span class="sd">        trs_details_folder (str): Folder where to save the transect details. Defaults to None.</span>
<span class="sd">        gdf_date_field (str): Date field of the slope geodataframe used to correct the shoreline.Defaults to &quot;raw_date&quot;.</span>
<span class="sd">        distance_field (str): Field storing the distance values. Default to &quot;distance&quot;.</span>
<span class="sd">        date_field (str): Field storing the survey date values. Default to &quot;raw_date&quot;.</span>
<span class="sd">        toe_field (str): Field storing the toe distances values. Default to &quot;toe&quot;.</span>

<span class="sd">    Returns:</span>
<span class="sd">        corr_shorelines (gpd.GeoDataFrame): GeoDataFrame containing both the original shorelines and the corrected ones, stored in two different geometry fields.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">slope_value</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
        <span class="n">limit_correction</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">extract_slope</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;User-defined slope value of </span><span class="si">{</span><span class="n">slope_value</span><span class="si">}</span><span class="s2"> degrees will be used to correct shorelines. No beachfaces extracted.&quot;</span>
        <span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">limit_correction</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">extract_slope</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">if</span> <span class="n">limit_correction</span><span class="p">:</span>
        <span class="n">limited</span> <span class="o">=</span> <span class="s2">&quot;limited&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">limited</span> <span class="o">=</span> <span class="s2">&quot;notlimited&quot;</span>

    <span class="k">if</span> <span class="s2">&quot;water_index&quot;</span> <span class="ow">in</span> <span class="n">shoreline</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="n">dataset_type</span> <span class="o">=</span> <span class="s2">&quot;uavs_hores&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dataset_type</span> <span class="o">=</span> <span class="s2">&quot;satellite_shores&quot;</span>

    <span class="n">grouping_fields</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="s2">&quot;water_index&quot;</span><span class="p">,</span> <span class="s2">&quot;thr_type&quot;</span><span class="p">,</span> <span class="s2">&quot;raw_date&quot;</span><span class="p">,</span> <span class="s2">&quot;location&quot;</span><span class="p">])</span>
    <span class="n">cols</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">shoreline</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>

    <span class="n">group_by_fields</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">cols</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">grouping_fields</span><span class="p">))</span>

    <span class="c1"># __________________ TIDAL CORRECTION_____________________________________</span>

    <span class="n">big_final</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>

    <span class="n">list_locations</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">location</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>  <span class="c1"># list the locations in the GDF file</span>

    <span class="k">for</span> <span class="n">location</span> <span class="ow">in</span> <span class="n">list_locations</span><span class="p">:</span>  <span class="c1"># work iteratively on each location</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;working on </span><span class="si">{</span><span class="n">location</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">alongshore_resolution</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Transect spacing set manually (alongshore resolution) = </span><span class="si">{</span><span class="n">alongshore_resolution</span><span class="si">}</span><span class="s2"> .&quot;</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">alongshore_resolution</span> <span class="o">==</span> <span class="s2">&quot;infer&quot;</span><span class="p">:</span>

            <span class="n">alongshore_resolution</span> <span class="o">=</span> <span class="n">infer_along_trs_spacing</span><span class="p">(</span><span class="n">gdf</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Transect spacing (alongshore resolution) inferred = </span><span class="si">{</span><span class="n">alongshore_resolution</span><span class="si">}</span><span class="s2"> .&quot;</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span>
                <span class="s2">&quot;Alongshore resolution must be either a float, int, or &#39;infer&#39;.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># get dates of location</span>
        <span class="n">list_dates</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;location==&#39;</span><span class="si">{</span><span class="n">location</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">raw_date</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
        <span class="n">shores_to_corr</span> <span class="o">=</span> <span class="n">shoreline</span><span class="o">.</span><span class="n">query</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;location==&#39;</span><span class="si">{</span><span class="n">location</span><span class="si">}</span><span class="s2">&#39; &amp; raw_date in @list_dates&quot;</span>
        <span class="p">)</span>  <span class="c1"># get shores to correct</span>
        <span class="n">gt_shores</span> <span class="o">=</span> <span class="n">cs_shores</span><span class="o">.</span><span class="n">query</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;location==&#39;</span><span class="si">{</span><span class="n">location</span><span class="si">}</span><span class="s2">&#39; &amp; raw_date in @list_dates&quot;</span>
        <span class="p">)</span>  <span class="c1"># get groudtruths shores</span>
        <span class="n">crs</span> <span class="o">=</span> <span class="n">crs_dict_string</span><span class="p">[</span><span class="n">loc</span><span class="p">]</span>    <span class="c1"># get crs of location</span>

        <span class="k">if</span> <span class="n">shores_to_corr</span><span class="o">.</span><span class="n">crs</span> <span class="o">!=</span> <span class="n">crs</span><span class="p">:</span>
            <span class="n">shores_to_corr</span> <span class="o">=</span> <span class="n">shores_to_corr</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span><span class="n">crs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="k">if</span> <span class="n">gt_shores</span><span class="o">.</span><span class="n">crs</span> <span class="o">!=</span> <span class="n">crs</span><span class="p">:</span>
            <span class="n">gt_shores</span> <span class="o">=</span> <span class="n">gt_shores</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span><span class="n">crs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="c1"># read baseline as a GeoDataFrame</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">baseline_location_path</span> <span class="o">=</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">baseline_folder</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">location</span><span class="si">}</span><span class="s2">*.gpkg&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">BaseException</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s2">&quot;Baseline file not found.&quot;</span><span class="p">)</span>
        <span class="n">baseline</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="n">baseline_location_path</span><span class="p">,</span> <span class="n">crs</span><span class="o">=</span><span class="n">crs</span><span class="p">)</span>

        <span class="c1"># create transects  # same parameter as the slope extraction. TO DO: if</span>
        <span class="c1"># exists, use existing data.</span>
        <span class="n">transects</span> <span class="o">=</span> <span class="n">create_transects</span><span class="p">(</span>
            <span class="n">baseline</span><span class="o">=</span><span class="n">baseline</span><span class="p">,</span>
            <span class="n">side</span><span class="o">=</span><span class="n">side</span><span class="p">,</span>
            <span class="n">sampling_step</span><span class="o">=</span><span class="n">alongshore_resolution</span><span class="p">,</span>
            <span class="n">tick_length</span><span class="o">=</span><span class="n">tick_length</span><span class="p">,</span>
            <span class="n">location</span><span class="o">=</span><span class="n">location</span><span class="p">,</span>
            <span class="n">crs</span><span class="o">=</span><span class="n">crs</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># 1)_____________________________________________CREATE THE BASELINE POINT</span>

        <span class="c1"># create a geodataframe of transects starting points to compute distance from</span>

        <span class="n">df_tmp</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span>
            <span class="p">{</span>
                <span class="s2">&quot;geometry&quot;</span><span class="p">:</span> <span class="p">[</span>
                    <span class="n">Point</span><span class="p">(</span><span class="n">tr_geom</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">tr_geom</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
                    <span class="k">for</span> <span class="n">tr_geom</span> <span class="ow">in</span> <span class="n">transects</span><span class="o">.</span><span class="n">geometry</span>
                <span class="p">],</span>
                <span class="s2">&quot;tr_id&quot;</span><span class="p">:</span> <span class="n">transects</span><span class="o">.</span><span class="n">tr_id</span><span class="p">,</span>
                <span class="s2">&quot;location&quot;</span><span class="p">:</span> <span class="n">location</span><span class="p">,</span>
            <span class="p">}</span>
        <span class="p">)</span>
        <span class="n">baseline_pts</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span><span class="n">df_tmp</span><span class="p">,</span> <span class="n">geometry</span><span class="o">=</span><span class="s2">&quot;geometry&quot;</span><span class="p">,</span> <span class="n">crs</span><span class="o">=</span><span class="n">crs</span><span class="p">)</span>

        <span class="c1"># loop through all transects in each satellite shoreline to compute</span>
        <span class="c1"># distances from the baseline points</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Computing cross-shore distances of satellite shorelines.&quot;</span><span class="p">)</span>

        <span class="n">orig_shore_base_distances</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">shores_to_corr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
            <span class="c1"># if &quot;water_index&quot; column is present, we will need to group based on water</span>
            <span class="c1"># indices and threshold types too</span>

            <span class="n">original_shore</span> <span class="o">=</span> <span class="n">shores_to_corr</span><span class="o">.</span><span class="n">iloc</span><span class="p">[[</span><span class="n">i</span><span class="p">]][[</span><span class="o">*</span><span class="n">group_by_fields</span><span class="p">,</span> <span class="s2">&quot;geometry&quot;</span><span class="p">]]</span>

            <span class="n">original_shore_pts</span> <span class="o">=</span> <span class="n">extract_shore_pts</span><span class="p">(</span>
                <span class="n">transects</span><span class="p">,</span> <span class="n">original_shore</span><span class="p">,</span> <span class="n">date_field</span><span class="o">=</span><span class="s2">&quot;raw_date&quot;</span><span class="p">,</span> <span class="n">crs</span><span class="o">=</span><span class="n">crs</span>
            <span class="p">)</span>

            <span class="n">matched</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span>
                <span class="n">original_shore_pts</span><span class="p">,</span>
                <span class="n">baseline_pts</span><span class="p">,</span>
                <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">,</span>
                <span class="n">on</span><span class="o">=</span><span class="s2">&quot;tr_id&quot;</span><span class="p">,</span>
                <span class="n">suffixes</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;_pt_on_shore&quot;</span><span class="p">,</span> <span class="s2">&quot;_pt_on_base&quot;</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="n">dists</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">shore_pt</span><span class="p">,</span> <span class="n">base_pt</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                <span class="n">matched</span><span class="o">.</span><span class="n">geometry_pt_on_shore</span><span class="p">,</span> <span class="n">matched</span><span class="o">.</span><span class="n">geometry_pt_on_base</span>
            <span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">dists</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">shore_pt</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">base_pt</span><span class="p">))</span>
                <span class="k">except</span> <span class="ne">BaseException</span><span class="p">:</span>
                    <span class="n">dists</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            <span class="n">matched</span><span class="p">[</span><span class="s2">&quot;sat_from_baseline&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dists</span>
            <span class="n">matched</span><span class="p">[</span><span class="s2">&quot;raw_date&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">original_shore</span><span class="o">.</span><span class="n">raw_date</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="k">if</span> <span class="s2">&quot;water_index&quot;</span> <span class="ow">in</span> <span class="n">shoreline</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>

                <span class="n">matched</span><span class="p">[</span><span class="s2">&quot;water_index&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">original_shore</span><span class="o">.</span><span class="n">water_index</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">matched</span><span class="p">[</span><span class="s2">&quot;thr_type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">original_shore</span><span class="o">.</span><span class="n">thr_type</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">pass</span>

            <span class="n">orig_shore_base_distances</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="n">matched</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;sat_from_baseline&quot;</span><span class="p">]),</span>
                    <span class="n">orig_shore_base_distances</span><span class="p">,</span>
                <span class="p">],</span>
                <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># update transects with the baseline shore distances info</span>
        <span class="n">orig_shore_base_distances</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span>
            <span class="n">orig_shore_base_distances</span><span class="p">,</span>
            <span class="n">transects</span><span class="p">[[</span><span class="s2">&quot;tr_id&quot;</span><span class="p">,</span> <span class="s2">&quot;geometry&quot;</span><span class="p">]],</span>
            <span class="n">on</span><span class="o">=</span><span class="s2">&quot;tr_id&quot;</span><span class="p">,</span>
            <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">shores_to_corr</span><span class="o">.</span><span class="n">raw_date</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

        <span class="c1"># loop through all transects in each groundthruth shoreline to compute</span>
        <span class="c1"># distances from the baseline points</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Computing cross-shore distances of UAV shorelines.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;gt&quot;</span><span class="p">:</span>  <span class="c1"># we will use these points to limit the beachface extraction</span>

            <span class="n">gt_base_distances</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>

            <span class="k">for</span> <span class="n">shoreline_i</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">gt_shores</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
                <span class="n">shore_i</span> <span class="o">=</span> <span class="n">gt_shores</span><span class="o">.</span><span class="n">iloc</span><span class="p">[[</span><span class="n">shoreline_i</span><span class="p">]][</span>
                    <span class="p">[</span><span class="s2">&quot;location&quot;</span><span class="p">,</span> <span class="s2">&quot;raw_date&quot;</span><span class="p">,</span> <span class="s2">&quot;geometry&quot;</span><span class="p">]</span>
                <span class="p">]</span>
                <span class="n">shore_pts_gt</span> <span class="o">=</span> <span class="n">extract_shore_pts</span><span class="p">(</span>
                    <span class="n">transects</span><span class="p">,</span> <span class="n">shore_i</span><span class="p">,</span> <span class="n">date_field</span><span class="o">=</span><span class="s2">&quot;raw_date&quot;</span>
                <span class="p">)</span>

                <span class="n">matched</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span>
                    <span class="n">shore_pts_gt</span><span class="p">,</span>
                    <span class="n">baseline_pts</span><span class="p">,</span>
                    <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">,</span>
                    <span class="n">on</span><span class="o">=</span><span class="s2">&quot;tr_id&quot;</span><span class="p">,</span>
                    <span class="n">suffixes</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;_gt_on_shore&quot;</span><span class="p">,</span> <span class="s2">&quot;_gt_on_base&quot;</span><span class="p">),</span>
                <span class="p">)</span>
                <span class="n">dists</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">shore_pt</span><span class="p">,</span> <span class="n">base_pt</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                    <span class="n">matched</span><span class="o">.</span><span class="n">geometry_gt_on_shore</span><span class="p">,</span> <span class="n">matched</span><span class="o">.</span><span class="n">geometry_gt_on_base</span>
                <span class="p">):</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">dists</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">shore_pt</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">base_pt</span><span class="p">))</span>
                    <span class="k">except</span> <span class="ne">BaseException</span><span class="p">:</span>
                        <span class="n">dists</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
                <span class="n">matched</span><span class="p">[</span><span class="s2">&quot;gt_from_baseline&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dists</span>
                <span class="n">matched</span><span class="p">[</span><span class="s2">&quot;raw_date&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">shore_i</span><span class="o">.</span><span class="n">raw_date</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

                <span class="n">gt_base_distances</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">matched</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;gt_from_baseline&quot;</span><span class="p">]),</span> <span class="n">gt_base_distances</span><span class="p">],</span>
                    <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="p">)</span>

            <span class="n">gt_base_distances</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span>
                <span class="n">gt_base_distances</span><span class="p">,</span>
                <span class="n">transects</span><span class="p">[[</span><span class="s2">&quot;tr_id&quot;</span><span class="p">,</span> <span class="s2">&quot;geometry&quot;</span><span class="p">]],</span>
                <span class="n">on</span><span class="o">=</span><span class="s2">&quot;tr_id&quot;</span><span class="p">,</span>
                <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="c1"># _______ EXTRACT BEACHFACE BASED ON SHORELINE POSITION AND DUNE TOE______</span>

        <span class="k">if</span> <span class="nb">bool</span><span class="p">(</span><span class="n">limit_correction</span><span class="p">):</span>

            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Extracting dune toes from slope profiles.&quot;</span><span class="p">)</span>
            <span class="n">gdf_loc</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;location==&#39;</span><span class="si">{</span><span class="n">location</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>

            <span class="n">toes_cand</span> <span class="o">=</span> <span class="n">toes_candidates</span><span class="p">(</span><span class="n">gdf_loc</span><span class="p">,</span> <span class="n">date_field</span><span class="o">=</span><span class="s2">&quot;raw_date&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;gt&quot;</span><span class="p">:</span>

                <span class="n">baseline_distances_in</span> <span class="o">=</span> <span class="n">gt_base_distances</span>
                <span class="n">baseline_field</span> <span class="o">=</span> <span class="s2">&quot;gt_from_baseline&quot;</span>
                <span class="n">txt</span> <span class="o">=</span> <span class="s2">&quot;UAV-derived&quot;</span>

                <span class="n">base_dist_toes</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span>
                    <span class="n">baseline_distances_in</span><span class="p">,</span>
                    <span class="n">toes_cand</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(),</span>
                    <span class="n">on</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;location&quot;</span><span class="p">,</span> <span class="s2">&quot;raw_date&quot;</span><span class="p">,</span> <span class="s2">&quot;tr_id&quot;</span><span class="p">],</span>
                    <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">,</span>
                <span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>

                <span class="n">baseline_distances_in</span> <span class="o">=</span> <span class="n">orig_shore_base_distances</span>
                <span class="n">baseline_field</span> <span class="o">=</span> <span class="s2">&quot;sat_from_baseline&quot;</span>
                <span class="n">txt</span> <span class="o">=</span> <span class="s2">&quot;satellite-derived&quot;</span>

                <span class="n">base_dist_toes</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span>
                    <span class="n">baseline_distances_in</span><span class="p">,</span>
                    <span class="n">toes_cand</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(),</span>
                    <span class="n">on</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;location&quot;</span><span class="p">,</span> <span class="s2">&quot;raw_date&quot;</span><span class="p">,</span> <span class="s2">&quot;tr_id&quot;</span><span class="p">],</span>
                    <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">,</span>
                <span class="p">)</span>

            <span class="n">toes</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">t</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                <span class="n">base_dist_toes</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="s2">&quot;toe_distances&quot;</span><span class="p">],</span>
                <span class="n">base_dist_toes</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">baseline_field</span><span class="p">],</span>
            <span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">toes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">t</span> <span class="o">&lt;=</span> <span class="n">d</span><span class="p">)][</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">except</span> <span class="ne">BaseException</span><span class="p">:</span>
                    <span class="n">toes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

            <span class="n">base_dist_toes</span><span class="p">[</span><span class="s2">&quot;toe&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">toes</span>

            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Classifying beachfaces as going from </span><span class="si">{</span><span class="n">txt</span><span class="si">}</span><span class="s2"> shorelines to dune toes.&quot;</span>
            <span class="p">)</span>

            <span class="c1"># preprocessing</span>
            <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;gt&quot;</span><span class="p">:</span>
                <span class="n">tmp_lookup</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">base_dist_toes</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s2">&quot;location&quot;</span><span class="p">,</span> <span class="s2">&quot;raw_date&quot;</span><span class="p">,</span> <span class="s2">&quot;tr_id&quot;</span><span class="p">])[</span>
                        <span class="n">toe_field</span><span class="p">,</span> <span class="n">baseline_field</span>
                    <span class="p">]</span>
                    <span class="o">.</span><span class="n">first</span><span class="p">()</span>
                    <span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
                <span class="p">)</span>
                <span class="n">tmp_merge</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span>
                    <span class="n">tmp_lookup</span><span class="p">,</span>
                    <span class="n">gdf_loc</span><span class="p">,</span>
                    <span class="n">how</span><span class="o">=</span><span class="s2">&quot;right&quot;</span><span class="p">,</span>
                    <span class="n">on</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;location&quot;</span><span class="p">,</span> <span class="s2">&quot;raw_date&quot;</span><span class="p">,</span> <span class="s2">&quot;tr_id&quot;</span><span class="p">],</span>
                <span class="p">)</span>
                <span class="n">tmp_merge</span> <span class="o">=</span> <span class="n">tmp_merge</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="n">baseline_field</span><span class="p">])[</span>
                    <span class="p">[</span>
                        <span class="s2">&quot;distance&quot;</span><span class="p">,</span>
                        <span class="n">baseline_field</span><span class="p">,</span>
                        <span class="s2">&quot;location&quot;</span><span class="p">,</span>
                        <span class="s2">&quot;raw_date&quot;</span><span class="p">,</span>
                        <span class="s2">&quot;tr_id&quot;</span><span class="p">,</span>
                        <span class="s2">&quot;toe&quot;</span><span class="p">,</span>
                        <span class="s2">&quot;slope&quot;</span><span class="p">,</span>
                    <span class="p">]</span>
                <span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>

                <span class="n">tmp_lookup</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">base_dist_toes</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="o">*</span><span class="n">group_by_fields</span><span class="p">,</span> <span class="s2">&quot;tr_id&quot;</span><span class="p">])[</span>
                        <span class="n">toe_field</span><span class="p">,</span> <span class="n">baseline_field</span>
                    <span class="p">]</span>
                    <span class="o">.</span><span class="n">first</span><span class="p">()</span>
                    <span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
                <span class="p">)</span>
                <span class="n">tmp_merge</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span>
                    <span class="n">tmp_lookup</span><span class="p">,</span>
                    <span class="n">gdf_loc</span><span class="p">,</span>
                    <span class="n">how</span><span class="o">=</span><span class="s2">&quot;right&quot;</span><span class="p">,</span>
                    <span class="n">on</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;location&quot;</span><span class="p">,</span> <span class="s2">&quot;raw_date&quot;</span><span class="p">,</span> <span class="s2">&quot;tr_id&quot;</span><span class="p">],</span>
                <span class="p">)</span>
                <span class="n">tmp_merge</span> <span class="o">=</span> <span class="n">tmp_merge</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="n">baseline_field</span><span class="p">])[</span>
                    <span class="p">[</span>
                        <span class="s2">&quot;distance&quot;</span><span class="p">,</span>
                        <span class="n">baseline_field</span><span class="p">,</span>
                        <span class="s2">&quot;location&quot;</span><span class="p">,</span>
                        <span class="s2">&quot;raw_date&quot;</span><span class="p">,</span>
                        <span class="s2">&quot;tr_id&quot;</span><span class="p">,</span>
                        <span class="s2">&quot;toe&quot;</span><span class="p">,</span>
                        <span class="s2">&quot;slope&quot;</span><span class="p">,</span>
                    <span class="p">]</span>
                <span class="p">]</span>

            <span class="c1"># conditions</span>
            <span class="n">tmp_merge</span><span class="p">[</span><span class="s2">&quot;beachface&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
                <span class="s2">&quot;bf&quot;</span>
                <span class="k">if</span> <span class="n">tmp_merge</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">distance_field</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">tmp_merge</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">toe_field</span><span class="p">]</span>
                <span class="ow">and</span> <span class="n">tmp_merge</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">distance_field</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">tmp_merge</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">baseline_field</span><span class="p">]</span>
                <span class="k">else</span> <span class="s2">&quot;land&quot;</span>
                <span class="k">if</span> <span class="n">tmp_merge</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">distance_field</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">tmp_merge</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">toe_field</span><span class="p">]</span>
                <span class="k">else</span> <span class="s2">&quot;water&quot;</span>
                <span class="k">if</span> <span class="n">tmp_merge</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">distance_field</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">tmp_merge</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">toe_field</span><span class="p">]</span>
                <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">tmp_merge</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="p">]</span>

        <span class="k">else</span><span class="p">:</span>  <span class="c1"># if we do not want to limit the correction to the beachface statistics, but we want to use the full transect stats</span>

            <span class="n">merged_tmp</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span>
                <span class="n">shores_to_corr</span><span class="p">,</span>
                <span class="n">orig_shore_base_distances</span><span class="p">,</span>
                <span class="n">on</span><span class="o">=</span><span class="p">[</span><span class="o">*</span><span class="n">group_by_fields</span><span class="p">],</span>
                <span class="n">how</span><span class="o">=</span><span class="s2">&quot;right&quot;</span><span class="p">,</span>
                <span class="n">suffixes</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;_shore&quot;</span><span class="p">,</span> <span class="s2">&quot;_tr&quot;</span><span class="p">),</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">slope_value</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>

            <span class="k">if</span> <span class="nb">bool</span><span class="p">(</span><span class="n">limit_correction</span><span class="p">):</span>

                <span class="n">df_in</span> <span class="o">=</span> <span class="n">tmp_merge</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="s2">&quot;beachface==&#39;bf&#39;&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>

                <span class="n">df_in</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span>
                    <span class="n">merged_tmp</span><span class="o">.</span><span class="n">astype</span><span class="p">({</span><span class="s2">&quot;tr_id&quot;</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="s2">&quot;raw_date&quot;</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="s2">&quot;location&quot;</span><span class="p">:</span> <span class="nb">str</span><span class="p">}),</span>
                    <span class="n">gdf_loc</span><span class="o">.</span><span class="n">astype</span><span class="p">({</span><span class="s2">&quot;tr_id&quot;</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="s2">&quot;raw_date&quot;</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="s2">&quot;location&quot;</span><span class="p">:</span> <span class="nb">str</span><span class="p">})[</span>
                        <span class="p">[</span><span class="s2">&quot;location&quot;</span><span class="p">,</span> <span class="s2">&quot;raw_date&quot;</span><span class="p">,</span> <span class="s2">&quot;tr_id&quot;</span><span class="p">,</span> <span class="s2">&quot;slope&quot;</span><span class="p">]</span>
                    <span class="p">],</span>
                    <span class="n">how</span><span class="o">=</span><span class="s2">&quot;right&quot;</span><span class="p">,</span>
                    <span class="n">on</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;location&quot;</span><span class="p">,</span> <span class="s2">&quot;raw_date&quot;</span><span class="p">,</span> <span class="s2">&quot;tr_id&quot;</span><span class="p">],</span>
                <span class="p">)</span>

            <span class="n">ops_dict</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;mean&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">,</span>
                <span class="s2">&quot;median&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmedian</span><span class="p">,</span>
                <span class="s2">&quot;min&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">,</span>
                <span class="s2">&quot;max&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">,</span>
                <span class="s2">&quot;range&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ptp</span><span class="p">,</span>
                <span class="s2">&quot;std&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">,</span>
                <span class="s2">&quot;var&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">nanvar</span><span class="p">,</span>
            <span class="p">}</span>

            <span class="n">stats</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ops_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>

                <span class="n">tmp</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span>
                    <span class="n">df_in</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s2">&quot;raw_date&quot;</span><span class="p">,</span> <span class="s2">&quot;tr_id&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">slope</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">ops_dict</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span>
                    <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">_beachface_slope&quot;</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">stats</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">stats</span><span class="p">,</span> <span class="n">tmp</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">stats</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span>
                    <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_tuples</span><span class="p">(</span><span class="n">stats</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;raw_date&quot;</span><span class="p">,</span> <span class="s2">&quot;tr_id&quot;</span><span class="p">))</span>
                <span class="p">)</span>
            <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;location&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">location</span>

            <span class="n">slope_field</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">stat</span> <span class="k">for</span> <span class="n">stat</span> <span class="ow">in</span> <span class="n">stats</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span> <span class="n">stat</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">slope_value</span><span class="p">)</span>
            <span class="p">][</span><span class="mi">0</span><span class="p">]</span>

            <span class="k">if</span> <span class="nb">bool</span><span class="p">(</span><span class="n">limit_correction</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Using </span><span class="si">{</span><span class="n">slope_field</span><span class="si">}</span><span class="s2"> of beachfaces to correct shorelines.&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Using full transect </span><span class="si">{</span><span class="n">slope_field</span><span class="si">}</span><span class="s2"> to correct shorelines.&quot;</span><span class="p">)</span>

            <span class="n">stats</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
            <span class="n">stats</span><span class="p">[</span><span class="s2">&quot;raw_date&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">stats</span><span class="o">.</span><span class="n">raw_date</span><span class="p">]</span>

            <span class="n">orig_shore_trs_stats</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span>
                <span class="n">orig_shore_base_distances</span><span class="p">,</span>
                <span class="n">stats</span><span class="p">,</span>
                <span class="n">on</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;tr_id&quot;</span><span class="p">,</span> <span class="s2">&quot;location&quot;</span><span class="p">,</span> <span class="s2">&quot;raw_date&quot;</span><span class="p">],</span>
                <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="nb">bool</span><span class="p">(</span><span class="n">replace_slope_outliers</span><span class="p">):</span>

                <span class="c1"># create temp dataframes to store survey-level slope values stats and</span>
                <span class="c1"># derive 3 sigmas thresholds per date</span>
                <span class="n">survey_slope_field_stat</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">stats</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s2">&quot;raw_date&quot;</span><span class="p">])[</span><span class="n">slope_field</span><span class="p">]</span><span class="o">.</span><span class="n">describe</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
                <span class="p">)</span>
                <span class="n">survey_slope_field_stat</span><span class="p">[</span><span class="s2">&quot;sigmas_3&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">survey_slope_field_stat</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="s2">&quot;50%&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span>
                <span class="p">)</span>

                <span class="n">orig_shore_trs_stats</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span>
                    <span class="n">orig_shore_trs_stats</span><span class="p">,</span>
                    <span class="n">survey_slope_field_stat</span><span class="p">[[</span><span class="s2">&quot;raw_date&quot;</span><span class="p">,</span> <span class="s2">&quot;sigmas_3&quot;</span><span class="p">,</span> <span class="s2">&quot;50%&quot;</span><span class="p">]],</span>
                    <span class="n">on</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;raw_date&quot;</span><span class="p">],</span>
                    <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">,</span>
                <span class="p">)</span>

                <span class="c1"># add the field &#39;outlier&#39; and mark slope_values exceeding 3 std.</span>
                <span class="n">orig_shore_trs_stats</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="s2">&quot;outlier&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                    <span class="n">orig_shore_trs_stats</span><span class="p">[</span><span class="n">slope_field</span><span class="p">]</span>
                    <span class="o">&gt;</span> <span class="n">orig_shore_trs_stats</span><span class="p">[</span><span class="s2">&quot;sigmas_3&quot;</span><span class="p">],</span>
                    <span class="kc">True</span><span class="p">,</span>
                    <span class="kc">False</span><span class="p">,</span>
                <span class="p">)</span>

                <span class="c1"># replace outliers with median survey values.</span>
                <span class="n">orig_shore_trs_stats</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">slope_field</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                    <span class="n">orig_shore_trs_stats</span><span class="p">[</span><span class="n">slope_field</span><span class="p">]</span>
                    <span class="o">&gt;</span> <span class="n">orig_shore_trs_stats</span><span class="p">[</span><span class="s2">&quot;sigmas_3&quot;</span><span class="p">],</span>
                    <span class="n">orig_shore_trs_stats</span><span class="p">[</span><span class="s2">&quot;50%&quot;</span><span class="p">],</span>
                    <span class="n">orig_shore_trs_stats</span><span class="p">[</span><span class="n">slope_field</span><span class="p">],</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">pass</span>

            <span class="n">correction_series</span> <span class="o">=</span> <span class="n">orig_shore_trs_stats</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">slope_field</span><span class="p">]</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">slope_value</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Using user-provided slope of </span><span class="si">{</span><span class="n">slope_value</span><span class="si">}</span><span class="s2"> to correct shorelines.&quot;</span><span class="p">)</span>
            <span class="n">orig_shore_trs_stats</span> <span class="o">=</span> <span class="n">orig_shore_base_distances</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span>
                <span class="n">fixed_slope</span><span class="o">=</span><span class="n">slope_value</span>
            <span class="p">)</span>

            <span class="n">correction_series</span> <span class="o">=</span> <span class="n">orig_shore_trs_stats</span><span class="o">.</span><span class="n">fixed_slope</span>

        <span class="c1"># add tide height</span>

        <span class="n">orig_shore_trs_stat_tide</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span>
            <span class="n">orig_shore_trs_stats</span><span class="p">,</span>
            <span class="n">shores_to_corr</span><span class="p">[[</span><span class="o">*</span><span class="n">group_by_fields</span><span class="p">,</span> <span class="s2">&quot;tide_height&quot;</span><span class="p">]],</span>
            <span class="n">on</span><span class="o">=</span><span class="p">[</span><span class="o">*</span><span class="n">group_by_fields</span><span class="p">],</span>
            <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">orig_shore_trs_stat_tide</span><span class="p">[</span><span class="s2">&quot;corr_dist&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">corr_baseline_distance</span><span class="p">(</span>
            <span class="n">orig_shore_trs_stat_tide</span><span class="o">.</span><span class="n">sat_from_baseline</span><span class="p">,</span>
            <span class="n">correction_series</span><span class="p">,</span>
            <span class="n">orig_shore_trs_stat_tide</span><span class="o">.</span><span class="n">tide_height</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">orig_shore_trs_stat_tide</span><span class="p">[</span><span class="s2">&quot;diff_corr&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">orig_shore_trs_stat_tide</span><span class="o">.</span><span class="n">sat_from_baseline</span>
            <span class="o">-</span> <span class="n">orig_shore_trs_stat_tide</span><span class="o">.</span><span class="n">corr_dist</span>
        <span class="p">)</span>

        <span class="n">orig_shore_corr_dist_gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span>
            <span class="n">orig_shore_trs_stat_tide</span><span class="p">,</span> <span class="n">geometry</span><span class="o">=</span><span class="s2">&quot;geometry&quot;</span><span class="p">,</span> <span class="n">crs</span><span class="o">=</span><span class="n">crs</span>
        <span class="p">)</span>

        <span class="c1"># _______ Apply threshold to correction, below this threshold, it is not c</span>

        <span class="n">diffs</span> <span class="o">=</span> <span class="n">orig_shore_corr_dist_gdf</span><span class="o">.</span><span class="n">diff_corr</span><span class="o">.</span><span class="n">values</span>
        <span class="n">corrs</span> <span class="o">=</span> <span class="n">orig_shore_corr_dist_gdf</span><span class="o">.</span><span class="n">corr_dist</span><span class="o">.</span><span class="n">values</span>
        <span class="n">originals</span> <span class="o">=</span> <span class="n">orig_shore_corr_dist_gdf</span><span class="o">.</span><span class="n">sat_from_baseline</span><span class="o">.</span><span class="n">values</span>

        <span class="c1"># whether to correct or not shorelines closer to this threshold</span>
        <span class="k">if</span> <span class="n">baseline_threshold</span> <span class="o">==</span> <span class="s2">&quot;infer&quot;</span><span class="p">:</span>
            <span class="n">baseline_threshold_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span>
                <span class="n">threshold_multiotsu</span><span class="p">(</span>
                    <span class="n">orig_shore_corr_dist_gdf</span><span class="o">.</span><span class="n">diff_corr</span><span class="o">.</span><span class="n">dropna</span><span class="p">(),</span> <span class="n">classes</span><span class="o">=</span><span class="mi">2</span>
                <span class="p">)[</span><span class="mi">0</span><span class="p">],</span>
                <span class="mi">2</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Inferred baseline_threshold of: </span><span class="si">{</span><span class="n">baseline_threshold_value</span><span class="si">}</span><span class="s2"> meters&quot;</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">baseline_threshold</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
            <span class="n">baseline_threshold_value</span> <span class="o">=</span> <span class="n">baseline_threshold</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot; Baseline distance threshold of: </span><span class="si">{</span><span class="n">baseline_threshold_value</span><span class="si">}</span><span class="s2"> meters&quot;</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">baseline_threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Baseline_threshold must be either &#39;infer&#39; or a numeric value.&quot;</span>
            <span class="p">)</span>

        <span class="n">updated_corr_dists</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">c</span> <span class="k">if</span> <span class="n">d</span> <span class="o">&gt;</span> <span class="n">baseline_threshold_value</span> <span class="k">else</span> <span class="n">o</span>
            <span class="k">for</span> <span class="n">d</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">o</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">diffs</span><span class="p">,</span> <span class="n">corrs</span><span class="p">,</span> <span class="n">originals</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="n">orig_shore_corr_dist_gdf</span><span class="p">[</span><span class="s2">&quot;updated_corr_dists&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">updated_corr_dists</span>

        <span class="k">if</span> <span class="s2">&quot;slope_field&quot;</span> <span class="ow">in</span> <span class="nb">locals</span><span class="p">():</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">orig_shore_corr_dist_gdf</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="n">slope_field</span><span class="p">])[</span>
                <span class="p">[</span>
                    <span class="o">*</span><span class="n">group_by_fields</span><span class="p">,</span>
                    <span class="s2">&quot;tr_id&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;sat_from_baseline&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;updated_corr_dists&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;geometry&quot;</span><span class="p">,</span>
                <span class="p">]</span>
            <span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">orig_shore_corr_dist_gdf</span><span class="o">.</span><span class="n">dropna</span><span class="p">()[</span>
                <span class="p">[</span>
                    <span class="o">*</span><span class="n">group_by_fields</span><span class="p">,</span>
                    <span class="s2">&quot;tr_id&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;sat_from_baseline&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;updated_corr_dists&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;geometry&quot;</span><span class="p">,</span>
                <span class="p">]</span>
            <span class="p">]</span>
        <span class="n">a</span><span class="p">[</span><span class="s2">&quot;updated_corr_dists&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">a</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">sat_from_baseline</span>
            <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">updated_corr_dists</span> <span class="o">&lt;</span> <span class="mi">0</span>
            <span class="k">else</span> <span class="n">a</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">updated_corr_dists</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="p">]</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="o">*</span><span class="n">group_by_fields</span><span class="p">])[</span><span class="s2">&quot;tr_id&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
        <span class="n">b</span><span class="p">[</span><span class="s2">&quot;updated_corr_dists&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">a</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="o">*</span><span class="n">group_by_fields</span><span class="p">])[</span><span class="s2">&quot;updated_corr_dists&quot;</span><span class="p">]</span>
            <span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">)</span>
            <span class="o">.</span><span class="n">reset_index</span><span class="p">()[</span><span class="s2">&quot;updated_corr_dists&quot;</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">b</span><span class="p">[</span><span class="s2">&quot;tr_geometries&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">a</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="o">*</span><span class="n">group_by_fields</span><span class="p">])[</span><span class="s2">&quot;geometry&quot;</span><span class="p">]</span>
            <span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">)</span>
            <span class="o">.</span><span class="n">reset_index</span><span class="p">()[</span><span class="s2">&quot;geometry&quot;</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="c1"># 5)_________________ Lines creation_________________________________________</span>

        <span class="n">lines</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">b</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
            <span class="n">groups</span> <span class="o">=</span> <span class="n">consecutive_ids</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">row</span><span class="o">.</span><span class="n">tr_id</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit_vertex</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">groups</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>

                <span class="n">lines_group</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">group</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">groups</span><span class="p">):</span>

                    <span class="n">trs</span> <span class="o">=</span> <span class="n">row</span><span class="o">.</span><span class="n">tr_geometries</span><span class="p">[</span><span class="n">group</span><span class="p">]</span>
                    <span class="n">dis</span> <span class="o">=</span> <span class="n">row</span><span class="o">.</span><span class="n">updated_corr_dists</span><span class="p">[</span><span class="n">group</span><span class="p">]</span>

                    <span class="n">line_pts</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">distance</span><span class="p">,</span> <span class="n">transect</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">dis</span><span class="p">,</span> <span class="n">trs</span><span class="p">):</span>
                        <span class="n">point</span> <span class="o">=</span> <span class="n">transect</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">distance</span><span class="p">)</span>
                        <span class="n">line_pts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>

                    <span class="n">line</span> <span class="o">=</span> <span class="n">LineString</span><span class="p">(</span><span class="n">line_pts</span><span class="p">)</span>
                    <span class="n">lines_group</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lines_group</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">lines_row</span> <span class="o">=</span> <span class="n">unary_union</span><span class="p">(</span><span class="n">lines_group</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">lines_row</span> <span class="o">=</span> <span class="n">lines_group</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

                <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lines_row</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;WARNING:</span><span class="se">\n\</span>
<span class="s2">                </span><span class="si">{</span><span class="n">row</span><span class="o">.</span><span class="n">location</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">row</span><span class="o">.</span><span class="n">raw_date</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">row</span><span class="o">.</span><span class="n">water_index</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">row</span><span class="o">.</span><span class="n">thr_type</span><span class="si">}</span><span class="s2"> has </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">groups</span><span class="p">)</span><span class="si">}</span><span class="s2"> groups. Skipped.&quot;</span>
                <span class="p">)</span>
                <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

        <span class="n">lines</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">geoseries</span><span class="o">.</span><span class="n">GeoSeries</span><span class="p">(</span><span class="n">lines</span><span class="p">,</span> <span class="n">crs</span><span class="o">=</span><span class="n">crs</span><span class="p">)</span>
        <span class="n">b</span><span class="p">[</span><span class="s2">&quot;corr_shore_geometry&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">lines</span><span class="o">.</span><span class="n">geometry</span>
        <span class="n">final</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">shores_to_corr</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="p">[</span><span class="o">*</span><span class="n">group_by_fields</span><span class="p">],</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">)</span>

        <span class="c1"># 6)_________________ saving outputs________________________________________</span>

        <span class="k">if</span> <span class="nb">bool</span><span class="p">(</span><span class="n">save_trs_details</span><span class="p">):</span>
            <span class="n">trs_details_file_name</span> <span class="o">=</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;trsdetails_</span><span class="si">{</span><span class="n">location</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">slope_value</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">limited</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">mode</span><span class="si">}</span><span class="s2">.csv&quot;</span>
            <span class="p">)</span>
            <span class="n">trs_details_out_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                <span class="n">trs_details_folder</span><span class="p">,</span> <span class="n">trs_details_file_name</span>
            <span class="p">)</span>

            <span class="n">orig_shore_corr_dist_gdf</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">trs_details_out_path</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;File </span><span class="si">{</span><span class="n">trs_details_file_name</span><span class="si">}</span><span class="s2"> saving in </span><span class="si">{</span><span class="n">trs_details_folder</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="n">big_final</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">big_final</span><span class="p">,</span> <span class="n">final</span><span class="p">],</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Done with </span><span class="si">{</span><span class="n">location</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">big_final</span>
</code></pre></div>
        </details>
    </div>

  </div>




  <div class="doc doc-object doc-function">



<h2 class="doc doc-heading" id="sandpyper.common.tiles_from_grid">
<code class="highlight language-python"><span class="n">tiles_from_grid</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">img_path</span><span class="p">,</span> <span class="n">output_path</span><span class="p">,</span> <span class="n">list_loc_codes</span><span class="p">,</span> <span class="n">crs_dict_string</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;rgb&#39;</span><span class="p">,</span> <span class="n">sel_bands</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">driver</span><span class="o">=</span><span class="s1">&#39;PNG&#39;</span><span class="p">,</span> <span class="n">geotransform</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>


<a class="headerlink" href="#sandpyper.common.tiles_from_grid" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Returns a dataframe with location, raw_date, filenames (paths) or geopackage index and CRS of each raster and its associated vector files.
If the directory containing the vector files has only one file, it is assumed that this file stores vectors
with location and raw_date columns.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>grid</code></td>
        <td><code>GeoDataFrame</code></td>
        <td><p>GeoDataFrame of the grid of only tiles containing the line. Output of grid_from_shore function.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>img_path</code></td>
        <td><code>str</code></td>
        <td><p>Path of the directory containing the geotiffs datasets (.tiff or .tif).</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>output_path</code></td>
        <td><code>str</code></td>
        <td><p>Path of the directory where to save the images tiles.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>list_loc_codes</code></td>
        <td><code>list</code></td>
        <td><p>list of strings containing location codes.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>mode</code></td>
        <td><code>str,&#39;rgb&#39;,&#39;mask&#39;,&#39;multi&#39;,&#39;custom&#39;</code></td>
        <td><p>'rgb', the output images are 3-channels RGB tiles. 'mask', 1-band output tiles.</p></td>
        <td><code>&#39;rgb&#39;</code></td>
      </tr>
      <tr>
        <td><code>(NOTE</code></td>
        <td><code></code></td>
        <td><p>in 'custom' mode, output tile bands indices are reindexd, so do not corresponds with the original band indices, but restart from 1).</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>geotransform</code></td>
        <td><code>bool or &#39;only&#39;</code></td>
        <td><p>If True, save tiles and also return a dictionary with the geotransform of each grid.</p></td>
        <td><code>False</code></td>
      </tr>
      <tr>
        <td><code>sel_bands</code></td>
        <td><code>list</code></td>
        <td><p>list of integers (minimum is 1, not zero-indexed) corresponding to the bands to be used to create the tiles. Only used with mode='custom'.</p></td>
        <td><code>None</code></td>
      </tr>
      <tr>
        <td><code>driver</code></td>
        <td><code>str, &#34;GTiff&#34; or &#34;PNG&#34;</code></td>
        <td><p>tiles image file type. Default is "PNG".</p></td>
        <td><code>&#39;PNG&#39;</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code></code></td>
      <td><p>Saves tiles to the specified output folder and optionally return the tiles geotransform dictionary.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>sandpyper\common.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">tiles_from_grid</span><span class="p">(</span>
    <span class="n">grid</span><span class="p">,</span>
    <span class="n">img_path</span><span class="p">,</span>
    <span class="n">output_path</span><span class="p">,</span>
    <span class="n">list_loc_codes</span><span class="p">,</span>
    <span class="n">crs_dict_string</span><span class="p">,</span>
    <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;rgb&quot;</span><span class="p">,</span>
    <span class="n">sel_bands</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">driver</span><span class="o">=</span><span class="s2">&quot;PNG&quot;</span><span class="p">,</span>
    <span class="n">geotransform</span><span class="o">=</span><span class="kc">False</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a dataframe with location, raw_date, filenames (paths) or geopackage index and CRS of each raster and its associated vector files.</span>
<span class="sd">    If the directory containing the vector files has only one file, it is assumed that this file stores vectors</span>
<span class="sd">    with location and raw_date columns.</span>

<span class="sd">    Args:</span>
<span class="sd">        grid (GeoDataFrame): GeoDataFrame of the grid of only tiles containing the line. Output of grid_from_shore function.</span>
<span class="sd">        img_path (str): Path of the directory containing the geotiffs datasets (.tiff or .tif).</span>
<span class="sd">        output_path (str): Path of the directory where to save the images tiles.</span>
<span class="sd">        list_loc_codes (list): list of strings containing location codes.</span>
<span class="sd">        mode (str,&#39;rgb&#39;,&#39;mask&#39;,&#39;multi&#39;,&#39;custom&#39;): &#39;rgb&#39;, the output images are 3-channels RGB tiles. &#39;mask&#39;, 1-band output tiles.</span>
<span class="sd">        &#39;multi&#39;, multibands output tiles (with all input bands).</span>
<span class="sd">        &#39;custom&#39;, use selected band indices (with sel_bands parameter) to only extract those bands from input multiband images</span>
<span class="sd">        (NOTE: in &#39;custom&#39; mode, output tile bands indices are reindexd, so do not corresponds with the original band indices, but restart from 1).</span>
<span class="sd">        geotransform (bool or &#39;only&#39;): If True, save tiles and also return a dictionary with the geotransform of each grid.</span>
<span class="sd">        If False, save tiles without geotransform dictionary. If &quot;only&quot;, do not save tiles but return the geotransform dictionary only.</span>
<span class="sd">        sel_bands (list): list of integers (minimum is 1, not zero-indexed) corresponding to the bands to be used to create the tiles. Only used with mode=&#39;custom&#39;.</span>
<span class="sd">        Default is None.</span>
<span class="sd">        driver (str, &quot;GTiff&quot; or &quot;PNG&quot;): tiles image file type. Default is &quot;PNG&quot;.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Saves tiles to the specified output folder and optionally return the tiles geotransform dictionary.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">loc</span> <span class="o">=</span> <span class="n">getLoc</span><span class="p">(</span><span class="n">img_path</span><span class="p">,</span> <span class="n">list_loc_codes</span><span class="p">)</span>
    <span class="n">crs</span> <span class="o">=</span> <span class="n">crs_dict_string</span><span class="p">[</span><span class="n">loc</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">driver</span> <span class="o">==</span> <span class="s2">&quot;PNG&quot;</span><span class="p">:</span>
        <span class="n">ext</span> <span class="o">=</span> <span class="s2">&quot;png&quot;</span>
    <span class="k">elif</span> <span class="n">driver</span> <span class="o">==</span> <span class="s2">&quot;GTiff&quot;</span><span class="p">:</span>
        <span class="n">ext</span> <span class="o">=</span> <span class="s2">&quot;tif&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s2">&quot;Driver must be either &#39;PNG&#39; or &#39;GTiff&#39;.&quot;</span><span class="p">)</span>

    <span class="k">with</span> <span class="n">ras</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">img_path</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">dataset</span><span class="p">:</span>

        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;rgb&quot;</span><span class="p">:</span>

            <span class="n">count</span> <span class="o">=</span> <span class="mi">3</span>
            <span class="n">source_idx</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>  <span class="c1"># the band indices of the source image</span>
            <span class="n">out_idx</span> <span class="o">=</span> <span class="n">source_idx</span>
            <span class="n">sel_bands</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="n">height_idx</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">width_idx</span> <span class="o">=</span> <span class="mi">2</span>

        <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;multi&quot;</span><span class="p">:</span>

            <span class="k">if</span> <span class="n">driver</span> <span class="o">==</span> <span class="s2">&quot;PNG&quot;</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="s2">&quot;NOTE: PNG format doesn&#39;t support multibands. Returning GeoTiffs instead.&quot;</span>
                <span class="p">)</span>
                <span class="n">driver</span> <span class="o">=</span> <span class="s2">&quot;GTiff&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">pass</span>

            <span class="n">sel_bands</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">count</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">count</span>
            <span class="n">source_idx</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">dataset</span><span class="o">.</span><span class="n">indexes</span><span class="p">)</span>
            <span class="n">out_idx</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">height_idx</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">width_idx</span> <span class="o">=</span> <span class="mi">2</span>

        <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;mask&quot;</span><span class="p">:</span>

            <span class="n">count</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">source_idx</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">out_idx</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">height_idx</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">width_idx</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;custom&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sel_bands</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">3</span> <span class="ow">and</span> <span class="n">driver</span> <span class="o">==</span> <span class="s2">&quot;PNG&quot;</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="s2">&quot;NOTE: More than 3 bands selected for the creation of PNG images. PNG format doesn&#39;t support multibands. Returning GeoTiffs instead.&quot;</span>
                <span class="p">)</span>
                <span class="n">driver</span> <span class="o">=</span> <span class="s2">&quot;GTiff&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">pass</span>

            <span class="n">source_idx</span> <span class="o">=</span> <span class="n">sel_bands</span>
            <span class="n">out_idx</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sel_bands</span><span class="p">)</span>
            <span class="n">height_idx</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">width_idx</span> <span class="o">=</span> <span class="mi">2</span>

        <span class="c1"># creates gereferenced bounding box of the image</span>
        <span class="n">geom_im</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoSeries</span><span class="p">(</span><span class="n">box</span><span class="p">(</span><span class="o">*</span><span class="n">dataset</span><span class="o">.</span><span class="n">bounds</span><span class="p">),</span> <span class="n">crs</span><span class="o">=</span><span class="n">crs_dict_string</span><span class="p">[</span><span class="n">loc</span><span class="p">]</span>  <span class="p">)</span>

        <span class="c1"># evaluates which tiles are fully within the raster bounds</span>
        <span class="n">fully_contains</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">geom_im</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">mask_geom</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">mask_geom</span> <span class="ow">in</span> <span class="n">grid</span><span class="o">.</span><span class="n">geometry</span>
        <span class="p">]</span>

        <span class="c1"># get the expected shape of fully contained tiles</span>
        <span class="n">full_in_geom</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[</span><span class="n">fully_contains</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[[</span><span class="mi">0</span><span class="p">]][</span><span class="s2">&quot;geometry&quot;</span><span class="p">]</span>
        <span class="n">geom_wdw</span> <span class="o">=</span> <span class="n">geometry_window</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">full_in_geom</span><span class="p">)</span>
        <span class="n">expected_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">geom_wdw</span><span class="o">.</span><span class="n">height</span><span class="p">,</span> <span class="n">geom_wdw</span><span class="o">.</span><span class="n">width</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Expected shape</span><span class="si">{</span><span class="n">expected_shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">grid</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>

            <span class="n">tile_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">loc</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">row</span><span class="o">.</span><span class="n">grid_id</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">getDate</span><span class="p">(</span><span class="n">img_path</span><span class="p">)</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">mode</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="n">ext</span><span class="si">}</span><span class="s2">&quot;</span>

            <span class="n">geom</span> <span class="o">=</span> <span class="n">Polygon</span><span class="p">(</span>  <span class="c1"># create the square polygons to clip the raster with</span>
                <span class="p">(</span>
                    <span class="p">(</span><span class="n">row</span><span class="o">.</span><span class="n">ulx</span><span class="p">,</span> <span class="n">row</span><span class="o">.</span><span class="n">uly</span><span class="p">),</span>
                    <span class="p">(</span><span class="n">row</span><span class="o">.</span><span class="n">urx</span><span class="p">,</span> <span class="n">row</span><span class="o">.</span><span class="n">ury</span><span class="p">),</span>
                    <span class="p">(</span><span class="n">row</span><span class="o">.</span><span class="n">lrx</span><span class="p">,</span> <span class="n">row</span><span class="o">.</span><span class="n">lry</span><span class="p">),</span>
                    <span class="p">(</span><span class="n">row</span><span class="o">.</span><span class="n">llx</span><span class="p">,</span> <span class="n">row</span><span class="o">.</span><span class="n">lly</span><span class="p">),</span>
                    <span class="p">(</span><span class="n">row</span><span class="o">.</span><span class="n">ulx</span><span class="p">,</span> <span class="n">row</span><span class="o">.</span><span class="n">uly</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="p">)</span>

            <span class="c1"># get the future shape of the tile which is about to get created</span>
            <span class="n">geom_wdw</span> <span class="o">=</span> <span class="n">geometry_window</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="p">[</span><span class="n">mapping</span><span class="p">(</span><span class="n">geom</span><span class="p">)])</span>
            <span class="n">tile_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">geom_wdw</span><span class="o">.</span><span class="n">height</span><span class="p">,</span> <span class="n">geom_wdw</span><span class="o">.</span><span class="n">width</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">tile_shape</span> <span class="o">==</span> <span class="n">expected_shape</span><span class="p">:</span>

                <span class="n">tile_to_disk</span><span class="p">(</span>
                    <span class="n">dataset</span><span class="o">=</span><span class="n">dataset</span><span class="p">,</span>
                    <span class="n">geom</span><span class="o">=</span><span class="n">geom</span><span class="p">,</span>
                    <span class="n">crs</span><span class="o">=</span><span class="n">crs</span><span class="p">,</span>
                    <span class="n">tile_name</span><span class="o">=</span><span class="n">tile_name</span><span class="p">,</span>
                    <span class="n">output_path</span><span class="o">=</span><span class="n">output_path</span><span class="p">,</span>
                    <span class="n">nodata</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                    <span class="n">source_idx</span><span class="o">=</span><span class="n">source_idx</span><span class="p">,</span>
                    <span class="n">height_idx</span><span class="o">=</span><span class="n">height_idx</span><span class="p">,</span>
                    <span class="n">width_idx</span><span class="o">=</span><span class="n">width_idx</span><span class="p">,</span>
                    <span class="n">out_idx</span><span class="o">=</span><span class="n">out_idx</span><span class="p">,</span>
                    <span class="n">count</span><span class="o">=</span><span class="n">count</span><span class="p">,</span>
                    <span class="n">driver</span><span class="o">=</span><span class="n">driver</span><span class="p">,</span>
                    <span class="n">geotransform</span><span class="o">=</span><span class="n">geotransform</span><span class="p">,</span>
                <span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>

                <span class="n">partial_tile_padding</span><span class="p">(</span>
                    <span class="n">dataset</span><span class="o">=</span><span class="n">dataset</span><span class="p">,</span>
                    <span class="n">expected_shape</span><span class="o">=</span><span class="n">expected_shape</span><span class="p">,</span>
                    <span class="n">crs</span><span class="o">=</span><span class="n">crs</span><span class="p">,</span>
                    <span class="n">geom</span><span class="o">=</span><span class="n">geom</span><span class="p">,</span>
                    <span class="n">tile_name</span><span class="o">=</span><span class="n">tile_name</span><span class="p">,</span>
                    <span class="n">output_path</span><span class="o">=</span><span class="n">output_path</span><span class="p">,</span>
                    <span class="n">nodata</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                    <span class="n">source_idx</span><span class="o">=</span><span class="n">source_idx</span><span class="p">,</span>
                    <span class="n">height_idx</span><span class="o">=</span><span class="n">height_idx</span><span class="p">,</span>
                    <span class="n">width_idx</span><span class="o">=</span><span class="n">width_idx</span><span class="p">,</span>
                    <span class="n">out_idx</span><span class="o">=</span><span class="n">out_idx</span><span class="p">,</span>
                    <span class="n">count</span><span class="o">=</span><span class="n">count</span><span class="p">,</span>
                    <span class="n">driver</span><span class="o">=</span><span class="n">driver</span><span class="p">,</span>
                    <span class="n">geotransform</span><span class="o">=</span><span class="n">geotransform</span><span class="p">,</span>
                <span class="p">)</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 class="doc doc-heading" id="sandpyper.common.toes_candidates">
<code class="highlight language-python"><span class="n">toes_candidates</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">location_field</span><span class="o">=</span><span class="s1">&#39;location&#39;</span><span class="p">,</span> <span class="n">date_field</span><span class="o">=</span><span class="s1">&#39;raw_date&#39;</span><span class="p">,</span> <span class="n">tr_id_field</span><span class="o">=</span><span class="s1">&#39;tr_id&#39;</span><span class="p">,</span> <span class="n">distance_field</span><span class="o">=</span><span class="s1">&#39;distance&#39;</span><span class="p">,</span> <span class="n">slope_field</span><span class="o">=</span><span class="s1">&#39;slope&#39;</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">peak_height</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span></code>


<a class="headerlink" href="#sandpyper.common.toes_candidates" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Dataframe implementation of the toes_from_slope function.
Returns dune toe distance (from transect origin) by extracting peaks higher of a given value
from a Gaussian filtered slope profile. It can return multiple candidates when multiple peaks are found.
These will be used to clip beachfaces, defined as going from the swash line to dune toes.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>df</code></td>
        <td><code>pd.DataFrame</code></td>
        <td><p>Dataframe containing the slope profiles.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>location_field</code></td>
        <td><code>str</code></td>
        <td><p>Field where the location code is stored. Default to "location".</p></td>
        <td><code>&#39;location&#39;</code></td>
      </tr>
      <tr>
        <td><code>date_field</code></td>
        <td><code>str</code></td>
        <td><p>Field where the survey date is stored. Default to "raw_date".</p></td>
        <td><code>&#39;raw_date&#39;</code></td>
      </tr>
      <tr>
        <td><code>tr_id_field</code></td>
        <td><code>str</code></td>
        <td><p>Field where the transect ID is stored. Default to "tr_id".</p></td>
        <td><code>&#39;tr_id&#39;</code></td>
      </tr>
      <tr>
        <td><code>distance_field</code></td>
        <td><code>str</code></td>
        <td><p>Field where the distance is stored. Default to "distance".</p></td>
        <td><code>&#39;distance&#39;</code></td>
      </tr>
      <tr>
        <td><code>slope_field</code></td>
        <td><code>str</code></td>
        <td><p>Field where the slope is stored. Default to "slope".</p></td>
        <td><code>&#39;slope&#39;</code></td>
      </tr>
      <tr>
        <td><code>sigma</code></td>
        <td><code>int</code></td>
        <td><p>Number of standard deviations sued in the Gaussian smoothing filter.</p></td>
        <td><code>0</code></td>
      </tr>
      <tr>
        <td><code>peak_height</code></td>
        <td><code>int</code></td>
        <td><p>Threshold to use to define a peak in the smoothed slope profile.</p></td>
        <td><code>30</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>df_formatted (pd.DataFrame)</code></td>
      <td><p>Candidate distances of the each slope profile.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>sandpyper\common.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">toes_candidates</span><span class="p">(</span>
    <span class="n">df</span><span class="p">,</span>
    <span class="n">location_field</span><span class="o">=</span><span class="s2">&quot;location&quot;</span><span class="p">,</span>
    <span class="n">date_field</span><span class="o">=</span><span class="s2">&quot;raw_date&quot;</span><span class="p">,</span>
    <span class="n">tr_id_field</span><span class="o">=</span><span class="s2">&quot;tr_id&quot;</span><span class="p">,</span>
    <span class="n">distance_field</span><span class="o">=</span><span class="s2">&quot;distance&quot;</span><span class="p">,</span>
    <span class="n">slope_field</span><span class="o">=</span><span class="s2">&quot;slope&quot;</span><span class="p">,</span>
    <span class="n">sigma</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">peak_height</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Dataframe implementation of the toes_from_slope function.</span>
<span class="sd">    Returns dune toe distance (from transect origin) by extracting peaks higher of a given value</span>
<span class="sd">    from a Gaussian filtered slope profile. It can return multiple candidates when multiple peaks are found.</span>
<span class="sd">    These will be used to clip beachfaces, defined as going from the swash line to dune toes.</span>
<span class="sd">    Args:</span>
<span class="sd">        df (pd.DataFrame): Dataframe containing the slope profiles.</span>
<span class="sd">        location_field (str): Field where the location code is stored. Default to &quot;location&quot;.</span>
<span class="sd">        date_field (str): Field where the survey date is stored. Default to &quot;raw_date&quot;.</span>
<span class="sd">        tr_id_field (str): Field where the transect ID is stored. Default to &quot;tr_id&quot;.</span>
<span class="sd">        distance_field (str): Field where the distance is stored. Default to &quot;distance&quot;.</span>
<span class="sd">        slope_field (str):  Field where the slope is stored. Default to &quot;slope&quot;.</span>
<span class="sd">        sigma (int): Number of standard deviations sued in the Gaussian smoothing filter.</span>
<span class="sd">        peak_height (int): Threshold to use to define a peak in the smoothed slope profile.</span>

<span class="sd">    Returns:</span>
<span class="sd">        df_formatted (pd.DataFrame): Candidate distances of the each slope profile.&quot;&quot;&quot;</span>

    <span class="n">apply_dict</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;distance_field&quot;</span><span class="p">:</span> <span class="n">distance_field</span><span class="p">,</span>
        <span class="s2">&quot;slope_field&quot;</span><span class="p">:</span> <span class="n">slope_field</span><span class="p">,</span>
        <span class="s2">&quot;sigma&quot;</span><span class="p">:</span> <span class="n">sigma</span><span class="p">,</span>
        <span class="s2">&quot;peak_height&quot;</span><span class="p">:</span> <span class="n">peak_height</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="n">dist_toe_</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="n">location_field</span><span class="p">,</span> <span class="n">date_field</span><span class="p">,</span> <span class="n">tr_id_field</span><span class="p">])</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
        <span class="n">toes_from_slopes</span><span class="p">,</span> <span class="o">**</span><span class="n">apply_dict</span>
    <span class="p">)</span>

    <span class="n">dist_toe_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">dist_toe_</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;toe_distances&quot;</span><span class="p">))</span>

    <span class="n">df_formatted</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
        <span class="n">dist_toe_df</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
        <span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="n">location_field</span><span class="p">,</span> <span class="n">date_field</span><span class="p">,</span> <span class="n">tr_id_field</span><span class="p">])[</span><span class="s2">&quot;toe_distances&quot;</span><span class="p">]</span>
        <span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">df_formatted</span>
</code></pre></div>
        </details>
    </div>

  </div>



  <div class="doc doc-object doc-function">



<h2 class="doc doc-heading" id="sandpyper.common.toes_from_slopes">
<code class="highlight language-python"><span class="n">toes_from_slopes</span><span class="p">(</span><span class="n">series</span><span class="p">,</span> <span class="n">distance_field</span><span class="o">=</span><span class="s1">&#39;distance&#39;</span><span class="p">,</span> <span class="n">slope_field</span><span class="o">=</span><span class="s1">&#39;slope&#39;</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">peak_height</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span></code>


<a class="headerlink" href="#sandpyper.common.toes_from_slopes" title="Permanent link">&para;</a></h2>

    <div class="doc doc-contents ">

      <p>Returns dune toe distance (from transect origin) by extracting peaks higher of a given value
from a Gaussian filtered slope profile. It can return multiple candidates when multiple peaks are found.
These will be used to clip beachfaces, defined as going from the swash line to dune toes.</p>

<p><strong>Parameters:</strong></p>
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Type</th>
      <th>Description</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
      <tr>
        <td><code>series</code></td>
        <td><code>pd.Series</code></td>
        <td><p>Slope profile.</p></td>
        <td><em>required</em></td>
      </tr>
      <tr>
        <td><code>distance_field</code></td>
        <td><code>str</code></td>
        <td><p>Field where the distance is stored. Default to "distance".</p></td>
        <td><code>&#39;distance&#39;</code></td>
      </tr>
      <tr>
        <td><code>slope_field</code></td>
        <td><code>str</code></td>
        <td><p>Field where the slope is stored. Default to "slope".</p></td>
        <td><code>&#39;slope&#39;</code></td>
      </tr>
      <tr>
        <td><code>sigma</code></td>
        <td><code>int</code></td>
        <td><p>Number of standard deviations sued in the Gaussian smoothing filter.</p></td>
        <td><code>0</code></td>
      </tr>
      <tr>
        <td><code>peak_height</code></td>
        <td><code>int</code></td>
        <td><p>Threshold to use to define a peak in the smoothed slope profile.</p></td>
        <td><code>30</code></td>
      </tr>
  </tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code></code></td>
      <td><p>Toe distances of the given slope profile.</p></td>
    </tr>
  </tbody>
</table>
        <details class="quote">
          <summary>Source code in <code>sandpyper\common.py</code></summary>
          <div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">toes_from_slopes</span><span class="p">(</span>
    <span class="n">series</span><span class="p">,</span> <span class="n">distance_field</span><span class="o">=</span><span class="s2">&quot;distance&quot;</span><span class="p">,</span> <span class="n">slope_field</span><span class="o">=</span><span class="s2">&quot;slope&quot;</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">peak_height</span><span class="o">=</span><span class="mi">30</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns dune toe distance (from transect origin) by extracting peaks higher of a given value</span>
<span class="sd">    from a Gaussian filtered slope profile. It can return multiple candidates when multiple peaks are found.</span>
<span class="sd">    These will be used to clip beachfaces, defined as going from the swash line to dune toes.</span>
<span class="sd">    Args:</span>
<span class="sd">        series (pd.Series): Slope profile.</span>
<span class="sd">        distance_field (str): Field where the distance is stored. Default to &quot;distance&quot;.</span>
<span class="sd">        slope_field (str):  Field where the slope is stored. Default to &quot;slope&quot;.</span>
<span class="sd">        sigma (int): Number of standard deviations sued in the Gaussian smoothing filter.</span>
<span class="sd">        peak_height (int): Threshold to use to define a peak in the smoothed slope profile.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Toe distances of the given slope profile.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sorted_series</span> <span class="o">=</span> <span class="n">series</span><span class="o">.</span><span class="n">sort_values</span><span class="p">([</span><span class="n">distance_field</span><span class="p">])</span>

    <span class="n">gauss</span> <span class="o">=</span> <span class="n">gaussian_filter</span><span class="p">(</span><span class="n">sorted_series</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">slope_field</span><span class="p">],</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">)</span>
    <span class="n">peak</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">find_peaks</span><span class="p">(</span><span class="n">gauss</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="n">peak_height</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">toe_distances</span> <span class="o">=</span> <span class="n">sorted_series</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">peak</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">distance_field</span><span class="p">]</span>

    <span class="k">except</span> <span class="ne">BaseException</span><span class="p">:</span>
        <span class="n">toe_distances</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="k">return</span> <span class="n">toe_distances</span>
</code></pre></div>
        </details>
    </div>

  </div>






  </div>

    </div>

  </div>
                
                  
                    

<hr>
<div class="md-source-date">
  <small>
    
      Last update: 2021-10-13
    
  </small>
</div>
                  
                
              

              
                


              
            </article>
          </div>
        </div>
        
      </main>
      
        
<footer class="md-footer">
  
    <nav class="md-footer__inner md-grid" aria-label="Footer">
      
        
        <a href="../sandpyper/" class="md-footer__link md-footer__link--prev" aria-label="Previous: sandpyper module" rel="prev">
          <div class="md-footer__button md-icon">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
          </div>
          <div class="md-footer__title">
            <div class="md-ellipsis">
              <span class="md-footer__direction">
                Previous
              </span>
              sandpyper module
            </div>
          </div>
        </a>
      
      
        
        <a href="../notebooks/1%20-%20Introduction%20and%20data%20preparation/" class="md-footer__link md-footer__link--next" aria-label="Next: Introduction and data preparation" rel="next">
          <div class="md-footer__title">
            <div class="md-ellipsis">
              <span class="md-footer__direction">
                Next
              </span>
              Introduction and data preparation
            </div>
          </div>
          <div class="md-footer__button md-icon">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11H4z"/></svg>
          </div>
        </a>
      
    </nav>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
        Made with
        <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
          Material for MkDocs
        </a>
        
      </div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    <script id="__config" type="application/json">{"base": "..", "features": ["navigation.instant", "search.highlight", "navigation.expand"], "translations": {"clipboard.copy": "Copy to clipboard", "clipboard.copied": "Copied to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.placeholder": "Search", "search.result.placeholder": "Type to start searching", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.term.missing": "Missing", "select.version.title": "Select version"}, "search": "../assets/javascripts/workers/search.709b4209.min.js", "version": null}</script>
    
    
      <script src="../assets/javascripts/bundle.29db7785.min.js"></script>
      
        <script src="../javascripts/extra.js"></script>
      
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
      
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
      
    
  </body>
</html>